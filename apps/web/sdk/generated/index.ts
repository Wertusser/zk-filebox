
/* Autogenerated file, do not edit! */

/* eslint-disable */

import { Noir, InputMap, type CompiledCircuit, type ForeignCallHandler } from "@noir-lang/noir_js"

export { type ForeignCallHandler } from "@noir-lang/noir_js"

export type Field = string;


export type askInputType = {
  buyer_pub: Field[];
  seller_pub: Field[];
  buyer_priv: Field;
}

export type askReturnType = Field;
export const ask_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"buyer_pub","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"seller_pub","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"buyer_priv","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+z9B5yV1bLtDU+anJVgAAwkA8nOTQuIkoyAATABAh3MYAJMYETMGAETYAKMYAYTYEKMYAYxAEbMGAHD27X26HvB07qPMmreqvdZ6/db3/zo997njPmMUbP+a+7a51YK//kcs3kI99T7z///KvhbpfA/P+V/2x1r5qZ9sqrwnpWZsYHG8mdWK/tWL/vWKPvWLPvWKvvWLvvWKfvWLfvKluuXfTcr+5a9gtCg7Nuw7Nuo7Nu47LtF2XfLsu9WZd+ty75Nyr5Ny77Nyr7blH23LftuV/bdvuzbvOzbouzbsuzbquzbuuy7Q9l3x7LvTmXfncu+bcq+bcu+7cq+7cu+Hcq+u8jey75ZZd/ssm9O2Te37JtX9s0v+xaUfTuWfQvLvruWfTuVfTuXfbuUfXcr+3bFfvco+3Yr+3Yv+/Yo+/bEO+hV/lIqY+2FtQrW8he34ad5+GdGZ/+X/+87/INn/beH7fhPnvVfHrbTP3rW3z9s53/2rL99WJt/+Ky/e1jbf/qsv3lYu3/8rL9+WPt//qy/fFiHf/Gsv3rYLv/mWX/1sH/1rIoflvXvnlXhw7L/5bMqeljOv31WBQ/L/dfP+p8Py/v3z/ofD8vfhGf9+WEFm/KsPz2s4yY9a+OHFW7aszZ62K6b+KwNH9ZpU5+1wcM6b/Kz/u/Dumz6s/7Pw3YjPKv8YV0Zz8LDdqc86z8P24PzrNTDupGeJQ/rznpW2cN60J6Vmd1zg2flZObn5pYUZJdk5WQNzcwuHNYxLzM3b1h+x6yOWXkd84qzO+bklHTM7VhQOKywILMwKzenJKs0rzCnFA/r9b9/VtF/eVZ2qODzv9xz1n/b9IY/OvaU/58NwXXP8H9/gfxTQM39L//fd8Dz/7fP+28P3PGfPu+/PHCnf/y8v3/gzv/8eX/7wDb/4nl/98C2/+Z5f/PAdv/qeX/9wPb/7nl/+cAO//J5f/XAXf7t8/7qgf/6eRU/MOvfP6/CB2ZvwvMqemDOpjyvggfmbtLz/ucD8zbtef/jgfmb+Lw/P7BgU5/3pwd23OTnbfzAwk1/3kYP3JXwvA0f2InxvA0e2JnyvP/7wC6c5/2fB+5Gel75A7uynocH7k573n8euAfveakHdiM+Tx7Ynfm8sgf2oD4vM7fnn573bwG5pPQ/n154Xks873/73My/h+WsHf6Jxvy/f9aO/2i/WX/7rJ3+2bvL+rtn7fwPfSj6m2e1+aee5v/1s9r+43xk/+Wz2v3zrOX/1bPa/4vc5v3Fszr8mxooqPhZu/yreiqs8FmZ/642Cyp6Vta/rPO8Cp6V/S+flV/yP5+V8y+fVZBZ8D+elfuvn9Wx9M/PyvvXzyrMyv7Ts/I34Vm5WRs/q2BTnpVTtNGzOm7Ss4pLN3xW4SY9qySreINn7bqJzyrN+b/P6rSpz8or+D/P6rzJzyrMKn9Wl01/Vk4xnrUb4VklJf95VlfGs0pTD8vanfKs1MOy9uA8Sx6W1Y30rLKHZXVnPau0JKtH4LHYhhefmZv2yfoHF5/D/svFZw6DN8svZPf6B3ss/S+fDe9I5blnh7//D/fLP//b//n/ZS9ZGz6TPSGyF+9ZG10u710utvzF7R3++1TE/8vN/RMT/qHB/+hWfp8/v7h9NngxGi9onw3MYL2sfQKvkvcN3ISWv1d57tn/7r3+V0PlJNu7gudu6ruQOTLWuwgbfFr9Q53pX+XpX+XpX+XpX+XpX+XpX+WZ6V/l6V/l6V/lZn+V/7f/w/+NOZm/yvcj7vGfsPA/+YUvGs/Gc9n8Lu9Sfhux/1Owav9E43/h7er/aL9/z9s1/tm7+1vervkPffg73q71Tz39G96u/Y/z8de8XeefZ+0vebvuv8jtX/F2vX9TA3/B2/X/VT1VzNub/bvarJC3N/+XdV4Rbzf4l8+qiLcb/stnVcTbjf71s/4nbzf+18/6n7y9xSY868+8veWmPOtPvL3VJj1rY97eepOetTFvN9nEZ23I20039Vkb8HazTX7W/+XtbTb9Wf+Ht7clPKuct7djPAu8vT3lWf/h7eacZ6V4uwXpWcLbLVnPKuPtVrRnlZa2DjwWZd53997gWVnFOTm5xYXDirLysvOHDsvsWJwzNLM0tyAnO3NocU5BcXFOx/z8oTk5xfkdSzsWdszOHlqa0zEzr6CgMDM/O6cw+x8wctZ/+68tbMjIovHssPF/TiEMWuVPf6tewd9qVPC3mhX8rVYFf6tdwd/qVPC3uhX8rV4Ff6tfwd82q+Bvm1fwtwYV/K1hBX9rVMHfGlfwty0q+NuWFfxtqwr+tnUFf2tSwd+aVvC3ZhX8bZsK/rZtBX/broK/bV/B35pX8LcWFfytZQV/a1XB31pX8LcdKvjbjhX8bacK/rZzBX9rU8Hf2lbwt3YV/K19BX/rUMHfdqngb5kV/C2rgr9lV/C3nAr+llvB3/Iq+Ft+BX8rqOBvHSv4W2EFf9u1gr91quBvnSv4W5cK/rZbBX/rWsHfdq/gb3tU8LduFfytewV/61HB33rib/KV/+xUzr6/+uyONXNY2e+OoflDi/NzSgpyCofllgwtGpZdkllYnJ9dUFCUlT10WMfijmX/GUJeTm5J5rD87I5lPSGnNH9Y2U+Mgsy8rP9Xz87OKygsyM7MKS0YmjksO7cwOy9PmkRRcVb+sNLCkuLSojJiyMsqHVZY1jlyCgpyh+UUlf3fGdqxILu4oLjjsP9Xz87895/swuzSIsVnd6y8wTP7YO2Ldf8//w+t9Kf/4VnZBUNLh2Z17FicWZxdkl/2AyivuLBjmeNlRFFSVFKcO7S0DKJzMwuGFhZlF+XlZJW9tOLCwpzMnMyhmVlFuX03fFZhXscyGC0tyS8Yll3Usagor2RYUX5mfmF+Ydlv7rI/ZmbnZZbklt2mDM3PGdqx7I9lP91KOnYcWlo6tLQwO/tvdRaXFObl5g3Ny83OLcgq6liQX5o9tKioLHMlefnD8kuLi3OzSjtmFpSWZhXnllFQdseheVlFmZklRaV5pSU5pX02fOFF2R3LQKQwq0x/Tm5pSeGwvOLSsp3m5mSW5BUWFOcVZOWUPaZ0aG7HwjKkyiwjquzMvLysgjKW6ViYN/TvCrUSz1z5ZPXhPSuzArkqRc9+B30jvYP0ARLCAVgPxHrQn/+HZvz5f/gmBmfDgG/qr51+QScoGeSg9CXu+WDynonFmwrXAQhR5T8/d2jJ0OKi/JKSwsLMkuKyvGSXFmaVtYlhZf/he15J2ek+LC+nJCe747DS4o45xVmFpWUHenHZf9Cc37HslWQX5G+Ym+zcoUXFuZkdM8t+sZY1npL8wqFlv1eL80rKrvPKnlz2iIJhWZm5ZUaUvcjS4mFZZSkte1RxTm7+0I6lwzKJB0zWAcp+bMJNRXF+cWbhgX/lxybu+0BeZor6JaM+5JMlez2Y6HP5vg8i7vv/D8DD1smucy2dfZ3oPDDo6Aw8nVFB7BCsh2I9TOvFS8EdEPgH0OHB9sErhXGgwr4Hk/ddmayvD/bNel5f5Iew51QRHIKws/0+JNgGs0OxbzaYHcrzpuhww3XCzovsdXDgnw+HhTSYaepk17mWTi9gdmjQ0Rl4OqOC2RFYh2AdqvXipeAOCfwDaFiwD2aHKuy7JNgHs0MDF8xIh2GqCI5A2Nl+HxFsg9kQ7JsNZkN43hQNM1wn7LzIXksC/3wYGtJgpqmTXedaOr2A2RAlnYGnMyqYlWI9EutRWi9eCu6IwD+Ajg72wWyIwr6PC/bBbEjgghnpMEwVQSnCzva7NNgGsyOxbzaYHcnzpuhow3XCzovs9bjAPx+OCmkw09TJrnMtnV7A7MigozPwdEYFs+OxDsc6QuvFS8GVBv4BdEKwD2ZHKuz75GAfzI4MXDAjHYapIjgeYWf7fXywDWbDsW82mA3neVN0guE6YedF9npy4J8PI0IazDR1sutcS6cXMBsedHQGns6oYHYK1pFYR2m9eCm44wP/ABod7IPZcIV9nx7sg9nwwAUz0mGYKoJTEHa236cE22A2Evtmg9lInjdFow3XCTsvstfTA/98GBXSYKapk13nWjq9gNnIoKMz8HRGBbMzsJ6JdYzWi5eCOyXwD6CxwT6YjVTY9znBPpiNDFwwIx2GqSI4A2Fn+31GsA1mZ2LfbDA7k+dN0VjDdcLOi+z1nMA/H8YEnUaXQdZ5BvFZ5zrZ8ynEZ53nZM/HE591vpM9lxKfNc7Jno8gPusCJ3s+hPis8U72fADxWRcq7ZndUy/a4Fmb+r8JRFPnxRu+z03835ojnCjfzfA86bHSc+QMljNJalQyKx7K+5H/2ZINqQk5C+QMlLNfet4ZG2Rxwx+h4U/7z9zEz1+918xN+2z0v68+cxM/WhovCTq1RA/ppRs8a1P/1xxJmKpsEFL5MSI/PuU/GZCxjSHhP/+FJ/lvo1+K74H42xD8nxmO/zvlNyEZeOafP7sbD4CHkF7G1Bjz2lirupKqkxoEhzoDT2fUa+PLsU7AeoXCi09tSIJ8SeB3nysD11CNwMk3g/zcK4nv8Crld7ip+iScopF81Zk9gfgsy36wfjKW/z9dcAkyzcry5fA3cP2N+p9DXx58NEAvOickXGfg6YwKFNdgvRbrRIUXn9qQBPnywG82k4JtoJDAyZcNFJOI73BysA0UEk7RyAaKa4nPsuwHGyguR6ZZWb4G/gauv1GB4prgowF60XltwnUGns6oQHE91huw3qjw4lMbkiBfE/jN5qZgGygkcPJlA8VNxHc4JdgGCgmnaGQDxQ3EZ1n2gw0U1yDTrCxfD38D19+oQHF98NEAvei8IeE6A09nVKCYhvVmrLcovPjUhiTI1wd+s7k12AYKCZx82UBxK/Ed3hZsA4WEUzSygeJm4rMs+8EGiuuRaVaWp8HfwPU30+tEVnUHGqczNXqdSvJg1AymxpiIPi3wX66GTmolKOq82YlOamAr+BCeHRXRZ2K9A+udWi9+Wtkzpgc+vt0VuIZqFMYMhX3fS943+7/MOg37Zj3vZuSHsOdUEcxE2Nl+z1TO46b+l1nvwL7Z/2XWO3jeFN1luE7YeZG93hv458OdxH3HBDN2/SRd5x0h2ToDT2dUMJuFdTbW+xRefGpDEuSZgX8A3R9sH7wSOPlmkJ97P/EdPhBswkS5PgmnaGTfnc4mPsuyH+y705nINCvLs+Bv4PobFShmBR8N0IvO2QnXGXg6owLFQ1gfxvqIwotPbUiCPCvwm82cYBsoJHDyZQPFHOI7nBtsA4WEUzSygeJh4rMs+8EGilnINCvLD8HfwPU3KlA8FHw0QC86H064zsDTGRUoHsP6ONYnFF58akMS5IcCv9k8GWwDhQROvmygeJL4DucF20Ah4RSNbKB4nPgsy36wgeIhZJqV5cfgb+D6GxUoHgs+GqAXnY8nXGfg6YwKFAuwPoX1aYUXn9qQBPmxwG82zwTbQCGBky8bKJ4hvsNng22gkHCKRjZQPEV8lmU/2EDxGDLNyvIC+Bu4/rodF6/hQONCpkYxyuO4uAejnmdqjInoCxReroZOaiUo6nzKiU5qYCv4EJ4dFdEXYX0B64taL14KbmHg49tLgWuoRmE8r7DvV8n7Zo+LL8C+Wc97Cvkh7DlVBIsQdrbfi5TzuKnj4i9g3+xx8Rd43hS9ZLhO2HmRvb4a+OfDi8R9xwQzdv0kXecLIdk6A09nVDBbjHUJ1tcUXnxqQxLkRYF/AL0ebB+8Ejj5ZpCf+zrxHb4RbMJEuT4Jp2hk350uIT7Lsh/su9NFyDQry4vhb+D6GxUoFgcfDdCLziUJ1xl4OqMCxVtY38b6jsKLT21Igrw48JvN0mAbKCRw8mUDxVLiO1wWbAOFhFM0soHibeKzLPvBBorFyDQry2/B38D1NypQvBV8NEAvOt9OuM7A0xkVKJZjfQ/r+wovPrUhCfJbgd9sPgi2gUICJ182UHxAfIcfBttAIeEUjWygeI/4LMt+sIHiLWSaleXl8Ddw/Y0KFMuDjwboRed7CdcZeDqjAsVKrKuwfqTw4lMbkiAvD/xm83GwDRQSOPmygeJj4jv8JNgGCgmnaGQDxSrisyz7wQaK5cg0K8sr4W/g+ut2XLymA42fMTWKUR7HxT0Y9TlTY0xEX6nwcjV0UitBUecqJzqpga3gQ3h2VERfjfULrF9qvXgpuM8CH9++ClxDNQrjc4V9f0veN3tcfCX2zXreKuSHsOdUEaxG2Nl+r1bO46aOi3+BfbPHxb/geVP0leE6YedF9vpt4J8PXxL3HRPM2PWTdJ1fhGTrDDydUcHsO6xrsH6v8OJTG5Igrw78A+iHYPvglcDJN4P83B+I7/DHYBMmyvVJOEUj++50DfFZlv1g352uRqZZWf4O/gauv1GB4rvgowF60bkm4ToDT2dUoPgZ6y9Y1yq8+NSGJMjfBX6zWRdsA4UETr5soFhHfIfrg22gkHCKRjZQ/EJ8lmU/2EDxHTLNyvLP8Ddw/Y0KFD8HHw3Qi85fEq4z8HRGBYrfsP6O9Q+FF5/akAT558BvNvJAgsb/PCvoBE6+bKDYcN+b+g4rVbINFBJO0cgGit+Jz7LsBxsofkamWVn+Df4Grr9RgeK34KMBetH5e8J1Bp7OqEBRGS+4CtaqlfgvPrUhCfJvgd9sqhkHCgmcfNlAUY3YwKobBwoJZ3UFoKjC23e2ZT/YQPEbMs3KcmX4G7j+uh0Xr+VAY01mRsUoj+PiHoyqxTQqJqJXrsR/uRo6azrRWcWJzlpKOgNPZ1REr40XXAdrXQVEl0+q4CTMbHyrZxzRpTBqKex7c/K+2ePilbFv1vOqID+sIpDg163E97u20Z875ePidbBv9rh4HZ43RfUq2a0Tdl5kr5srnA91ifuOCWbs+km6zjoJ1xl4OqOCWQO84IZYG2ndnUqQayscQI2NH7wSOPlmkJ/bmNi8tjB+dyrh3ELh7rQh8e7Ush/su9PayDQryw3gb+D6GxUoGjhpgF50Nky4zsDTGRUotsIL3hprEy2gkCA3UACKpsaBQgLXUAEomhIbWDPjQCHhbKYAFFsTgcKyH2ygaIBMs7K8FfwNXH+jAsVWThqgF51bJ1xn4OmMChTb4gVvh3V7LaCQIG+lABTNjQOFBG5rBaBoTmxgLYwDhYSzhQJQbEcECst+sIFiK2SaleVt4W/g+hsVKLZ10gC96Nwu4ToDT2dUoGiFF9wa6w5aQCFB3lYBKHY0DhQSuO0UgGJHYgPbyThQSDh3UgCK1kSgsOwHGyi2RaZZWW4FfwPXX7fj4rUdaGzDzKgY5XFc3INRbZlGxUT0Vk6Qso0Tna2d6GyrpDPwdEZF9HZ4we2xdlBAdPmkCq6NAqLvYhzRpTDaKuw7m7xv9rh4K+yb9bzWyA+rCCT4HSrx/W5n9OdO+bh4e+ybPS7enudN0S6V7NYJOy+y12yF86EDcd8xwYxdP0nX2T7hOgNPZ1Qwy8ELzsWap3V3KkFup3AA5Rs/eCVw7RXuTvOJzavA+N2phLNA4e40l3h3atkP9t1pO2SaleUc+Bu4/kYFihwnDdCLztyE6ww8nVGBohAveFesnbSAQoKcowAUnY0DhQQuVwEoOhMbWBfjQCHh7KIAFLsSgcKyH2ygyEGmWVkuhL+B629UoCh00gC96Nw14ToDT2dUoOiKF7w71j20gEKCXKgAFN2MA4UEblcFoOhGbGDdjQOFhLO7AlDsTgQKy36wgaIQmWZluSv8DVx/owJFVycN0IvO3ROuM/B0RgWKnnjBvbDuqQUUEuSuCkCxl3GgSAVOASj2IjawvY0DhYRzbwWg6EUECst+sIGiKzLNynJP+Bu4/rodF6/jQOO+zIyKUR7HxT0YtR/TqJiI3tMJUu7rRGcvJzr3U9IZeDqjInpvvOA+WPsqILp8UgW3rwKi728c0aUw9lPY90HkfbPHxXti36zn9UJ+WEUgwe9bie93b6M/d8rHxftg3+xx8T48b4r2r2S3Tth5kb0epHA+9CXuOyaYsesn6Tr7JFxn4OmMCmb98IL7Yx2gdXcqQe6tcAAdbPzglcD1Ubg7PZjYvA4xfncq4TxE4e60P/Hu1LIf7LvT3sg0K8v94G/g+hsVKPo5aYBedPZPuM7A0xkVKA7DCz4c60AtoJAg91MAikHGgUIC118BKAYRG9hg40Ah4RysABSHE4HCsh9soOiHTLOyfBj8DVx/owLFYU4aoBedhydcZ+DpjAoUQ/CCh2IdpgUUEuTDFICiyDhQSOAOVwCKImIDKzYOFBLOYgWgGEoECst+sIHiMGSaleUh8Ddw/Y0KFEOcNEAvOocmXGfg6YwKFKV4wUdiPUoLKCTIQxSA4mjjQCGBG6oAFEcTG9gxxoFCwnmMAlAcSQQKy36wgWIIMs3Kcin8DVx/3Y6L13Wg8ThmRsUoj+PiHow6nmlUTEQvdYKUxznReaQTnccr6Qw8nVERfThe8AisJyggunxSBXecAqKfaBzRpTCOV9j3KeR9s8fFS7Fv1vOORH5YRSDBP6ES3+/hRn/ulI+Lj8C+2ePiI3jeFJ1YyW6dsPMiez1F4Xw4gbjvmGDGrp+k6xyRcJ2BpzMqmI3ECx6FdbTW3akEebjCAXSq8YNXAjdC4e70VGLzOs343amE8zSFu9NRxLtTy36w706HI9OsLI+Ev4Hrb1SgGOmkAXrROSrhOgNPZ1SgOAMv+EysY7SAQoI8UgEoxhoHCgncKAWgGEtsYGcZBwoJ51kKQHEmESgs+8EGipHINCvLZ8DfwPU3KlCc4aQBetF5ZsJ1Bp7OqEBxDl7wuVjP0wIKCfIZCkBxvnGgkMCdqQAU5xMb2DjjQCHhHKcAFOcSgcKyH2ygOAOZZmX5HPgbuP5GBYpznDRALzrPTbjOwNMZFSjG4wVfiPUiLaCQIJ+jABQXGwcKCdy5CkBxMbGBXWIcKCSclygAxYVEoLDsBxsozkGmWVkeD38D11+34+L1HGi8jJlRMcrjuLgHoy5nGhUT0cc7QcrLnOi80InOy5V0Bp7OqIg+AS/4CqxXKiC6fFIFd5kCol9lHNGlMC5X2Pe15H2zx8XHY9+s512I/LCKQIJ/ZSW+3xOM/twpHxe/Avtmj4tfwfOm6KpKduuEnRfZ67UK58OVxH3HBDN2/SRd5xUJ1xl4OqOC2US84ElYJ2vdnUqQJygcQNcZP3glcFco3J1eR2xe1xu/O5VwXq9wdzqJeHdq2Q/23ekEZJqV5YnwN3D9jQoUE500QC86JyVcZ+DpjAoUN+IF34R1ihZQSJAnKgDFVONAIYGbpAAUU4kNbJpxoJBwTlMAipuIQGHZDzZQTESmWVm+Ef4Grr9RgeJGJw3Qi86bEq4z8HRGBYpb8IJvxXqbFlBIkG9UAIrbjQOFBO4mBaC4ndjAphsHCgnndAWguJUIFJb9YAPFjcg0K8u3wN/A9TcqUNzipAF60XlrwnUGns6oQDETL/gOrHdqAYUE+RYFoLjLOFBI4G5VAIq7iA3sbuNAIeG8WwEo7iAChWU/2EBxCzLNyvJM+Bu4/rodF6/vQOO9zIyKUR7HxT0YNYtpVExEn+kEKe91ovMOJzpnKekMPJ1REX02XvB9WO9XQHT5pAruXgVEf8A4okthzFLY98PkfbPHxWdi36zn3YH8sIpAgn9/Jb7fs43+3CkfF78P+2aPi9/H86bogUp264SdF9nrwwrnw/3EfccEM3b9JF3nfQnXGXg6o4LZI3jBc7DO1bo7lSDPVjiAHjV+8Erg7lO4O32U2LweM353KuF8TOHudA7x7tSyH+y709nINCvLj8DfwPU3KlA84qQBetE5J+E6A09nVKB4Ai/4SazztIBCgvyIAlDMNw4UErg5CkAxn9jAFhgHCgnnAgWgeJIIFJb9YAPFI8g0K8tPwN/A9TcqUDzhpAF60flkwnUGns6oQPE0XvAzWJ/VAgoJ8hMKQPGccaCQwD2pABTPERvYQuNAIeFcqAAUzxCBwrIfbKB4AplmZflp+Bu4/kYFiqedNEAvOp9JuM7A0xkVKBbhBb+A9UUtoJAgP60AFC8ZBwoJ3DMKQPESsYG9bBwoJJwvKwDFC0SgsOwHGyieRqZZWV4EfwPXX7fj4ps50PgqM6NilMdxcQ9GLWYaFRPRFzlByled6HzBic7FSjoDT2dURF+CF/wa1tcVEF0+qYJ7VQHR3zCO6FIYixX2/TZ53+xx8UXYN+t5LyA/rCKQ4L9eie/3EqM/d8rHxV/Dvtnj4q/xvCl6o5LdOmHnRfb6tsL58Dpx3zHBjF0/Sdf5WsJ1Bp7OqGD2Dl7wUqzLtO5OJchLFA6gd40fvBK41xTuTt8lNq/lxu9OJZzLFe5OlxLvTi37wb47XYJMs7L8DvwNXH+jAsU7ThqgF51LE64z8HRGBYr38YI/wPqhFlBIkN9RAIoVxoFCArdUAShWEBvYSuNAIeFcqQAUHxCBwrIfbKB4B5lmZfl9+Bu4/kYFivedNEAvOj9IuM7A0xkVKD7CC/4Y6ydaQCFBfl8BKD41DhQSuA8UgOJTYgP7zDhQSDg/UwCKj4lAYdkPNlC8j0yzsvwR/A1cf6MCxUdOGqAXnR8nXGfg6YwKFKvxgr/A+qUWUEiQP1IAiq+MA4UE7mMFoPiK2MC+Ng4UEs6vFYDiCyJQWPaDDRQfIdOsLK+Gv4Hrr9tx8c0daPyWmVExyuO4uAejvmMaFRPRVztBym+d6PzCic7vlHQGns6oiL4GL/h7rD8oILp8UgX3rQKi/2gc0aUwvlPY9y/kfbPHxVdj36znfYH8sIpAgv9DJb7fa4z+3CkfF/8e+2aPi3/P86box0p264SdF9nrLwrnww/EfccEM3b9JF3n9wnXGXg6o4LZWrzgdVjXa92dSpDXKBxAvxo/eCVw3yvcnf5KbF6/Gb87lXD+pnB3uo54d2rZD/bd6RpkmpXltfA3cP2NChRrnTRALzrXJVxn4OmMChR/lL9gHDqVMvgvPrUhCfJaBaDIyLANFBK4dQpAseG+N/UdVs6wDRTy8kQjGygCb9/Zlv1gA8VaZJqVZTmEKpeLDD6B4g8nDdCLzpCRbJ2BpzMqUFRFHVfDWl0LKCTIfygARQ3jQJE60TL4QFGD2MBqGgcKCWdNBaCoRgQKy36wgSL1K4SnMasq/A1cf6MCRVUnDdCLzmoJ1xl4OqMCRW3UcR2sdbWAQoIsX3azqWccKCRw1RSAoh6xgdU3DhQSzvoKQFGHCBSW/WADRVVkmpXl2vA3cP11Oy7ewIHGzZkZFaM8jot7MKoB06iYiF7bCVJu7kRnHSc6GyjpDDydURG9ITpjI6yNFRBdPqmC21wB0bcwjuhSGA0U9r01ed/scfHa2DfreXWQH1YRSPAbZ/D9bmj05075uHgj7Js9Lt6I503RFhl264SdF9nr1grnQ2PivmOCGbt+kq6zUcJ1Bp7OqGDWBCDWFGuzDP6LT21IgtxQ4QDaxvjBK4FrpHB3ug2xeW1r/O5Uwrmtwt1pU+LdqWU/Mkh+lN+dNkSmWVluAn8D19+oQNHESQP0orNpwnUGns6oQLE96rg51hZaQCFBbqIAFC2NA4UErqkCULQkNrBWxoFCwtlKASiaE4HCsh9soGiCTLOyvD38DVx/owLF9k4aoBedzROuM/B0RgWKHVDHO2LdSQsoJMjbKwDFzsaBQgLXXAEodiY2sDbGgULC2UYBKHYkAoVlP9hAsT0yzcryDvA3cP2NChQ7OGmAXnTumHCdgaczKlC0Qx23x9pBCygkyDsoAMUuxoFCArejAlDsQmxgmcaBQsKZqQAU7YlAYdkPNlDsgEyzstwO/gauv27HxRs60JjNzKgY5XFc3INROUyjYiJ6OydIme1EZ3snOnOUdAaezqiInovOmIc1XwHR5ZMquGwFRC8wjuhSGDkK+96VvG/2uHg77Jv1vPbID6sIJPj5GXy/c43+3CkfF8/Dvtnj4nk8b4oKMuzWCTsvstddFc6HfOK+Y4IZu36SrjMv4ToDT2dUMOsEEOuMtUsG/8WnNiRBzlU4gHYzfvBK4PIU7k53IzavrsbvTiWcXRXuTjsT704t+5FB8qP87jQXmWZluRP8DVx/owJFJycN0IvOzgnXGXg6owLFHqjjbli7awGFBLmTAlD0MA4UErjOCkDRg9jAehoHCglnTwWg6EYECst+sIGiEzLNyvIe8Ddw/Y0KFHs4aYBedHZLuM7A0xkVKPZEHe+FdW8toJAg76EAFPsYBwoJXDcFoNiH2MD2NQ4UEs59FYBiLyJQWPaDDRR7INOsLO8JfwPX36hAsaeTBuhF514J1xl4OqMCRW/UcR+sfbWAQoK8pwJQ7G8cKCRweykAxf7EBnaAcaCQcB6gABR9iEBh2Q82UOyJTLOy3Bv+Bq6/bsfFGznQeBAzo2KUx3FxD0b1YxoVE9F7O0HKg5zo7ONEZz8lnYGnMyqi90dnHID1YAVEl0+q4A5SQPRDjCO6FEY/hX0fTt43e1y8N/bNel4f5IdVBBL8gzP4fvc3+nOnfFx8APbNHhcfwPOm6JAMu3XCzovs9XCF8+Fg4r5jghm7fpKuc0DCdQaezqhgNhAgNgjr4Az+i09tSILcX+EAOsL4wSuBG6Bwd3oEsXkNMX53KuEconB3Ooh4d2rZjwySH+V3p/2RaVaWB8LfwPU3KlAMdNIAvegclHCdgaczKlAMQx0XYS3WAgoJ8kAFoCgxDhQSuEEKQFFCbGClxoFCwlmqABRFRKCw7AcbKAYi06wsD4O/getvVKAY5qQBetFZlHCdgaczKlAchTo+GusxWkAhQR6mABTHGgcKCVyRAlAcS2xgxxkHCgnncQpAcTQRKCz7wQaKYcg0K8tHwd/A9TcqUBzlpAF60Xl0wnUGns6oQDEcdTwC6wlaQCFBPkoBKE40DhQSuKMVgOJEYgM7yThQSDhPUgCKEUSgsOwHGyiOQqZZWR4OfwPXX7fj4o0daDyFmVExyuO4uAejRjKNionow50g5SlOdI5wonOkks7A0xkV0UehM47GeqoCossnVXCnKCD6acYRXQpjpMK+zyTvmz0uPhz7Zj1vBPLDKgIJ/qkZfL9HGf25Uz4uPhr7Zo+Lj+Z5U3Raht06YedF9nqmwvlwKnHfMcGMXT9J1zk64ToDT2dUMBsDEBuL9awM/otPbUiCPErhADrb+MErgRutcHd6NrF5nWP87lTCeY7C3elY4t2pZT8ySH6U352OQqZZWR4DfwPX36hAMcZJA/Sic2zCdQaezqhAcR7q+Hys47SAQoI8RgEoLjAOFBK4sQpAcQGxgY03DhQSzvEKQHE+ESgs+8EGijHINCvL58HfwPU3KlCc56QBetF5fsJ1Bp7OqEBxEer4YqyXaAGFBPk8BaC41DhQSODOVwCKS4kN7DLjQCHhvEwBKC4mAoVlP9hAcR4yzcryRfA3cP2NChQXOWmAXnRenHCdgaczKlBMQB1fgfVKLaCQIF+kABRXGQcKCdzFCkBxFbGBXW0cKCScVysAxRVEoLDsBxsoLkKmWVmeAH8D11+34+JbONB4LTOjYpTHcXEPRk1kGhUT0Sc4Qcprnei8wonOiUo6A09nVESfhM44Get1Cogun1TBXauA6NcbR3QpjIkK+76JvG/2uPgE7Jv1vCuQH1YRSPCvy+D7Pcnoz53ycfHJ2Dd7XHwyz5ui6zPs1gk7L7LXmxTOh+uI+44JZuz6SbrOyQnXGXg6o4LZFIDYVKzTMvgvPrUhCfIkhQPoZuMHrwRussLd6c3E5nWL8btTCectCnenU4l3p5b9yCD5UX53OgmZZmV5CvwNXH+jAsUUJw3Qi86pCdcZeDqjAsVtqOPbsU7XAgoJ8hQFoJhhHCgkcFMVgGIGsYHNNA4UEs6ZCkBxOxEoLPvBBoopyDQry7fB38D1NypQ3OakAXrReXvCdQaezqhAcSfq+C6sd2sBhQT5NgWguMc4UEjgblcAinuIDexe40Ah4bxXASjuIgKFZT/YQHEbMs3K8p3wN3D9jQoUdzppgF503pVwnYGnMypQzEYd34f1fi2gkCDfqQAUDxgHCgncXQpA8QCxgT1oHCgknA8qAMV9RKCw7AcbKO5EpllZng1/A9dft+PiWzrQ+DAzo2KUx3FxD0Y9wjQqJqLPdoKUDzvReZ8TnY8o6Qw8nVERfQ4641ysjyogunxSBfewAqI/ZhzRpTAeUdj3k+R9s8fFZ2PfrOfdh/ywikCC/2gG3+85Rn/ulI+Lz8W+2ePic3neFD2WYbdO2HmRvT6pcD48Stx3TDBj10/Sdc5NuM7A0xkVzOYBxOZjXZDBf/GpDUmQ5ygcQE8ZP3glcHMV7k6fIjavp43fnUo4n1a4O51PvDu17EcGyY/yu9M5yDQry/Pgb+D6GxUo5jlpgF50zk+4zsDTGRUonkUdP4d1oRZQSJDnKQDF88aBQgI3XwEonic2sEXGgULCuUgBKJ4jAoVlP9hAMQ+ZZmX5WfgbuP5GBYpnnTRALzqfS7jOwNMZFSheRB2/hPVlLaCQID+rABSvGAcKCdxzCkDxCrGBvWocKCScryoAxUtEoLDsBxsonkWmWVl+Ef4Grr9RgeJFJw3Qi86XEq4z8HRGBYolqOPXsL6uBRQS5BcVgOIN40AhgXtJASjeIDawN40DhYTzTQWgeI0IFJb9YAPFi8g0K8tL4G/g+ut2XHwrBxrfZmZUjPI4Lu7BqHeYRsVE9CVOkPJtJzpfc6LzHSWdgaczKqIvRWdchvVdBUSXT6rg3lZA9OXGEV0K4x2FfX9A3jd7XHwJ9s163mvID6sIJPjvZvD9Xmr05075uPgy7Js9Lr6M503R8gy7dcLOi+z1A4Xz4V3ivmOCGbt+kq5zWcJ1Bp7OqGD2IUBsBdaVGfwXn9qQBHmpwgG0yvjBK4FbpnB3uorYvD4yfncq4fxI4e50BfHu1LIfGSQ/yu9OlyLTrCx/CH8D19+oQPGhkwboReeKhOsMPJ1RgeIT1PGnWD/TAgoJ8ocKQPG5caCQwK1QAIrPiQ1stXGgkHCuVgCKT4lAYdkPNlB8iEyzsvwJ/A1cf6MCxSdOGqAXnZ8mXGfg6YwKFF+ijr/C+rUWUEiQP1EAim+MA4UE7lMFoPiG2MC+NQ4UEs5vFYDiKyJQWPaDDRSfINOsLH8JfwPX36hA8aWTBuhF51cJ1xl4OqMCxRrU8fdYf9ACCgnylwpA8aNxoJDAfaUAFD8SG9hPxoFCwvmTAlB8TwQKy36wgeJLZJqV5TXwN3D9dTsuvrUDjb8wMypGeRwX92DUWqZRMRF9jROk/MWJzu+d6FyrpDPwdEZF9HXojOux/qqA6PJJFdwvCoj+m3FEl8JYq7BvYQ/mvtnj4muwb9bzvkd+WEUgwf81g+/3OqM/d8rHxddj3+xx8fU8b4p+y7BbJ+y8/IbfEezz4VdiDmOCGbt+kq5zfcJ1Bp7OqGBWCf/IwFq5Mv/FpzYkQV6nAChVjB+8Erj1CnenG+57U99h1co2YaJcn4RTNLLvTjN4+8627Af77nQdMs3KciX4G7j+RgWKSpV9NEAvOjMSrjPwdEYFiur4Rw2sNbWAQoJcSeEXTS3jQCGBS33Jz61FbGC1jQOFhLO2AlDUIAKFZT/YQFEJmWZluTr8DVx/owJFdScN0IvOGgnXGXg6owJFXfyjHtb6WkAhQa6uABSbGQcKCVwNBaDYjNjANjcOFBLOzRWAoh4RKCz7wQaK6sg0K8t14W/g+hsVKOo6aYBedNZLuM7A0xkVKBriH42wNtYCCglyXQWg2MI4UEjg6ikAxRbEBralcaCQcG6pABSNiEBh2Q82UNRFpllZbgh/A9dft+PiTRxo3JqZUTHK47i4B6OaMI2KiegNnSDl1k50NnKis4mSzsDTGRXRm+IfzbBuo4Do8kkV3NYKiL6tcUSXwmiisO/mxsfFG2LfrOc1Qn5YRSDB36Yy3++mRn/ulI+LN8O+2ePizXjeFG1b2W6dsPMie22ucD5sQ9x3TDBr6gQkvOhslnCdgaczKpi1wD9aYm2ldXcqQW6qcAC1Nn7wSuCaKdydtiY2rx2M351KOHdQuDttSbw7tewH++60KTLNynIL+Bu4/kYFihZOGqAXnS0TrjPwdEYFip3wj52xttECCglyCwWgaGscKCRwLRWAoi2xgbUzDhQSznYKQLEzESgs+8EGihbINCvLO8HfwPU3KlDs5KQBetG5c8J1Bp7OqEDRAf/YBWumFlBIkHdSAIos40AhgdtZASiyiA0s2zhQSDizFYBiFyJQWPaDDRQ7IdOsLHeAv4Hrb1Sg6OCkAXrRuUvCdQaezqhAkYt/5GHN1wIKCXIHBaAoMA4UErhdFICigNjAOhoHCglnRwWgyCMChWU/2EDRAZlmZTkX/gauv27HxZs60LgrM6NilMdxcQ9GdWIaFRPRc50g5a5OdOY50dlJSWfg6YyK6J3xjy5Yd1NAdPmkCm5XBUTvahzRpTA6Key7G3nflcn6crFv1vPykB9WEUjwd6vM97uz0Z875ePiXbBv8s+drC48b4q6VrZbJ+y8yF67KZwPuxH3HRPMOjsBCS86uyRcZ+DpjApm3fGPHlh7at2dSpA7KxxAvYwfvBK4Lgp3p72IzWtP43enEs49Fe5OexDvTi37wb477YxMs7LcHf4Grr9RgaK7kwboRWePhOsMPJ1RgWJv/GMfrPtqAYUEubsCUOxnHCgkcD0UgGI/YgPrbRwoJJy9FYBiHyJQWPaDDRTdkWlWlveGv4Hrb1Sg2NtJA/Sic5+E6ww8nVGBoi/+sT/WA7SAQoK8twJQHGgcKCRw+ygAxYHEBnaQcaCQcB6kABT7E4HCsh9soNgbmWZluS/8DVx/owJFXycN0IvO/ROuM/B0RgWK/vjHAKwHawGFBLmvAlAcYhwoJHD7KwDFIcQGdqhxoJBwHqoAFAOIQGHZDzZQ9EWmWVnuD38D11+34+LNHGg8nJlRMcrjuLgHowYyjYqJ6P2dIOXhTnQOcKJzoJLOwNMZFdEH4R+DsR6hgOjySRXc4QqIPsQ4okthDFTYdxF535XJ+vpj36znDUB+WEUgwT+iMt/vQUZ/7pSPiw/Gvsk/d7IG87wpGlLZbp2w8yJ7LVI4H44g7jsmmA1yAhJedA5OuM7A0xkVzIrxjxKspVp3pxLkQQoH0JHGD14J3GCFu9Mjic3rKON3pxLOoxTuTkuId6eW/WDfnQ5CpllZLoa/getvVKAodtIAvegsSbjOwNMZFSiOwT+OxXqcFlBIkIsVgOJ440AhgStRAIrjiQ1suHGgkHAOVwCKY4lAYdkPNlAUI9OsLB8DfwPX36hAcYyTBuhF57EJ1xl4OqMCxQn4x4lYT9ICCgnyMQpAcbJxoJDAHasAFCcTG9gpxoFCwnmKAlCcSAQKy36wgeIYZJqV5RPgb+D6GxUoTnDSAL3oPDHhOgNPZ1SgGIV/jMZ6qhZQSJBPUACK04wDhQTuRAWgOI3YwE43DhQSztMVgGI0ESgs+8EGihOQaVaWR8HfwPXX7bj4Ng40nsnMqBjlcVzcg1FjmEbFRPRRTpDyTCc6RzvROUZJZ+DpjIroY/GPs7CerYDo8kkV3JkKiH6OcUSXwhijsO/zyfuuTNY3CvtmPW808sMqAgn+2ZX5fo81+nOnfFz8LOyb/HMn6yyeN0XnVLZbJ+y8yF7PVzgfzibuOyaYjXUCEl50npVwnYGnMyqYjcM/LsA6XuvuVII8VuEAutD4wSuBO0vh7vRCYvO6yPjdqYTzIoW70wuId6eW/WDfnY5FpllZHgd/A9ffqEAxzkkD9KLzgoTrDDydUYHiEvzjUqyXaQGFBHmcAlBcbhwoJHAXKADF5cQGNsE4UEg4JygAxaVEoLDsBxsoxiHTrCxfAn8D19+oQHGJkwboReelCdcZeDqjAsWV+MdVWK/WAgoJ8iUKQHGNcaCQwF2qABTXEBvYtcaBQsJ5rQJQXEUECst+sIHiEmSaleUr4W/g+hsVKK500gC96Lwq4ToDT2dUoJiEf0zGep0WUEiQr1QAiuuNA4UE7ioFoLie2MBuMA4UEs4bFIBiMhEoLPvBBoorkWlWlifB38D11+24+LYONN7EzKgY5XFc3INRU5hGxUT0SU6Q8iYnOic70TlFSWfg6YyK6FPxj2lYb1ZAdPmkCu4mBUS/xTiiS2FMUdj37eR9Vybrm4R9s543GflhFYEE/+bKfL+nGv25Uz4uPg37Jv/cyZrG86bolsp264SdF9nr7Qrnw83EfccEs6lOQMKLzmkJ1xl4OqOC2XT8YwbWmVp3pxLkqQoH0B3GD14J3DSFu9M7iM3rTuN3pxLOOxXuTmcQ704t+8G+O52KTLOyPB3+Bq6/UYFiupMG6EXnjITrDDydUYHibvzjHqz3agGFBHm6AlDMMg4UErgZCkAxi9jAZhsHCgnnbAWguIcIFJb9YAPFdGSaleW74W/g+hsVKO520gC96Lwn4ToDT2dUoLgf/3gA64NaQCFBvlsBKB4yDhQSuHsUgOIhYgN72DhQSDgfVgCKB4hAYdkPNlDcjUyzsnw//A1cf6MCxf1OGqAXnQ8kXGfg6YwKFHPwj7lYH9UCCgny/QpA8ZhxoJDAPaAAFI8RG9jjxoFCwvm4AlDMJQKFZT/YQHE/Ms3K8hz4G7j+uh0X386BxieZGRWjPI6LezBqHtOomIg+xwlSPulE51wnOucp6Qw8nVERfT7+sQDrUwqILp9UwT2pgOhPG0d0KYx5Cvt+jrzvymR9c7Bv1vPmIj+sIpDgP1WZ7/d8oz93ysfFF2Df5J87WQt43hQ9XdlunbDzInt9TuF8eIq475hgNt8JSHjRuSDhOgNPZ1QwW4h/PI91kdbdqQR5vsIB9ILxg1cCt0Dh7vQFYvN60fjdqYTzRYW70+eJd6eW/WDfnc5HpllZXgh/A9ffqECx0EkD9KLz+YTrDDydUYHiZfzjFayvagGFBHmhAlAsNg4UErjnFYBiMbGBLTEOFBLOJQpA8QoRKCz7wQaKhcg0K8svw9/A9TcqULzspAF60flKwnUGns6oQPE6/vEG1je1gEKC/LICULxlHCgkcK8oAMVbxAb2tnGgkHC+rQAUbxCBwrIfbKB4GZlmZfl1+Bu4/kYFitedNEAvOt9IuM7A0xkVKJbiH8uwvqsFFBLk1xWAYrlxoJDAvaEAFMuJDew940Ah4XxPASiWEYHCsh9soHgdmWZleSn8DVx/3Y6Lb+9A4wfMjIpRHsfFt3eg8UOmUTERfakTpPzAic5lTnR+qKQz8HRGRfQV+MdKrKsUEF0+qYL7QAHRPzKO6FIYHyrs+1PyviuT9S3FvlnPW4b8sIpAgr+qMt/vFUZ/7pSPi6/Evsk/d7JW8rwp+qiy3Tph50X2+qnC+bCKuO+YYLbCCUh40bky4ToDT2dUMPsM//gc62qtu1MJ8gqFA+gL4wevBG6lwt3pF8Tm9aXxu1MJ55cKd6efE+9OLfvBvjtdgUyzsvwZ/A1cf6MCxWdOGqAXnZ8nXGfg6YwKFF/jH99g/VYLKCTInykAxXfGgUIC97kCUHxHbGBrjAOFhHONAlB8QwQKy36wgeIzZJqV5a/hb+D6GxUovnbSAL3o/CbhOgNPZ1Sg+AH/+BHrT1pAIUH+WgEofjYOFBK4bxSA4mdiA/vFOFBIOH9RAIofiUBh2Q82UHyNTLOy/AP8DVx/owLFD04aoBedPyZcZ+DpjAoU6/CP9Vh/1QIKCfIPCkDxm3GgkMD9qAAUvxEb2O/GgULC+bsCUKwnAoVlP9hA8QMyzcryOvgbuP66HRdv7kCjTA7TNIpRHsfFPRhViWlUTERf5wQpqZWgqHO9k/dZSel9Bp7OqIiegZOxMtYqVZRefOq3QBU+vlUlG6pRGJUU9l2DvO/KZH3rsG/W89YjP6wikOBXqcL3O0M5j5s6Ll4Z+2aPi1fmeVNUtYrdOmHnRfZaQ+F8qELcd0wwy3ACPF50Vk64zsDTGRXMagLEamGtrQBmqQ1JkDMUDqA6xg9eCZx8M8jPrUNsXnWNwkS5PglnXT5MZNfi7Tvbsh/su9MMZJqV5ZrwN3D9jQoUNZ00QC86ayVcZ+DpjAoU9VHHm2HdXAsoJMg1FYCigXGgkMDVUgCKBsQG1tA4UEg4GyoAxWZEoLDsBxsoaiLTrCzXh7+B629UoKjvpAF60blZwnUGns6oQNEYdbwF1i21gEKCXF8BKLYyDhQSuM0UgGIrYgPb2jhQSDi3VgCKLYhAYdkPNlDUR6ZZWW4MfwPX36hA0dhJA/Sic4uE6ww8nVGBoinquBnWbbSAQoLcWAEotjUOFBK4LRSAYltiA9vOOFBIOLdTAIpmRKCw7AcbKBoj06wsN4W/geuv23HxFg40Nk+Pi/swqoXXcfGmTpCyuROdzZzobKGkM/B0RkX0ljgZW2FtrYDo8kkVXHMFRN/BOKJLYbRQ2PfOxsfFm2LfrOc1Q35YRSDBb12F73dLoz93ysfFW2Hf7HHxVsRx8R2q2K0Tdl5krzsrnA+tnY6Lt3QCEl50tkq4zsDTGRXM2gDE2mJtp3V3KkFuqXAAtTd+8ErgWincnbYnNq8Oxu9OJZwdFO5O2xLvTi37wb47bYlMs7LcBv4Grr9RgaKNkwboRWfbhOsMPJ1RgSITdZyFNVsLKCTIbRSAIsc4UEjg2ioARQ6xgeUaBwoJZ64CUGQRgcKyH2ygaINMs7KcCX8D19+oQJHppAF60ZmVcJ2BpzMqUOSjjguwdtQCCglypgJQFBoHCglclgJQFBIb2K7GgULCuasCUBQQgcKyH2ygyESmWVnOh7+B629UoMh30gC96CxIuM7A0xkVKDqjjrtg3U0LKCTI+QpA0dU4UEjgChSAoiuxge1uHCgknLsrAEUXIlBY9oMNFPnINCvLneFv4Prrdly8pQON3ZgZFaOqpI1S0didaVRMRO/sBCm7OdHZxYnO7ko6A09nVETvgZOxJ9ZeCogun1TBdVNA9D2NI7oURneFfe9D3jd7XLwz9s16Xhfkh1UEEvxeVfh+9zD6c6d8XLwn9s0eF+9JHBffs4rdOmHnRfa6j8L50MvpuHgPJyDhRWfPhOsMPJ1RwWxfgNh+WHtr3Z1KkHsoHEB9jB+8ErieCnenfYjNq6/xu1MJZ1+Fu9P9iHenlv1g3532QKZZWd4X/gauv1GBYl8nDdCLzv0SrjPwdEYFigNQxwdiPUgLKCTI+yoART/jQCGB208BKPoRG1h/40Ah4eyvABQHEoHCsh9soNgXmWZl+QD4G7j+RgWKA5w0QC86D0y4zsDTGRUoDkYdH4L1UC2gkCAfoAAUhxkHCgncgQpAcRixgR1uHCgknIcrAMUhRKCw7AcbKA5ApllZPhj+Bq6/UYHiYCcN0IvOQxKuM/B0RgWKQajjwViP0AIKCfLBCkAxxDhQSOAOUQCKIcQGNtQ4UEg4hyoAxWAiUFj2gw0UByPTrCwPgr+B66/bcfFWDjQWMTMqRlVJG6WisZhpVExEH+QEKYuc6BzsRGexks7A0xkV0UtwMpZiPVIB0eWTKrgiBUQ/yjiiS2EUK+z7WPK+2ePig7Bv1vMGIz+sIpDgH1mF73eJ0Z875ePipdg3e1y8lOdN0VFV7NYJOy+y12MVzocjifuOCWYlTkDCi87ShOsMPJ1Rwew4gNjxWIdr3Z1KkEsUDqARxg9eCVypwt3pCGLzOsH43amE8wSFu9PjiXenlv1g352WINOsLB8HfwPX36hAcZyTBuhF5/EJ1xl4OqMCxUmo45OxnqIFFBLk4xSAYqRxoJDAHa8AFCOJDWyUcaCQcI5SAIqTiUBh2Q82UByHTLOyfBL8DVx/owLFSU4aoBedJydcZ+DpjAoUp6KOT8N6uhZQSJBPUgCKM4wDhQTuZAWgOIPYwM40DhQSzjMVgOI0IlBY9oMNFCch06wsnwp/A9ffqEBxqpMG6EXnaQnXGXg6owLFWNTxWVjP1gIKCfKpCkBxjnGgkMCdpgAU5xAb2LnGgULCea4CUJxFBArLfrCB4lRkmpXlsfA3cP11Oy7e2oHG85kZFaOqpI1S0TiOaVRMRB/rBCnPd6LzLCc6xynpDDydURH9ApyM47FeqIDo8kkV3PkKiH6RcUSXwhinsO9Lyftmj4uPxb5ZzzsL+WEVgQT/wip8vy8w+nOnfFx8PPbNHhcfTxwXv6iK3Tph50X2eqnC+XCh03HxC5yAhBed4xOuM/B0RgWzywBil2OdoHV3KkG+QOEAusL4wSuBG69wd3oFsXldafzuVMJ5pcLd6eXEu1PLfrDvTi9ApllZvgz+Bq6/UYHiMicN0IvOyxOuM/B0RgWKq1HH12C9VgsoJMiXKQDFRONAIYG7XAEoJhIb2CTjQCHhnKQAFNcQgcKyH2yguAyZZmX5avgbuP5GBYqrnTRALzqvSbjOwNMZFSiuQx1fj/UGLaCQIF+tABQ3GgcKCdw1CkBxI7GB3WQcKCScNykAxfVEoLDsBxsorkamWVm+Dv4Grr9RgeI6Jw3Qi87rE64z8HRGBYqpqONpWG/WAgoJ8nUKQHGLcaCQwF2vABS3EBvYrcaBQsJ5qwJQTCMChWU/2EBxHTLNyvJU+Bu4/rodF9/BgcbbmRkVo6qkjVLROJ1pVExEn+oEKW93onOaE53TlXQGns6oiD4DJ+NMrHcoILp8UgV3uwKi32kc0aUwpivs+x7yvtnj4lOxb9bzpiE/rCKQ4N9Rhe/3DKM/d8rHxWdi3+xx8ZnEcfE7q9itE3ZeZK/3KJwPdzgdF5/hBCS86JyZcJ2BpzMqmN0LEJuFdbbW3akEeYbCAXSf8YNXAjdT4e70PmLzut/43amE836Fu9NZxLtTy36w705nINOsLN8LfwPX36hAca+TBuhF56yE6ww8nVGB4kHU8UNYH9YCCgnyvQpA8YhxoJDAzVIAikeIDWyOcaCQcM5RAIqHiEBh2Q82UNyLTLOy/CD8DVx/owLFg04aoBedDyVcZ+DpjAoUj6KOH8P6uBZQSJAfVACKJ4wDhQTuIQWgeILYwJ40DhQSzicVgOIxIlBY9oMNFA8i06wsPwp/A9ffqEDxqJMG6EXnYwnXGXg6owLFfNTxAqxPaQGFBPlRBaB42jhQSOAeUwCKp4kN7BnjQCHhfEYBKBYQgcKyH2ygeBSZZmV5PvwNXH/djovv6EDjc8yMilFV0kapaFzINComos93gpTPOdG5wInOhUo6A09nVER/HifjIqwvKCC6fFIF95wCor9oHNGlMBYq7PsV8r7Z4+LzsW/W8xYgP6wikOC/UIXv9/NGf+6Uj4svwr7Z4+KLiOPiL1axWyfsvMheX1E4H15wOi7+vBOQ8KJzUcJ1Bp7OqGD2KkBsMdYlWnenEuTnFQ6g14wfvBK4RQp3p68Rm9frxu9OJZyvK9ydLibenVr2g313+jwyzcryq/A3cP2NChSvOmmAXnQuTrjOwNMZFSjeRB2/hfVtLaCQIL+qABTvGAcKCdxiBaB4h9jAlhoHCgnnUgWgeIsIFJb9YAPFq8g0K8tvwt/A9TcqULzppAF60flWwnUGns6oQPEu6ng51ve0gEKC/KYCULxvHCgkcG8pAMX7xAb2gXGgkHB+oAAUy4lAYdkPNlC8iUyzsvwu/A1cf6MCxbtOGqAXncsTrjPwdEYFihWo45VYV2kBhQT5XQWg+Mg4UEjglisAxUfEBvaxcaCQcH6sABQriUBh2Q82ULyLTLOyvAL+Bq6/bsfFd3Kg8VNmRsWoKmmjVDR+xjQqJqKvcIKUnzrRudKJzs+UdAaezqiI/jlOxtVYv1BAdPmkCu5TBUT/0jiiS2F8prDvb8j7Zo+Lr8C+Wc9bifywikCC/0UVvt+fG/25Uz4uvhr7Zo+LryaOi39ZxW6dsPMie/1G4Xz4wum4+OdOQMKLztUJ1xl4OqOC2bcAse+wrtG6O5Ugf65wAH1v/OCVwK1WuDv9nti8fjB+dyrh/EHh7vQ74t2pZT/Yd6efI9OsLH8LfwPX36hA8a2TBuhF53cJ1xl4OqMCxU+o45+x/qIFFBLkbxWAYq1xoJDAfacAFGuJDWydcaCQcK5TAIqfiUBh2Q82UHyLTLOy/BP8DVx/owLFT04aoBedPydcZ+DpjAoUv6KOf8P6uxZQSJB/UgCKP4wDhQTuZwWg+IPYwEJV20CRCmdVPlD8RgQKy36wgeInZJqV5V/hb+D6GxUofnXSAL3o/C3hOgNPZ1SgyEAdV8ZapSr/xac2JEH+VQEoqio3w8xN+6QC95sCUGy47019h9WMA4WEs5oCUFTm7Tvbsh9soPgVmWZlOQP+Bq6/bsfFd3agsQYzo2JUlbRRKhprMo2KiegZVfkvV0NnDSc6KzvRWVNJZ+DpjIrotdAZa2Oto4Do8kkVnISZjW91jSO6FEZNhX1vRt43e1w8A/tmPa8y8sMqAgl+nap8v2sZ/blTPi5eG/tmj4vX5nlTVLeq3Tph50X2upnC+VCHuO+YYFbLCUh40Vk74ToDT2dUMNscINYAa0Otu1MJci2FA6iR8YNXAiffDPJzGxGbV2Pjd6cSzsYKd6cNiHenlv1g353WQqZZWd4c/gauv1GBYnMnDdCLzgYJ1xl4OqMCxZao462wbq0FFBLkzRWAoolxoJDANVAAiibEBtbUOFBIOJsqAMVWRKCw7AcbKDZHpllZ3hL+Bq6/UYFiSycN0IvOrRKuM/B0RgWKbVDH22LdTgsoJMhbKgDF9saBQgK3lQJQbE9sYM2NA4WEs7kCUGxLBArLfrCBYktkmpXlbeBv4PobFSi2cdIAvejcNuE6A09nVKBoiTpuhbW1FlBIkLdRAIodjAOFBG5bBaDYgdjAdjQOFBLOHRWAohURKCz7wQaKbZBpVpZbwt/A9dftuHgbBxp3To+L+zCqjddx8ZZOkHJnJzpbOdHZJo3oGyF6W3TGdljbKyC6fFIFt7MConcwjuhSGG0U9p1lfFy8JfbNel4r5IdVBBL89lX5frc1+nOnfFy8HfbNHhdvRxwX71DVbp2w8yJ7zVI4H9o7HRdv6wQkvOhsl3CdgaczKphlA8RysOZq3Z1KkNsqHEB5xg9eCVw7hbvTPGLzyjd+dyrhzFe4O80h3p1a9oN9d9oWmWZlORv+Bq6/UYEi20kD9KIzJ+E6A09nVKDoiDouxLqrFlBIkLMVgKKTcaCQwOUoAEUnYgPrbBwoJJydFYCikAgUlv1gA0U2Ms3Kckf4G7j+RgWKjk4aoBedhQnXGXg6owLFbqjjrlh31wIKCXJHBaDYwzhQSOAKFYBiD2ID62YcKCSc3RSAoisRKCz7wQaKjsg0K8u7wd/A9TcqUOzmpAF60dk14ToDT2dUoOiBOu6JtZcWUEiQd1MAij2NA4UErqsCUOxJbGB7GQcKCedeCkDRkwgUlv1gA8VuyDQryz3gb+D663ZcvK0Djfukx8V9GLWv13HxHk6Qch8nOns60blvGtE3QvT90Bl7Y+2jgOjySRXcPgqI3tc4okth7Kuw7wONj4v3wL5Zz+uJ/LCKQILfpyrf7/2M/twpHxfvjX2zx8V7E8fF+1a1WyfsvMheD1Q4H/o4HRffzwlIeNHZO+E6A09nVDA7CCDWD2t/rbtTCfJ+CgfQAOMHrwSut8Ld6QBi8zrY+N2phPNghbvTfsS7U8t+sO9O90OmWVk+CP4Grr9RgeIgJw3Qi85+CdcZeDqjAsWhqOPDsB6uBRQS5IMUgGKgcaCQwPVTAIqBxAY2yDhQSDgHKQDFYUSgsOwHGygOQqZZWT4U/gauv1GB4lAnDdCLzsMSrjPwdEYFiiNQx0OwDtUCCgnyoQpAMcw4UEjgDlMAimHEBlZkHCgknEUKQDGECBSW/WADxaHINCvLR8DfwPU3KlAc4aQBetE5JOE6A09nVKAoQR2XYj1SCygkyEcoAMVRxoFCAjdEASiOIjawo40DhYTzaAWgKCUChWU/2EBxBDLNynIJ/A1cf92Oi7dzoPHY9Li4D6OO8zouXuIEKY91orPUic7j0oi+EaIfj844HOsIBUSXT6rgjlVA9BOMI7oUxnEK+z7Z+Lh4CfbNel4p8sMqAgn+iKp8v483+nOnfFx8OPbNHhcfThwXP6Gq3Tph50X2erLC+TDC6bj48U5AwovO4QnXGXg6o4LZKQCxkVhHad2dSpCPVziARhs/eCVwwxXuTkcTm9epxu9OJZynKtydjiTenVr2g313ejwyzcryKfA3cP2NChSnOGmAXnSOTLjOwNMZFShORx2fgfVMLaCQIJ+iABRjjAOFBG6kAlCMITawscaBQsI5VgEoziAChWU/2EBxCjLNyvLp8Ddw/Y0KFKc7aYBedJ6RcJ2BpzMqUJyNOj4H67laQCFBPl0BKM4zDhQSuDMUgOI8YgM73zhQSDjPVwCKc4hAYdkPNlCcjkyzsnw2/A1cf6MCxdlOGqAXneckXGfg6YwKFBegjsdjvVALKCTIZysAxUXGgUICd44CUFxEbGAXGwcKCefFCkAxnggUlv1gA8XZyDQryxfA38D11+24eHsHGi9Nj4v7MOoyr+PiFzhBykud6BzvROdlaUTfCNEvR2ecgPUKBUSXT6rgLlVA9CuNI7oUxmUK+77G+Lj4Bdg363njkR9WEUjwr6jK9/tyoz93ysfFJ2Df7HHxCcRx8Sur2q0Tdl5kr9conA9XOB0Xv9wJSHjROSHhOgNPZ1QwuxYgNhHrJK27Uwny5QoH0GTjB68EboLC3elkYvO6zvjdqYTzOoW704nEu1PLfrDvTi9HpllZvhb+Bq6/UYHiWicN0IvOiQnXGXg6owLFDajjG7HepAUUEuRrFYBiinGgkMBNVACKKcQGNtU4UEg4pyoAxY1EoLDsBxsorkWmWVm+Af4Grr9RgeIGJw3Qi84bE64z8HRGBYqbUce3YL1VCygkyDcoAMVtxoFCAnejAlDcRmxgtxsHCgnn7QpAcQsRKCz7wQaKG5BpVpZvhr+B629UoLjZSQP0ovOWhOsMPJ1RgWIG6ngm1ju0gEKCfLMCUNxpHCgkcLcoAMWdxAZ2l3GgkHDepQAUM4lAYdkPNlDcjEyzsjwD/gauv27HxTs40HhPelzch1H3eh0Xn+EEKe9xonOmE533phF9I0Sfhc44G+t9Cogun1TB3aOA6PcbR3QpjHsV9v2Q8XHxGdg363kzkR9WEUjw76vK93uW0Z875ePis7Fv9rj4bOK4+P1V7dYJOy+y14cUzof7nI6Lz3ICEl50zk64zsDTGRXMHgaIPYJ1jtbdqQR5lsIBNNf4wSuBm61wdzqX2LweNX53KuF8VOHu9BHi3allP9h3p7OQaVaWH4a/getvVKB42EkD9KLzkYTrDDydUYHicdTxE1if1AIKCfLDCkAxzzhQSOAeUQCKecQGNt84UEg45ysAxRNEoLDsBxsoHkamWVl+HP4Grr9RgeJxJw3Qi84nEq4z8HRGBYqnUMdPY31GCygkyI8rAMWzxoFCAveEAlA8S2xgzxkHCgnncwpA8TQRKCz7wQaKx5FpVpafgr+B629UoHjKSQP0ovPphOsMPJ1RgeJ51PEirC9oAYUE+SkFoHjROFBI4J5WAIoXiQ3sJeNAIeF8SQEoFhGBwrIfbKB4CplmZfl5+Bu4/rodF9/FgcZX0uPiPox61eu4+PNOkPIVJzoXOdH5ahrRN0L0xeiMS7C+poDo8kkV3CsKiP66cUSXwnhVYd9vGR8Xfx77Zj1vEfLDKgIJ/mtV+X4vNvpzp3xcfAn2zR4XX0IcF3+9qt06YedF9vqWwvnwmtNx8cVOQMKLziUJ1xl4OqOC2dsAsXewLtW6O5UgL1Y4gJYZP3glcEsU7k6XEZvXu8bvTiWc7yrcnb5DvDu17Af77nQxMk3SmPU2/A1cf6MCxdtOGqAXne8kXGfg6YwKFO+hjt/H+oEWUEiQ31YAig+NA4UE7h0FoPiQ2MBWGAcKCecKBaB4nwgUlv1gA8XbyDQry+/B38D1NypQvOekAXrR+X7CdQaezqhAsQp1/BHWj7WAQoL8ngJQfGIcKCRw7ysAxSfEBvapcaCQcH6qABQfEYHCsh9soHgPmWZleRX8DVx/owLFKicN0IvOjxKuM/B0RgWKz1HHq7F+oQUUEuRVCkDxpXGgkMB9pAAUXxIb2FfGgULC+ZUCUKwmAoVlP9hAsQqZZmX5c/gbuP66HRfPdKDxm/S4uA+jvvU6Lv65E6T8xonO1U50fptG9I0Q/Tt0xjVYv1dAdPmkCu4bBUT/wTiiS2F8q7Dvn42Pi3+OfbOetxr5YRWBBP/7qny/vzP6c6d8XHwN9s0eF19DHBf/oardOmHnRfb6s8L58L3TcfHvnICEF51rEq4z8HRGBbNfAGJrsa7TujuVIH+ncACtN37wSuDWKNydric2r1+N351KOH9VuDtdS7w7tewH++70O2SaleVf4G/g+hsVKH5x0gC96FybcJ2BpzMqUPyOOv6jvJ6r8V98akMS5F8UgKJSNdtAIYFbqwAUG+57U99hRjXbQCHhFI1soPiDCBSW/WADxS/INCvLv8PfwPU3KlD87qQBetH5R8J1Bp7OqEBRBcVWFWs1LaCQIP+uABTVjQOFBO4PBaCoTmxgNYwDhYSzhgJQVOXtO9uyH2yg+B2ZZmW5CvwNXH+jAkWVaj4aoBedVROuM/B0RgWKWii22ljraAGFBFm+7GZT1zhQSODkywaKusQGVs84UEg46ykARW0iUFj2gw0UVZBpVpZrwd/A9dftuHiWA42bMTMqRnkcF/dg1OZMo2Iiei0nSLmZE521nejcXEln4OmMiugNUGwNsTZSQHT5pApuMwVEb2wc0aUwNlfY91bkfbPHxWth36zn1UZ+WEUgwW9Uje93A6M/d8rHxRti3+xx8YY8b4oaV7NbJ+y8yF63UjgfGhH3HRPMGjgBCS86GyZcZ+DpjApmW6PYmmBtqnV3KkFuoHAANTN+8ErgGircnTYjNq9tjN+dSji3Ubg7bUK8O7XsB/vutAEyzcry1vA3cP2NChRbO2mAXnQ2SbjOwNMZFSi2Q7Ftj7W5FlBIkLdWAIoWxoFCAtdEAShaEBtYS+NAIeFsqQAU2xOBwrIfbKDYGplmZXk7+Bu4/kYFiu2cNEAvOrdPuM7A0xkVKFqj2HbAuqMWUEiQt1MAip2MA4UEbnsFoNiJ2MB2Ng4UEs6dFYBiByJQWPaDDRTbIdOsLLeGv4Hrb1SgaO2kAXrRuUPCdQaezqhA0RbF1g5rey2gkCC3VgCKDsaBQgK3gwJQdCA2sF2MA4WEcxcFoGhHBArLfrCBojUyzcpyW/gbuP66HRfPdqAxi5lRMcrjuLgHo7K9jou3dYKUWU50tnOiM1tJZ+DpjIroOSi2XKx5Cogun1TBZSkger5xRJfCyFbYdyF53+xx8bbYN+t57ZAfVhFI8POq8f3OMfpzp3xcPBf7Zo+L5xLHxfOr2a0Tdl5kr4UK50Oe03HxHCcg4UVnbsJ1Bp7OqGC2K4qtE9bOWnenEuQchQOoi/GDVwKXq3B32oXYvHYzfncq4dxN4e60E/Hu1LIf7LvTHGSaleVd4W/g+hsVKHZ10gC96OyUcJ2BpzMqUOyOYtsDazctoJAg76oAFN2NA4UErpMCUHQnNrAexoFCwtlDASj2IAKFZT/YQLErMs3K8u7wN3D9jQoUuztpgF507pFwnYGnMypQ9EKx7Yl1Ly2gSAVZASj2Ng4UErg9FIBib2ID28c4UEg491EAij2JQGHZDzZQ7I5Ms7LcC/4Grr9RgaKXkwboReeeCdcZeDqjAsV+KLbeWPtoAYUEuZcCUPQ1DhQSuD0VgKIvsYHtbxwoJJz7KwBFbyJQWPaDDRS9kGlWlveDv4Hrr9tx8RwHGg9kZlSM8jgu7sGog7yOi+/nBCkPdKKztxOdBynpDDydURG9H4qtP9YBCogun1TBHaiA6AcbR3QpjIMU9n0Yed/scfH9sG/W83ojP6wikOAPqMb3u5/Rnzvl4+L9sW/2uHh/4rj4wdXs1gk7L7LXwxTOhwFOx8X7OQEJLzr7J1xn4OmMCmaHo9gGYh2kdXcqQe6ncAANNn7wSuD6K9ydDiY2ryOM351KOI9QuDsdSLw7tewH++60HzLNyvLh8Ddw/Y0KFIc7aYBedA5MuM7A0xkVKIai2IZhLdICCgny4QpAUWwcKCRwAxWAopjYwEqMA4WEs0QBKIYRgcKyH2ygOByZZmV5KPwNXH+jAsVQJw3Qi85hCdcZeDqjAsWRKLajsB6tBRQS5KEKQHGMcaCQwA1TAIpjiA3sWONAIeE8VgEojiIChWU/2EAxFJlmZflI+Bu4/kYFiiOdNEAvOo9KuM7A0xkVKI5HsQ3HOkILKCTIRyoAxQnGgUICd5QCUJxAbGAnGgcKCeeJCkAxnAgUlv1gA8WRyDQry8fD38D11+24eK4DjSczMypGeRwX92DUKV7HxY93gpQnO9E53InOU5R0Bp7OqIg+EsU2CutoBUSXT6rgTlZA9FONI7oUxikK+z6DvG/2uPjx2DfrecORH1YRSPBHV+P7PdLoz53ycfFR2Dd7XHwUcVz81Gp264SdF9nrGQrnw2in4+IjnYCEF52jEq4z8HRGBbMzUWxjsI7VujuVII9UOIDOMn7wSuBGKdydnkVsXmcbvzuVcJ6tcHc6hnh3atkP9t3pSGSaleUz4W/g+hsVKM500gC96ByTcJ2BpzMqUJyLYjsP6/laQCFBPlMBKMYZBwoJ3BgFoBhHbGAXGAcKCecFCkBxHhEoLPvBBoozkWlWls+Fv4Hrb1SgONdJA/Si87yE6ww8nVGB4kIU20VYL9YCCgnyuQpAcYlxoJDAnacAFJcQG9ilxoFCwnmpAlBcRAQKy36wgeJcZJqV5Qvhb+D6GxUoLnTSAL3ovCjhOgNPZ1SguBzFNgHrFVpAIUG+UAEorjQOFBK4ixSA4kpiA7vKOFBIOK9SAIoJRKCw7AcbKC5EpllZvhz+Bq6/bsfF8xxovIaZUTHK47i4B6Ou9ToufrkTpLzGic4JTnReq6Qz8HRGRfSJKLZJWCcrILp8UgV3jQKiX2cc0aUwrlXY943kfbPHxS/HvlnPm4D8sIpAgj+5Gt/viUZ/7pSPi0/Cvtnj4pOI4+LXVbNbJ+y8yF5vVDgfJjsdF5/oBCS86JyUcJ2BpzMqmN2EYpuCdarW3akEeaLCATTN+MErgZukcHc6jdi8bjZ+dyrhvFnh7nQK8e7Ush/su9OJyDQryzfB38D1NypQ3OSkAXrROSXhOgNPZ1SguBXFdhvW27WAQoJ8kwJQTDcOFBK4KQpAMZ3YwGYYBwoJ5wwFoLiNCBSW/WADxU3INCvLt8LfwPU3KlDc6qQBetF5W8J1Bp7OqEBxB4rtTqx3aQGFBPlWBaC42zhQSOBuUwCKu4kN7B7jQCHhvEcBKO4kAoVlP9hAcSsyzcryHfA3cP2NChR3OGmAXnTemXCdgaczKlDMQrHNxnqfFlBIkO9QAIr7jQOFBO5OBaC4n9jAHjAOFBLOBxSAYjYRKCz7wQaKO5BpVpZnwd/A9dftuHi+A40PMTMqRnkcF/dg1MNex8VnOUHKh5zonO1E58NKOgNPZ1REfwTFNgfrXAVEl0+q4B5SQPRHjSO6FMbDCvt+grxv9rj4LOyb9bzZyA+rCCT4c6vx/X7E6M+d8nHxOdg3e1x8DnFc/NFqduuEnRfZ6xMK58Ncp+PijzgBCS865yRcZ+DpjApmT6LY5mGdr3V3KkF+ROEAWmD84JXAzVG4O11AbF5PGb87lXA+pXB3Oo94d2rZD/bd6SPINCvLT8LfwPU3KlA86aQBetE5L+E6A09nVKB4BsX2LNbntIBCgvykAlAsNA4UErh5CkCxkNjAnjcOFBLO5xWA4lkiUFj2gw0UTyLTrCw/A38D19+oQPGMkwboReezCdcZeDqjAsULKLYXsb6kBRQS5GcUgOJl40AhgXtWASheJjawV4wDhYTzFQWgeJEIFJb9YAPFM8g0K8svwN/A9TcqULzgpAF60fliwnUGns6oQLEYxbYE62taQCFBfkEBKF43DhQSuBcVgOJ1YgN7wzhQSDjfUACKJUSgsOwHGyheQKZZWV4MfwPXX7fj4gUONL7FzKgY5XFc3INRb3sdF1/sBCnfcqJziROdbyvpDDydURH9HRTbUqzLFBBdPqmCe0sB0d81juhSGG8r7Pt98r7Z4+KLsW/W85YgP6wikOAvq8b3+x2jP3fKx8WXYt/scfGlxHHxd6vZrRN2XmSv7yucD8ucjou/4wQkvOhcmnCdgaczKph9gGL7EOsKrbtTCfI7CgfQSuMHrwRuqcLd6Upi81pl/O5UwrlK4e70Q+LdqWU/2Hen7yDTrCx/AH8D19+oQPGBkwboReeHCdcZeDqjAsXHKLZPsH6qBRQS5A8UgOIz40AhgftQASg+Izawz40DhYTzcwWg+IQIFJb9YAPFB8g0K8sfw9/A9TcqUHzspAF60flJwnUGns6oQPEFiu1LrF9pAYUE+WMFoPjaOFBI4D5RAIqviQ3sG+NAIeH8RgEoviQChWU/2EDxMTLNyvIX8Ddw/Y0KFF84aYBedH6ZcJ2BpzMqUHyHYluD9XstoJAgf6EAFD8YBwoJ3JcKQPEDsYH9aBwoJJw/KgDFGiJQWPaDDRRfINOsLH8HfwPXX7fj4h0daPyZmVExyuO4uAejfvE6Lv6dE6T82YnONU50/qKkM/B0RkX0tSi2dVjXKyC6fFIF97MCov9qHNGlMH5R2Pcf5H2zx8W/w75Zz1uD/LCKQIK/vhrf77VGf+6Uj4uvw77Z4+LriOPiv1azWyfsvMhe/1A4H9Y7HRdf6wQkvOhcl3CdgaczKpiF6njPWDOq8198akMS5LUKB1Dl6rYPXgncOoW70w33vanvsEp1mzBRrk/CKRrZd6eVePvOtuwH++50LTLNynKAv4Hrb1SgCNV9NEAvOislXGfg6YwKFNVQx9Wx1tACihS5VOc3m5rGgUICJ182UNQkNrBaxoFCwllLASiqE4HCsh9soAjINCvL1eBv4PobFSiqOWmAXnRWT7jOwNMZFSjqoI7rYq2nBRQS5GoKQFHfOFBI4KorAEV9YgPbzDhQSDg3UwCKukSgsOwHGyiqIdOsLNeBv4Hrb1SgqOOkAXrRWTfhOgNPZ1SgaIA6boi1kRZQSJDrKABFY+NAIYGrqwAUjYkNbAvjQCHh3EIBKBoSgcKyH2ygqINMs7LcAP4Grr9ux8ULHWjciplRMcrjuLgHo7ZmGhUT0Rs4QcqtnOhs6ETn1mlE3wjRm6AzNsXaTAHR5ZMquK0UEH0b44guhbG1wr63J++bPS7eAPtmPa8h8sMqAgl+s+p8v5sY/blTPi7eFPtmj4s35XlTtE11u3XCzovsdXuF86EZcd8xwayJE5DworNpwnUGns6oYNYcINYCa0utu1MJchOFA6iV8YNXAtdU4e60FbF5tTZ+dyrhbK1wd9qCeHdq2Q/23WkTZJqV5ebwN3D9jQoUzZ00QC86WyRcZ+DpjAoUO6KOd8K6sxZQSJCbKwBFG+NAIYFroQAUbYgNrK1xoJBwtlUAip2IQGHZDzZQNEemWVneEf4Grr9RgWJHJw3Qi86dEq4z8HRGBYr2qOMOWHfRAgoJ8o4KQJFpHCgkcDspAEUmsYFlGQcKCWeWAlB0IAKFZT/YQLEjMs3Kcnv4G7j+RgWK9k4aoBedHRKuM/B0RgWKHNRxLtY8LaCQILdXAIp840AhgeugABT5xAZWYBwoJJwFCkCRSwQKy36wgaI9Ms3Kcg78DVx/3Y6L7+pAY2F6XNyHUbt6HRfPcYKUhU505jrRuWsa0TdC9E7ojJ2xdlFAdPmkCq5QAdF3M47oUhi7Kux7D+Pj4jnYN+t5ucgPqwgk+F2q8/3uZPTnTvm4eGfsmz0u3pk4Lr5bdbt1ws6L7HUPhfOhi9Nx8U5OQMKLzs4J1xl4OqOCWTeAWHesPbTuTiXInRQOoJ7GD14JXGeFu9OexObVy/jdqYSzl8LdaXfi3allP9h3p52QaVaWu8HfwPU3KlB0c9IAvejsnnCdgaczKlDshTreG+s+WkAhQe6mABT7GgcKCVx3BaDYl9jA9jMOFBLO/RSAYm8iUFj2gw0U3ZBpVpb3gr+B629UoNjLSQP0onPvhOsMPJ1RgaIP6rgv1v21gEKCvJcCUBxgHCgkcHsrAMUBxAZ2oHGgkHAeqAAUfYlAYdkPNlDshUyzstwH/gauv1GBoo+TBuhFZ9+E6ww8nVGBoh/quD/WAVpAIUHuowAUBxsHCglcXwWgOJjYwA4xDhQSzkMUgKI/ESgs+8EGij7INCvL/eBv4Prrdly8kwONh6XHxX0YdbjXcfF+TpDyMCc6+zvReXga0TdC9IHojIOwDlZAdPmkCu4wBUQ/wjiiS2EcrrDvYcbHxfth36zn9Ud+WEUgwR9cne/3QKM/d8rHxQdh3+xx8UHEcfEjqtutE3ZeZK/DFM6HwU7HxQc6AQkvOgclXGfg6YwKZkUAsWKsJVp3pxLkgQoHUKnxg1cCN0jh7rSU2LyONH53KuE8UuHutJh4d2rZD/bd6UBkmpXlIvgbuP5GBYoiJw3Qi87ihOsMPJ1RgeJo1PExWI/VAgoJcpECUBxnHCgkcMUKQHEcsYEdbxwoJJzHKwDFMUSgsOwHGyiKkGlWlo+Gv4Hrb1SgONpJA/Si85iE6ww8nVGBYgTq+ASsJ2oBhQT5aAWgOMk4UEjgjlEAipOIDexk40Ah4TxZAShOIAKFZT/YQHE0Ms3K8gj4G7j+RgWKEU4aoBedJyRcZ+DpjAoUI1HHo7CO1gIKCfIIBaA41ThQSOBOUACKU4kN7DTjQCHhPE0BKEYRgcKyH2ygGIFMs7I8Ev4Grr9ux8U7O9B4Rnpc3IdRZ3odFx/pBCnPcKJzlBOdZ6YRfSNEH4POOBbrWQqILp9UwZ2hgOhnG0d0KYwzFfZ9nvFx8ZHYN+t5o5AfVhFI8M+qzvd7jNGfO+Xj4mOxb/a4+FjiuPjZ1e3WCTsvstfzFM6Hs5yOi49xAhJedI5NuM7A0xkVzM4HiI3DeoHW3akEeYzCATTe+MErgRurcHc6nti8LjR+dyrhvFDh7nQc8e7Ush/su9MxyDQry+fD38D1NypQnO+kAXrROS7hOgNPZ1SguBh1fAnWS7WAQoJ8vgJQXGYcKCRw4xSA4jJiA7vcOFBIOC9XAIpLiEBh2Q82UJyPTLOyfDH8DVx/owLFxU4aoBedlyRcZ+DpjAoUV6COr8R6lRZQSJAvVgCKq40DhQTuEgWguJrYwK4xDhQSzmsUgOJKIlBY9oMNFBcj06wsXwF/A9ffqEBxhZMG6EXnlQnXGXg6owLFRNTxJKyTtYBCgnyFAlBcZxwoJHBXKgDFdcQGdr1xoJBwXq8AFJOIQGHZDzZQXIFMs7I8Ef4Grr9ux8W7ONB4Y3pc3IdRN3kdF5/oBClvdKJzkhOdN6URfSNEn4LOOBXrNAVEl0+q4G5UQPSbjSO6FMZNCvu+zfi4+ETsm/W8ScgPqwgk+NOq8/2eYvTnTvm4+FTsmz0uPpU4Ln5zdbt1ws6L7PU2hfNhmtNx8SlOQMKLzqkJ1xl4OqOC2e0AselYZ2jdnUqQpygcQDONH7wSuKkKd6czic3rDuN3pxLOOxTuTqcT704t+8G+O52CTLOyfDv8DVx/owLF7U4aoBed0xOuM/B0RgWKu1DHd2O9RwsoJMi3KwDFvcaBQgI3XQEo7iU2sFnGgULCOUsBKO4mAoVlP9hAcTsyzcryXfA3cP2NChR3OWmAXnTenXCdgaczKlDchzq+H+sDWkAhQb5LASgeNA4UEri7FYDiQWIDe8g4UEg4H1IAivuJQGHZDzZQ3IVMs7J8H/wNXH+jAsV9ThqgF533J1xn4OmMChSPoI7nYJ2rBRQS5PsUgOJR40AhgbtfASgeJTawx4wDhYTzMQWgmEMECst+sIHiPmSaleVH4G/g+ut2XHw3BxqfSI+L+zDqSa/j4o84QconnOic40Tnk2lE3wjR56Ezzse6QAHR5ZMquCcUEP0p44guhfGkwr6fNT4u/gj2zXreHOSHVQQS/AXV+X7PM/pzp3xcfD72zR4Xn08cF3+qut06YedF9vqswvmwwOm4+DwnIOFF5/yE6ww8nVHB7DmA2EKsz2vdnUqQ5ykcQIuMH7wSuPkKd6eLiM3rBeN3pxLOFxTuThcS704t+8G+O52HTLOy/Bz8DVx/owLFc04aoBedCxOuM/B0RgWKl1DHL2N9RQsoJMjPKQDFq8aBQgK3UAEoXiU2sMXGgULCuVgBKF4mAoVlP9hA8RwyzcryS/A3cP2NChQvOWmAXnS+nHCdgaczKlC8hjp+HesbWkAhQX5JASjeNA4UEriXFYDiTWIDe8s4UEg431IAiteJQGHZDzZQvIRMs7L8GvwNXH+jAsVrThqgF52vJ1xn4OmMChTvoI6XYl2mBRQS5NcUgOJd40AhgXtdASjeJTaw5caBQsK5XAEolhKBwrIfbKB4DZlmZfkd+Bu4/rodF+/qQOP76XFxH0Z94HVc/B0nSPm+E51Lnej8II3oGyH6h+iMK7CuVEB0+aQK7n0FRF9lHNGlMD5Q2PcnxsfF38G+Wc9bivywikCCv7I63+8Pjf7cKR8XX4F9s8fFVxDHxVdVt1sn7LzIXj9ROB9WOh0X/9AJSHjRuSLhOgNPZ1Qw+xQg9hnWz7XuTiXIHyocQKuNH7wSuBUKd6eric3rC+N3pxLOLxTuTj8j3p1a9oN9d/ohMs3K8qfwN3D9jQoUnzppgF50fpZwnYGnMypQfIU6/hrrN1pAIUH+VAEovjUOFBK4zxSA4ltiA/vOOFBIOL9TAIqviUBh2Q82UHyKTLOy/BX8DVx/owLFV04aoBedXydcZ+DpjAoU36OOf8D6oxZQSJC/UgCKn4wDhQTuawWg+InYwH42DhQSzp8VgOIHIlBY9oMNFF8h06wsfw9/A9ffqEDxvZMG6EXnDwnXGXg6owLFWtTxOqzrtYBCgvy9AlD8ahwoJHA/KADFr8QG9ptxoJBw/qYAFOuIQGHZDzZQfI9Ms7K8Fv4Grr9ux8V3d6Dxj/S4uA+jQg2ixpiIvtYJUv7hROc6Jzqpga3gQ3h2VESvVOM/awbWyjWUXrwU3B8KiF6FbKhGYUjo2PuuTt43e1x8LfbNet465IdVBBL8yjX4fldSzuOmjotnYN/scfGMGrzDr0oNu3XCzovstbrC+VCZuO+YYFaphg+Q8KIzI+E6A09nVDCrARCribWWApilNiRBrqRwANU2fvBK4FJf8nNrE5tXHaMwUa5PwlmHDxPZNXn7zrbsB/vutBIyzcpyDfgbuP5GBYoaThqgF501E64z8HRGBYp6qOP6WDfTAgoJcg0FoNjcOFBI4GoqAMXmxAbWwDhQSDgbKABFfSJQWPaDDRQ1kGlWluvB38D1NypQ1HPSAL3orJ9wnYGnMypQNEIdN8a6hRZQSJDrKQDFlsaBQgJXXwEotiQ2sK2MA4WEcysFoGhMBArLfrCBoh4yzcpyI/gbuP5GBYpGThqgF52NE64z8HRGBYomqOOmWJtpAYUEuZECUGxjHCgkcI0VgGIbYgPb1jhQSDi3VQCKpkSgsOwHGygaIdOsLDeBv4Hrr9tx8T0caNyemVExyuO4uAejmnsdF2/iBCm3d6KzqROdzdOIvhGit0BnbIm1lQKiyydVcNsrIHpr44guhdFcYd87GR8Xb4J9s57XFPlhFYEEv1UNvt8tjP7cKR8Xb4l9s8fFWxLHxVvXsFsn7LzIXndSOB9aOR0Xb+EEJLzobJlwnYGnMyqY7QwQa4O1rdbdqQS5hcIB1M74wSuBa6lwd9qO2LzaG787lXC2V7g7bUO8O7XsB/vutAUyzcryzvA3cP2NChQ7O2mAXnS2SbjOwNMZFSh2QR1nYs3SAgoJ8s4KQJFtHCgkcG0UgCKb2MByjAOFhDNHASgyiUBh2Q82UOyMTLOyvAv8DVx/owLFLk4aoBedmQnXGXg6owJFHuo4H2uBFlBIkHdRAIqOxoFCApepABQdiQ2s0DhQSDgLFYAinwgUlv1gA8UuyDQry3nwN3D9jQoUeU4aoBed+QnXGXg6owJFJ9RxZ6xdtIBCgpynABS7GQcKCVy+AlDsRmxgXY0DhYSzqwJQdCYChWU/2ECRh0yzstwJ/gauv27Hxbs50LhHelzch1HdvI6Ld3KClHs40dnZic5uaUTfCNG7ozP2wNpTAdHlkyq4PRQQvZdxRJfC6Kaw772Nj4t3wr5Zz+uM/LCKQILfswbf7+5Gf+6Uj4v3wL7Z4+I9iOPivWrYrRN2XmSveyucDz2djot3dwISXnT2SLjOwNMZFcz2AYjti3U/rbtTCXJ3hQOot/GDVwLXQ+HutDexefUxfncq4eyjcHe6L/Hu1LIf7LvT7sg0K8v7wN/A9TcqUOzjpAF60blvwnUGns6oQLE/6vgArAdqAYUEeR8FoDjIOFBI4PZVAIqDiA2sn3GgkHD2UwCKA4hAYdkPNlDsg0yzsrw//A1cf6MCxf5OGqAXnQckXGfg6YwKFANQxwdjPUQLKCTI+ysAxaHGgUICd4ACUBxKbGCHGQcKCedhCkBxMBEoLPvBBor9kWlWlgfA38D1NypQDHDSAL3oPDjhOgNPZ1SgGIg6HoR1sBZQSJAHKADFEcaBQgJ3sAJQHEFsYEOMA4WEc4gCUAwiAoVlP9hAMQCZZmV5IPwNXH/djot3d6BxWHpc3IdRRV7HxQc6QcphTnQOcqKzKI3oGyF6MTpjCdZSBUSXT6rghikg+pHGEV0Ko0hh38cYHxcfiH2znjcI+WEVgQS/tAbf72KjP3fKx8VLsG/2uHgJcVz8yBp264SdF9nrMQrnQ6nTcfFiJyDhRWdJwnUGns6oYHYsQOw4rMdr3Z1KkIsVDqDhxg9eCVyJwt3pcGLzGmH87lTCOULh7vQ44t2pZT/Yd6fFyDQry8fC38D1NypQHOukAXrReVzCdQaezqhAcSLq+CSsJ2sBhQT5WAWgOMU4UEjgjlMAilOIDWykcaCQcI5UAIqTiEBh2Q82UByLTLOyfCL8DVx/owLFiU4aoBedJyVcZ+DpjAoUo1HHp2I9TQsoJMgnKgDF6caBQgJ3kgJQnE5sYGcYBwoJ5xkKQHEqESgs+8EGihORaVaWR8PfwPU3KlCMdtIAveg8NeE6A09nVKAYgzoei/UsLaCQII9WAIqzjQOFBO5UBaA4m9jAzjEOFBLOcxSAYiwRKCz7wQaK0cg0K8tj4G/g+ut2XLyHA43npcfFfRh1vtdx8TFOkPI8JzrHOtF5fhrRN0L0ceiMF2Adr4Do8kkV3HkKiH6hcUSXwjhfYd+XGB8XH4N9s543FvlhFYEEf3wNvt/jjP7cKR8XvwD7Zo+LX0AcF7+wht06YedF9nqJwvkw3um4+DgnIOFF5wUJ1xl4OqOC2aUAscuwXq51dypBHqdwAE0wfvBK4C5QuDudQGxeVxi/O5VwXqFwd3oZ8e7Ush/su9NxyDQry5fC38D1NypQXOqkAXrReVnCdQaezqhAcRXq+Gqs12gBhQT5UgWguNY4UEjgLlMAimuJDWyicaCQcE5UAIqriUBh2Q82UFyKTLOyfBX8DVx/owLFVU4aoBedVydcZ+DpjAoUk1HH12G9XgsoJMhXKQDFDcaBQgJ3tQJQ3EBsYDcaBwoJ540KQHEdESgs+8EGiquQaVaWJ8PfwPU3KlBMdtIAvei8LuE6A09nVKCYgjqeinWaFlBIkCcrAMXNxoFCAnedAlDcTGxgtxgHCgnnLQpAMZUIFJb9YAPFZGSaleUp8Ddw/XU7Lt7Tgcbb0uPiPoy63eu4+BQnSHmbE51Tnei8PY3oGyH6dHTGGVhnKiC6fFIFd5sCot9hHNGlMG5X2PfdxsfFp2DfrOdNRX5YRSDBn1mD7/d0oz93ysfFZ2Df7HHxGcRx8Ttq2K0Tdl5kr3crnA8znY6LT4/UoLNzhxYV52Z2zBxampNd1LEkv3BoTmF2cV5JblZJSWbhsNLigmFZmbkFBbllL7m0eFjWsNySzKzC4pzc/KEdS4epQsqMWO8gr6CwIDszp7RgaOaw7NzC7Lw8CVxRcVb+sNLCkuLSopLMzLys0mGFZSnMKXsVw3KKyv7vDO1YkF1cUNxx2N89O/Pff6IC0D0AnnuxztqgFunG9go6xmb82dhNDPd04gE8u4aPPc8g7vn+WHvexAJm7vkBu402VfRS6LMqAp+hJUOLi/JLSgoLM0uKy5KSXVqYVVBYOCwzKy+vJL80e1heTklOdseyAHXMKc4qLO04NK+4LDj5HcteSXZBPrFhZd1D9ONBo/e85frkLCTWSepsfVDhnreiLG4qhN/7V1ncxHdwLxHCZxOz+JCDLD5AzuJDkbKYuWmfLPH5AYUfIA878HwW2fOHlTxn/+e7opXJePK8exT+c2im39Nr2PdkBtmTexU8qUT0ZIZdZpRPVgZ8Zp+Njxjft3BJZYV9zzF+OSq+zOHWTIqliH5nzSGeETEv9jIC1/uk66yccJ2BpzPqheNcMOKjWB+r8af/oZqHz6YeGI8rXWyxfwgTG03W48T394TxYUgJ5RMKw5CPEochLfvB+pFaPgyZgdpgZXku/A1cf6OCxFwno0ZeQOJRJ+8zDRIbg8Q81PF8rAu0RrckyHMVbgifcvAr+FGFfT9rfHQrA/tmPa8y8sMqAgn+AoXRrXnGbyfmY99sWJ5P/E+Nnqpht07YeZG9PqtwPixwOrrlBczmOdHpBczmK+kMPJ1Rwew5gNhCrM9rgZkU3DyFA2iR8YNXCmO+wr5fMg5mc7Fv1vMeRX5YRSDBf14BzJ4zDmYLsW82mC0kgtmiGnbrhJ0X2etLCufD82kwUwWJ59JgRtW5MA1mG4HZywCxV7C+qglmzykcQIsdgNlChX2/7gDMFpLB7DkimEnwX1UAs5eNg9kr2DcbzF4hgtniGnbrhJ0X2evrCufDq2kwUwWJl9NgRtX5ShrMNgKzNwBib2J9SxPMXlY4gN52AGavKOx7mQMwe4UMZi8TwUyC/5YCmL1hHMzexL7ZYPYmEczermG3Tth5kb0uUzgf3kqDmSpIvJEGM6rON9NgthGYvQsQW471PU0we0PhAHrfAZi9qbDvFQ7A7E0ymL1BBDMJ/nsKYPaucTBbjn2zwWw5Eczer2G3Tth5kb2uUDgf3kuDmSpIvJsGM6rO5Wkw2wjMVgLEVmH9SBPM3lU4gD52AGbLFfb9mQMwW04Gs3eJYCbB/0gBzFYaB7NV2DcbzFYRwezjGnbrhJ0X2etnCufDR2kwUwWJlWkwo+pclQazjcDsc4DYaqxfaILZSoUD6EsHYLZKYd/fOACzVWQwW0kEMwn+Fwpg9rlxMFuNfbPBbDURzL6sYbdO2HmRvX6jcD58odToMsg6Pyd6/a2TPa8k7vk7J3t+l7jnNU72/AZxz9872fPLxD3/4GTPzxH3/KOTPc8j7vknJ3vOID7rZ+KeheWqln03w/OkD0pfkHNSzg2pI8mVvGf5nyv7EP+ew3jgG7j0lL5U/oMwA8/884elufx5bJ6q5kDjL8y8i/nVNjB/NX54LcfIgsyTyn/ZZz6gX77z8bdX8H9mOf7vrN7A/Gpp81U0rmWaH/PKlJratE5uEBzqDDydUa9M1+GQXI/11xr8F5/akAT5F4Wrgd+MX4lI4NbW4P8/BfAbEVl/N3rNV65Pwvk7/5ovez1v39mW/WD9dCj/34z7CzLNyvI6+Bu4/kb9z2DXOWmAXnSuT7jOwNMZFShCTbxnrBk1+S8+tSEJ8joFoKhc0zZQSODWKwDFhvve5P+3TWraBgoJp2hkA0Ul3r6zLfvBBop1yDQrywH+Bq6/UYEi1PTRAL3orJRwnYGnMypQVEMdV8daQwsoUuRSk99sahoHCgmcfNlAUZPYwGoZBwoJZy0FoKhOBArLfrCBIiDTrCxXg7+B629UoKjmpAF60Vk94ToDT2dUoKiDOq6LtZ4WUEiQqykARX3jQCGBq64AFPWJDWwz40Ah4dxMASjqEoHCsh9soKiGTLOyXAf+Bq6/mV4nnao70NiAmVGvU0kejGrINComotdxgpQNnOis60RnwzSib4TojdAZG2PdQgHR5ZMquAYKiL6lcUSXwmiosO8m5H2z/4ucdbBv1vPqIj+sIpDgb1GT73cjoz93yv+LnI2xb/Z/kbMxz5uiLWvarRN2XmSvTRTOhy2I+44JZo2cgIQXnY0TrjPwdEYFs6YAsWZYt9G6O5UgN1I4gLY1fvBK4Bor3J1uS2xe2xm/O5Vwbqdwd9qMeHdq2Q/23WkjZJqV5abwN3D9jQoUTZ00QC86myVcZ+DpjAoUzVHHLbC21AIKCXJTBaBoZRwoJHDNFICiFbGBtTYOFBLO1gpA0YIIFJb9YANFU2SaleXm8Ddw/Y0KFM2dNEAvOlskXGfg6YwKFDuijnfCurMWUEiQmysARRvjQCGBa6EAFG2IDaytcaCQcLZVAIqdiEBh2Q82UDRHpllZ3hH+Bq6/UYFiRycN0IvOnRKuM/B0RgWK9qjjDlh30QIKCfKOCkCRaRwoJHA7KQBFJrGBZRkHCglnlgJQdCAChWU/2ECxIzLNynJ7+Bu4/rodF6/hQGNOelzch1G5XsfF2ztByhwnOjs40ZmbRvSNED0PnTEfa4ECossnVXA5Coje0TiiS2HkKuy7k/Fx8fbYN+t5HZAfVhFI8Atq8v3OM/pzp3xcPB/7Zo+L5xPHxTvWtFsn7LzIXjspnA8FTsfF85yAhBed+QnXGXg6o4JZZ4BYF6y7ad2dSpDzFA6grsYPXglcvsLdaVdi89rd+N2phHN3hbvTLsS7U8t+sO9O85BpVpY7w9/A9TcqUHR20gC96OyScJ2BpzMqUHRDHXfH2kMLKCTInRWAoqdxoJDAdVEAip7EBtbLOFBIOHspAEV3IlBY9oMNFJ2RaVaWu8HfwPU3KlB0c9IAvejsnnCdgaczKlDshTreG+s+WkAhQe6mABT7GgcKCVx3BaDYl9jA9jMOFBLO/RSAYm8iUFj2gw0U3ZBpVpb3gr+B629UoNjLSQP0onPvhOsMPJ1RgaIP6rgv1v21gEKCvJcCUBxgHCgkcHsrAMUBxAZ2oHGgkHAeqAAUfYlAYdkPNlDshUyzstwH/gauv27HxWs60NgvPS7uw6j+XsfF+zhByn5OdPZ1orO/ks7A0xkV0QegMx6M9RAFRJdPquD6KSD6ocYRXQqjv8K+BxofF++DfbOe1xf5YRWBBP+Qmny/Bxj9uVM+Ln4w9s0eFz+YOC5+aE27dcLOi+x1oML5cIjTcfEBTkDCi86DE64z8HRGBbNBALHBWI/QujuVIA9QOICGGD94JXAHK9ydDiE2r6HG704lnEMV7k4HE+9OLfvBvjsdgEyzsjwI/gauv1GBYpCTBuhF5+CE6ww8nVGBogh1XIy1RAsoJMiDFICi1DhQSOAGKwBFKbGBHWkcKCScRyoARTERKCz7wQaKQcg0K8tF8Ddw/Y0KFEVOGqAXncUJ1xl4OqMCxdGo42OwHqsFFBLkIgWgOM44UEjgihWA4jhiAzveOFBIOI9XAIpjiEBh2Q82UBQh06wsHw1/A9ffqEBxtJMG6EXnMQnXGXg6owLFCNTxCVhP1AIKCfLRCkBxknGgkMAdowAUJxEb2MnGgULCebICUJxABArLfrCB4mhkmpXlEfA3cP11Oy5ey4HGkcyM/hX1WX8JHowa5XVcfIQTpBzpROcJTnSOSiP6Rog+Gp3xVKynKSC6fFIFN1IB0U83juhSGKMU9j3G+Lj4COyb9bwTkB9WEUjwT6vJ93u00Z875ePip2Lf7HHxU4nj4qfXtFsn7LzIXsconA+nOR0XH+0EJLzoPDXhOgNPZ1QwGwsQOwvr2Vp3pxLk0QoH0DnGD14J3KkKd6fnEJvXucbvTiWc5yrcnZ5FvDu17Af77nQ0Ms3K8lj4G7j+RgWKsU4aoBedZyVcZ+DpjAoU56OOx2G9QAsoJMhjFYBivHGgkMCdpQAU44kN7ELjQCHhvFABKMYRgcKyH2ygGItMs7J8PvwNXH+jAsX5ThqgF53jEq4z8HRGBYqLUceXYL1UCygkyOcrAMVlxoFCAjdOASguIzawy40DhYTzcgWguIQIFJb9YAPF+cg0K8sXw9/A9TcqUFzspAF60XlJwnUGns6oQHEF6vhKrFdpAYUE+WIFoLjaOFBI4C5RAIqriQ3sGuNAIeG8RgEoriQChWU/2EBxMTLNyvIV8Ddw/XU7Ll7bgcaJ6XFxH0ZN8joufoUTpJzoROeVTnROSiP6Rog+GZ3xOqzXKyC6fFIFN1EB0W8wjuhSGJMU9j3F+Lj4Fdg363lXIj+sIpDgX1+T7/dkoz93ysfFr8O+2ePi1xHHxW+oabdO2HmRvU5ROB+udzouPtkJSHjReV3CdQaezqhgNhUgNg3rzVp3pxLkyQoH0C3GD14J3HUKd6e3EJvXrcbvTiWctyrcnU4j3p1a9oN9dzoZmWZleSr8DVx/owLFVCcN0IvOaQnXGXg6owLF7ajj6VhnaAGFBHmqAlDMNA4UErhpCkAxk9jA7jAOFBLOOxSAYjoRKCz7wQaKqcg0K8u3w9/A9TcqUNzupAF60Tk94ToDT2dUoLgLdXw31nu0gEKCfLsCUNxrHCgkcNMVgOJeYgObZRwoJJyzFIDibiJQWPaDDRS3I9OsLN8FfwPX36hAcZeTBuhF590J1xl4OqMCxX2o4/uxPqAFFBLkuxSA4kHjQCGBu1sBKB4kNrCHjAOFhPMhBaC4nwgUlv1gA8VdyDQry/fB38D11+24eB0HGh9Jj4v7MGqO13Hx+5wg5SNOdN7vROecNKJvhOhz0RkfxfqYAqLLJ1Vwjygg+uPGEV0KY47CvucZHxe/D/tmPe9+5IdVBBL8x2ry/Z5r9OdO+bj4o9g3e1z8UeK4+OM17dYJOy+y13kK58NjTsfF5zoBCS86H024zsDTGRXM5gPEFmB9SuvuVII8V+EAetr4wSuBe1Th7vRpYvN6xvjdqYTzGYW70wXEu1PLfrDvTuci06wsz4e/getvVKCY76QBetG5IOE6A09nVKB4DnW8EOvzWkAhQZ6vABSLjAOFBG6BAlAsIjawF4wDhYTzBQWgWEgECst+sIFiPjLNyvJz8Ddw/Y0KFM85aYBedC5MuM7A0xkVKF5CHb+M9RUtoJAgP6cAFK8aBwoJ3EIFoHiV2MAWGwcKCediBaB4mQgUlv1gA8VzyDQryy/B38D1NypQvOSkAXrR+XLCdQaezqhA8Rrq+HWsb2gBhQT5JQWgeNM4UEjgXlYAijeJDewt40Ah4XxLASheJwKFZT/YQPESMs3K8mvwN3D9dTsuXteBxnfS4+I+jFrqdVz8NSdI+Y4Tna870bk0jegbIfoydMZ3sS5XQHT5pAruHQVEf884okthLFXY94fGx8Vfw75Zz3sd+WEVgQR/eU2+38uM/twpHxd/F/tmj4u/SxwXf6+m3Tph50X2+qHC+bDc6bj4Micg4UXnuwnXGXg6o4LZCoDYSqyrtO5OJcjLFA6gj4wfvBK4dxXuTj8iNq+Pjd+dSjg/Vrg7XUm8O7XsB/vudBkyzcryCvgbuP5GBYoVThqgF50rE64z8HRGBYpPUcefYf1cCygkyCsUgGK1caCQwK1UAIrVxAb2hXGgkHB+oQAUnxGBwrIfbKBYgUyzsvwp/A1cf6MCxadOGqAXnZ8lXGfg6YwKFF+hjr/G+o0WUEiQP1UAim+NA4UE7jMFoPiW2MC+Mw4UEs7vFIDiayJQWPaDDRSfItOsLH8FfwPX36hA8ZWTBuhF59cJ1xl4OqMCxfeo4x+w/qgFFBLkrxSA4ifjQCGB+1oBKH4iNrCfjQOFhPNnBaD4gQgUlv1gA8VXyDQry9/D38D11+24eD0HGtemx8V9GLXO67j4906Qcq0TnT840bkujegbIfp6dMZfsf6mgOjySRXcWgVE/904okthrFPYd6Va3H2zx8W/x75Zz/sB+WEVgQT/t5p8v9cb/blTPi7+K/bNHhf/lTgu/ntNu3XCzovsVTSyz4ffnI6Lr3cCEl50/ppwnYGnMyqYZdT6z1oZa5Va/Bef2pAEeb0CoFQ1fvBK4H5VuDvdcN+b+g6r1bIJE+X6JJyikX13Wpm372zLfrDvTtcj06wsZ8DfwPU3KlBk1PLRAL3orJxwnYGnMypQ1EAd18RaSwsoJMgZCr9oahsHCgmcfNlAUZvYwOoYBwoJZx0FoKhJBArLfrCBIgOZZmW5BvwNXH+jAkUNJw3Qi86aCdcZeDqjAkU91HF9rJtpAYUEuYYCUGxuHCgkcDUVgGJzYgNrYBwoJJwNFICiPhEoLPvBBooayDQry/Xgb+D6GxUo6jlpgF501k+4zsDTGRUoGqGOG2PdQgsoJMj1FIBiS+NAIYGrrwAUWxIb2FbGgULCuZUCUDQmAoVlP9hAUQ+ZZmW5EfwNXH/djovXd6CxCTOjf0V91l+CB6OaMo2KieiNnCBlEyc6GzvR2TSN6BshejN0xm2wbquA6PJJFVwTBUTfzjiiS2E0Vdh3C+Pj4o2wb9bzGiM/rCKQ4G9bi+93M6M/d8rHxbfBvtnj4tvwvCnarpbdOmHnRfbaQuF82Ja475hg1swJSHjRuU3CdQaezqhg1hIg1gpra627UwlyM4UDaAfjB68EbhuFu9MdiM1rR+N3pxLOHRXuTlsR704t+8G+O22GTLOy3BL+Bq6/UYGipZMG6EVnq4TrDDydUYFiZ9RxG6xttYBCgtxSASjaGQcKCVwrBaBoR2xg7Y0DhYSzvQJQtCEChWU/2EDREplmZXln+Bu4/kYFip2dNEAvOtskXGfg6YwKFLugjjOxZmkBhQR5ZwWgyDYOFBK4NgpAkU1sYDnGgULCmaMAFJlEoLDsBxsodkamWVneBf4Grr9RgWIXJw3Qi87MhOsMPJ1RgSIPdZyPtUALKCTIuygARUfjQCGBy1QAio7EBlZoHCgknIUKQJFPBArLfrCBYhdkmpXlPPgbuP66HRffzIHGTulx8UwXRnX2Oi6e5wQpOznRme9EZ+c0om+E6F3QGXfD2lUB0eWTKrhOCoi+u3FEl8LorLDv7sbHxfOwb9bz8pEfVhFI8LvW4vvdxejPnfJx8d2wb/a4+G7EcfHda9mtE3ZeZK/dFc6Hrk7Hxbs4AQkvOndLuM7A0xkVzHoAxHpi7aV1dypB7qJwAO1p/OCVwO2mcHe6J7F57WX87lTCuZfC3WlP4t2pZT/Yd6ddkGlWlnvA38D1NypQ9HDSAL3o7JlwnYGnMypQ7IM63hfrflpAIUHuoQAUvY0DhQSupwJQ9CY2sD7GgULC2UcBKPYlAoVlP9hA0QOZZmV5H/gbuP5GBYp9nDRALzr3TbjOwNMZFSj2Rx0fgPVALaCQIO+jABQHGQcKCdy+CkBxELGB9TMOFBLOfgpAcQARKCz7wQaKfZBpVpb3h7+B629UoNjfSQP0ovOAhOsMPJ1RgWIA6vhgrIdoAYUEeX8FoDjUOFBI4A5QAIpDiQ3sMONAIeE8TAEoDiYChWU/2ECxPzLNyvIA+Bu4/rodF9/cgcaB6XFxH0YN8jouPsAJUg50ovNgJzoHpRF9I0QfjM54BNYhCogun1TBDVRA9KHGEV0KY5DCvouNj4sPwL5ZzzsY+WEVgQR/SC2+34ON/twpHxc/Avtmj4sfQRwXH1rLbp2w8yJ7LVY4H4Y4HRcf7AQkvOg8IuE6A09nVDArAYiVYj1S6+5UgjxY4QA6yvjBK4E7QuHu9Chi8zra+N2phPNohbvTUuLdqWU/2Heng5FpVpZL4G/g+hsVKEqcNEAvOksTrjPwdEYFimNRx8dhPV4LKCTIJQpAMdw4UEjgShWAYjixgY0wDhQSzhEKQHEcESgs+8EGihJkmpXlY+Fv4PobFSiOddIAveg8LuE6A09nVKA4EXV8EtaTtYBCgnysAlCcYhwoJHDHKQDFKcQGNtI4UEg4RyoAxUlEoLDsBxsojkWmWVk+Ef4Grr9RgeJEJw3Qi86TEq4z8HRGBYrRqONTsZ6mBRQS5BMVgOJ040AhgTtJAShOJzawM4wDhYTzDAWgOJUIFJb9YAPFicg0K8uj4W/g+ut2XLyBA41j0uPiPowa63VcfLQTpBzjROepTnSOTSP6Roh+Fjrj2VjPUUB0+aQKbowCop9rHNGlMMYq7Huc8XHx0dg363mnIj+sIpDgn1OL7/dZRn/ulI+Ln419s8fFzyaOi59by26dsPMiex2ncD6c43Rc/CwnIOFF59kJ1xl4OqOC2QUAsfFYL9S6O5Ugn6VwAF1k/OCVwJ2tcHd6EbF5XWz87lTCebHC3el44t2pZT/Yd6dnIdOsLF8AfwPX36hAcYGTBuhF5/iE6ww8nVGB4lLU8WVYL9cCCgnyBQpAMcE4UEjgxisAxQRiA7vCOFBIOK9QAIrLiEBh2Q82UFyATLOyfCn8DVx/owLFpU4aoBedlyVcZ+DpjAoUV6GOr8Z6jRZQSJAvVQCKa40DhQTuMgWguJbYwCYaBwoJ50QFoLiaCBSW/WADxaXINCvLV8HfwPU3KlBc5aQBetF5dcJ1Bp7OqEAxGXV8HdbrtYBCgnyVAlDcYBwoJHBXKwDFDcQGdqNxoJBw3qgAFNcRgcKyH2yguAqZZmV5MvwNXH/djos3dKBxSnpc3IdRU72Oi092gpRTnOi8zonOqWlE3wjRp6Ez3oz1FgVEl0+q4KYoIPqtxhFdCmOqwr6nGx8Xn4x9s553HfLDKgIJ/i21+H5PM/pzp3xc/Gbsmz0ufjNxXPzWWnbrhJ0X2et0hfPhFqfj4tOcgIQXnTcnXGfg6YwKZjMAYjOx3qF1dypBnqZwAN1p/OCVwN2scHd6J7F53WX87lTCeZfC3elM4t2pZT/Yd6fTkGlWlmfA38D1NypQzHDSAL3onJlwnYGnMypQ3IM6vhfrLC2gkCDPUACK2caBQgI3UwEoZhMb2H3GgULCeZ8CUNxLBArLfrCBYgYyzcryPfA3cP2NChT3OGmAXnTem3CdgaczKlA8gDp+EOtDWkAhQb5HASgeNg4UErh7FYDiYWIDe8Q4UEg4H1EAigeJQGHZDzZQ3INMs7L8APwNXH+jAsUDThqgF50PJlxn4OmMChRzUcePYn1MCygkyA8oAMXjxoFCAvegAlA8TmxgTxgHCgnnEwpA8SgRKCz7wQaKB5BpVpbnwt/A9dftuHgjBxrnpcfFfRg13+u4+FwnSDnPic5Hneicn0b0jRB9ATrjU1ifVkB0+aQKbp4Coj9jHNGlMOYr7Huh8XHxudg363mPIj+sIpDgP12L7/cCoz93ysfFn8K+2ePiTxHHxZ+pZbdO2HmRvS5UOB+edjouvsAJSHjR+VTCdQaezqhg9jxAbBHWF7TuTiXICxQOoBeNH7wSuKcU7k5fJDavl4zfnUo4X1K4O11EvDu17Af77nQBMs3K8vPwN3D9jQoUzztpgF50Lkq4zsDTGRUoXkEdv4p1sRZQSJCfVwCKJcaBQgK3SAEolhAb2GvGgULC+ZoCULxKBArLfrCB4nlkmpXlV+Bv4PobFShecdIAveh8NeE6A09nVKB4A3X8Jta3tIBCgvyKAlC8bRwoJHCvKgDF28QG9o5xoJBwvqMAFG8SgcKyH2ygeAWZZmX5DfgbuP5GBYo3nDRALzrfTLjOwNMZFSiWoY7fxbpcCygkyG8oAMV7xoFCAvemAlC8R2xg7xsHCgnn+wpA8S4RKCz7wQaKN5BpVpaXwd/A9dftuHhjBxo/TI+L+zBqhddx8WVOkPJDJzrfdaJzRRrRN0L0leiMq7B+pIDo8kkV3IcKiP6xcUSXwlihsO/PjI+LL8O+Wc97F/lhFYEE/6NafL9XGv25Uz4uvgr7Zo+LryKOi39cy26dsPMie/1M4Xz4yOm4+EonIOFF56qE6ww8nVHB7HOA2GqsX2jdnUqQVyocQF8aP3glcKsU7k6/JDavr4zfnUo4v1K4O11NvDu17Af77nQlMs3K8ufwN3D9jQoUnztpgF50rk64zsDTGRUovkEdf4v1Oy2gkCB/rgAUa4wDhQRutQJQrCE2sO+NA4WE83sFoPiWCBSW/WADxefINCvL38DfwPU3KlB846QBetH5bcJ1Bp7OqEDxI+r4J6w/awGFBPkbBaD4xThQSOC+VQCKX4gNbK1xoJBwrlUAip+IQGHZDzZQfINMs7L8I/wNXH+jAsWPThqgF50/JVxn4OmMChTrUce/Yv1NCygkyD8qAMXvxoFCAveTAlD8TmxgfxgHCgnnHwpA8SsRKCz7wQaKH5FpVpbXw9/A9dftuPgWDjRWqk3U+FfUZ/0leDAqg2lUTERf7wQpqZWgqPNXJ+8zQ+l9Bp7OqIheufZ/1ipYq9ZWevFScBJmNr5VIxuqURgZCvuuSd43e1x8PfbNet6vyA+tCGr/J+xsvysr53FTx8WrYN/scfEqPG+KqtW2WyfsvMheayqcD1WJ+44JZpWdAI8XnVUSrjPwdEYFs1oAsdpY6yiAWWpDEuTKCgdQXeMHrwROvhnk59YlNq96RmGiXJ+Esx4fJrJr8/adbdkP9t1pZWSaleVa8Ddw/Y0KFLWcNEAvOmsnXGfg6YwKFJuhjjfH2kALKCTItRSAoqFxoJDA1VYAiobEBtbIOFBIOBspAMXmRKCw7AcbKGoh06wsbwZ/A9ffqECxmZMG6EXn5gnXGXg6owLFFqjjLbFupQUUEuTNFIBia+NAIYHbXAEotiY2sCbGgULC2UQBKLYkAoVlP9hAsRkyzcryFvA3cP2NChRbOGmAXnRumXCdgaczKlA0Qx1vg3VbLaCQIG+hABTbGQcKCdyWCkCxHbGBbW8cKCSc2ysAxTZEoLDsBxsotkCmWVluBn8D11+34+JbOtDYIj0u7sOoll7HxZs5QcoWTnRu40RnyzSib4TordAZW2PdQQHR5ZMquBYKiL6jcUSXwmipsO82xsfFm2HfrOdtg/ywikCCv0Ntvt+tjP7cKR8Xb419s8fFWxPHxXesbbdO2HmRvbZROB92cDou3soJSHjR2TrhOgNPZ1QwawsQa4e1vdbdqQS5lcIB1MH4wSuBa61wd9qB2Lx2MX53KuHcReHutB3x7tSyH+y701bINCvLbeFv4PobFSjaOmmAXnS2S7jOwNMZFSiyUMfZWHO0gEKC3FYBKHKNA4UErp0CUOQSG1iecaCQcOYpAEU2ESgs+8EGirbINCvLWfA3cP2NChRZThqgF53E2nSpM/B0RgWKAtRxR6yFWkAhQc5SAIpdjQOFBC5bASh2JTawTsaBQsLZSQEoOhKBwrIfbKDIQqZZWS6Av4Hrb1SgKHDSAL3o7JhwnYGnMypQdEEd74a1qxZQSJALFIBid+NAIYHrqAAUuxMb2B7GgULCuYcCUOxGBArLfrCBogCZZmW5C/wNXH/djotv5UBj9/S4uA+jengdF+/iBCm7O9G5mxOdPdKIvhGi90Rn7IV1TwVEl0+q4LorIPpexhFdCqOHwr73NT4u3gX7Zj1vN+SHVQQS/D1r8/3uafTnTvm4eC/smz0u3os4Lr5Xbbt1ws6L7HVfhfNhT6fj4j2dgIQXnb0SrjPwdEYFs/0AYr2x9tG6O5Ug91Q4gPoaP3glcL0U7k77EpvX/sbvTiWc+yvcnfYm3p1a9oN9d9oTmWZleT/4G7j+RgWK/Zw0QC86eydcZ+DpjAoUB6KOD8LaTwsoJMj7KQBFf+NAIYHrrQAU/YkNbIBxoJBwDlAAioOIQGHZDzZQ7IdMs7J8IPwNXH+jAsWBThqgF50HJVxn4OmMChSHoI4PxXqYFlBIkA9UAIrDjQOFBO4gBaA4nNjABhoHCgnnQAWgOJQIFJb9YAPFgcg0K8uHwN/A9TcqUBzipAF60XlownUGns6oQDEYdXwE1iFaQCFBPkQBKIYaBwoJ3KEKQDGU2MCGGQcKCecwBaA4gggUlv1gA8UhyDQry4Phb+D663ZcfGsHGovT4+I+jCrxOi4+2AlSFjvReYQTnSVpRN8I0UvRGY/EepQCossnVXDFCoh+tHFEl8IoUdj3ccbHxQdj36znHYH8sIpAgn9Ubb7fpUZ/7pSPix+JfbPHxY8kjosfXdtunbDzIns9TuF8OMrpuHipE5DwovPIhOsMPJ1Rwex4gNhwrCO07k4lyKUKB9AJxg9eCdyRCnenJxCb14nG704lnCcq3J0OJ96dWvaDfXdaikyzsnw8/A1cf6MCxfFOGqAXncMTrjPwdEYFipNRx6dgHakFFBLk4xWAYpRxoJDADVcAilHEBjbaOFBIOEcrAMUpRKCw7AcbKI5HpllZPhn+Bq6/UYHiZCcN0IvOUxKuM/B0RgWK01DHp2M9QwsoJMgnKwDFmcaBQgJ3igJQnElsYGOMA4WEc4wCUJxOBArLfrCB4mRkmpXl0+Bv4PobFShOc9IAveg8PeE6A09nVKA4C3V8NtZztIBCgnyaAlCcaxwoJHCnKwDFucQGdp5xoJBwnqcAFGcTgcKyH2ygOA2ZZmX5LPgbuP66HRdv4kDjuPS4uA+jLvA6Ln6WE6Qc50Tn2U50XpBG9I0QfTw644VYL1JAdPmkCm6cAqJfbBzRpTAuUNj3ZcbHxc/CvlnPOxv5YRWBBP+i2ny/xxv9uVM+Ln4h9s0eF7+QOC5+cW27dcLOi+z1MoXz4SKn4+LjnYCEF50XJlxn4OmMCmaXA8QmYL1C6+5Ugjxe4QC60vjBK4G7UOHu9Epi87rK+N2phPMqhbvTCcS7U8t+sO9OxyPTrCxfDn8D19+oQHG5kwboReeEhOsMPJ1RgeIa1PG1WCdqAYUE+XIFoJhkHCgkcBMUgGISsYFNNg4UEs7JCkBxLREoLPvBBorLkWlWlq+Bv4Hrb1SguMZJA/Si89qE6ww8nVGB4nrU8Q1Yb9QCCgnyNQpAcZNxoJDAXasAFDcRG9gU40Ah4ZyiABQ3EIHCsh9soLgGmWZl+Xr4G7j+RgWK6500QC86b0i4zsDTGRUopqGOb8Z6ixZQSJCvVwCKW40DhQTuBgWguJXYwG4zDhQSztsUgOJmIlBY9oMNFNcj06wsT4O/geuv23Hxpg40Tk+Pi/swaobXcfFpTpByuhOdNzvROSON6Bsh+kx0xjuw3qmA6PJJFdx0BUS/yziiS2HMUNj3vcbHxadh36zn3Yz8sIpAgn9nbb7fM43+3CkfF78D+2aPi99BHBe/q7bdOmHnRfZ6r8L5cKfTcfGZTkDCi847Eq4z8HRGBbNZALHZWO/TujuVIM9UOIDuN37wSuDuULg7vZ/YvB4wfncq4XxA4e50NvHu1LIf7LvTmcg0K8uz4G/g+hsVKGY5aYBedM5OuM7A0xkVKB5CHT+M9REtoJAgz1IAijnGgUICN1sBKOYQG9hc40Ah4ZyrABQPE4HCsh9soJiFTLOy/BD8DVx/owLFQ04aoBedDydcZ+DpjAoUj6GOH8f6hBZQSJAfUgCKJ40DhQTuYQWgeJLYwOYZBwoJ5zwFoHicCBSW/WADxUPINCvLj8HfwPU3KlA85qQBetH5eMJ1Bp7OqECxAHX8FNantYBCgvyYAlA8YxwoJHCPKwDFM8QG9qxxoJBwPqsAFE8RgcKyH2ygeAyZZmV5AfwNXH/djos3c6BxYXpc3IdRz3sdF1/gBCkXOtH5lBOdz6cRfSNEX4TO+ALWFxUQXT6pgluogOgvGUd0KYznFfb9qvFx8QXYN+t5TyE/rCKQ4L9Ym+/3IqM/d8rHxV/Avtnj4i8Qx8Vfqm23Tth5kb2+qnA+vOh0XHyRE5DwovOFhOsMPJ1RwWwxQGwJ1te07k4lyIsUDqDXjR+8ErgXFO5OXyc2rzeM351KON9QuDtdQrw7tewH++50ETLNyvJi+Bu4/kYFisVOGqAXnUsSrjPwdEYFirdQx29jfUcLKCTIixWAYqlxoJDALVEAiqXEBrbMOFBIOJcpAMXbRKCw7AcbKBYj06wsvwV/A9ffqEDxlpMG6EXn2wnXGXg6owLFctTxe1jf1wIKCfJbCkDxgXGgkMC9rQAUHxAb2IfGgULC+aECULxHBArLfrCB4i1kmpXl5fA3cP2NChTLnTRALzrfS7jOwNMZFShWoo5XYf1ICygkyMsVgOJj40AhgXtPASg+JjawT4wDhYTzEwWgWEUECst+sIFiOTLNyvJK+Bu4/rodF9/GgcbP0uPiPoz63Ou4+EonSPmZE52rnOj8PI3oGyH6anTGL7B+qYDo8kkV3GcKiP6VcUSXwvhcYd/fGh8XX4l9s563CvlhFYEE/8vafL9XG/25Uz4u/gX2zR4X/4I4Lv5Vbbt1ws6L7PVbhfPhS6fj4qudgIQXnV8kXGfg6YwKZt8BxNZg/V7r7lSCvFrhAPrB+MErgftC4e70B2Lz+tH43amE80eFu9M1xLtTy36w705XI9OsLH8HfwPX36hA8Z2TBuhF55qE6ww8nVGB4mfU8S9Y12oBhQT5OwWgWGccKCRwaxSAYh2xga03DhQSzvUKQPELESgs+8EGiu+QaVaWf4a/getvVKD42UkD9KLzl4TrDDydUYHiN9Tx71j/0AIKCfLPCkAR6tgGCgncLwpAseG+N/UdVqpjGygknKKRDRS/E4HCsh9soPgZmWZl+Tf4G7j+RgWK35w0QC86f0+4zsDTGRUoKqOOq2CtWof/4lMbkiD/pgAU1YwDhQTudwWgqEZsYNWNA4WEs7oCUFTh7Tvbsh9soPgNmWZluTL8DVx/3Y6Lb+tAY01mRv+K+qy/BA9G1WIaFRPRK9fhv1wNnTWd6KziRGctJZ2BpzMqotdGZ6yDta4CossnVXASZja+1TOO6FIYtRT2vTl53+xx8crYN+t5VZAfVhFI8OvW4ftd2+jPnfJx8TrYN3tcvA7Pm6J6dezWCTsvstfNFc6HusR9xwSz2k5AwovOOgnXGXg6o4JZA4BYQ6yNtO5OJci1FQ6gxsYPXgmcfDPIz21MbF5bGL87lXBuoXB32pB4d2rZD/bdaW1kmpXlBvA3cP2NChQNnDRALzobJlxn4OmMChRboY63xtpECygkyA0UgKKpcaCQwDVUAIqmxAbWzDhQSDibKQDF1kSgsOwHGygaINOsLG8FfwPX36hAsZWTBuhF59YJ1xl4OqMCxbao4+2wbq8FFBLkrRSAorlxoJDAba0AFM2JDayFcaCQcLZQAIrtiEBh2Q82UGyFTLOyvC38DVx/owLFtk4aoBed2yVcZ+DpjAoUrVDHrbHuoAUUEuRtFYBiR+NAIYHbTgEodiQ2sJ2MA4WEcycFoGhNBArLfrCBYltkmpXlVvA3cP11Oy6+nQONbdLj4j6Maut1XLyVE6Rs40Rnayc626YRfSNEb4fO2B5rBwVEl0+q4NooIPouxhFdCqOtwr6zjY+Lt8K+Wc9rjfywikCC36EO3+92Rn/ulI+Lt8e+2ePi7Ynj4rvUsVsn7LzIXrMVzocOTsfF2zkBCS862ydcZ+DpjApmOQCxXKx5WnenEuR2CgdQvvGDVwLXXuHuNJ/YvAqM351KOAsU7k5ziXenlv1g3522Q6ZZWc6Bv4Hrb1SgyHHSAL3ozE24zsDTGRUoClHHu2LtpAUUEuQcBaDobBwoJHC5CkDRmdjAuhgHCglnFwWg2JUIFJb9YANFDjLNynIh/A1cf6MCRaGTBuhF564J1xl4OqMCRVfU8e5Y99ACCglyoQJQdDMOFBK4XRWAohuxgXU3DhQSzu4KQLE7ESgs+8EGikJkmpXlrvA3cP2NChRdnTRALzp3T7jOwNMZFSh6oo57Yd1TCygkyF0VgGIv40CRCpwCUOxFbGB7GwcKCefeCkDRiwgUlv1gA0VXZJqV5Z7wN3D9dTsuvr0Djfumx8V9GLWf13Hxnk6Qcl8nOns50blfGtE3QvTe6Ix9sPZVQHT5pApuXwVE3984okth7Kew74OMj4v3xL5Zz+uF/LCKQILftw7f795Gf+6Uj4v3wb7Z4+J9iOPi+9exWyfsvMheD1I4H/o6HRfv7QQkvOjsk3CdgaczKpj1A4j1xzpA6+5Ugtxb4QA62PjBK4Hro3B3ejCxeR1i/O5UwnmIwt1pf+LdqWU/2HenvZFpVpb7wd/A9TcqUPRz0gC96OyfcJ2BpzMqUByGOj4c60AtoJAg91MAikHGgUIC118BKAYRG9hg40Ah4RysABSHE4HCsh9soOiHTLOyfBj8DVx/owLFYU4aoBedhydcZ+DpjAoUQ1DHQ7EO0wIKCfJhCkBRZBwoJHCHKwBFEbGBFRsHCglnsQJQDCUChWU/2EBxGDLNyvIQ+Bu4/kYFiiFOGqAXnUMTrjPwdEYFilLU8ZFYj9ICCgnyEAWgONo4UEjghioAxdHEBnaMcaCQcB6jABRHEoHCsh9soBiCTLOyXAp/A9dft+PizR1oPC49Lu7DqOO9jouXOkHK45zoPNKJzuPTiL4Rog9HZxyB9QQFRJdPquCOU0D0E40juhTG8Qr7PsX4uHgp9s163pHID6sIJPgn1OH7Pdzoz53ycfER2Dd7XHwEcVz8xDp264SdF9nrKQrnwwlOx8WHOwEJLzpHJFxn4OmMCmYjAWKjsI7WujuVIA9XOIBONX7wSuBGKNydnkpsXqcZvzuVcJ6mcHc6inh3atkP9t3pcGSaleWR8Ddw/Y0KFCOdNEAvOkclXGfg6YwKFGegjs/EOkYLKCTIIxWAYqxxoJDAjVIAirHEBnaWcaCQcJ6lABRnEoHCsh9soBiJTLOyfAb8DVx/owLFGU4aoBedZyZcZ+DpjAoU56COz8V6nhZQSJDPUACK840DhQTuTAWgOJ/YwMYZBwoJ5zgFoDiXCBSW/WADxRnINCvL58DfwPU3KlCc46QBetF5bsJ1Bp7OqEAxHnV8IdaLtIBCgnyOAlBcbBwoJHDnKgDFxcQGdolxoJBwXqIAFBcSgcKyH2ygOAeZZmV5PPwNXH/djou3cKDxsvS4uA+jLvc6Lj7eCVJe5kTnhU50Xp5G9I0QfQI64xVYr1RAdPmkCu4yBUS/yjiiS2FcrrDva42Pi4/HvlnPuxD5YRWBBP/KOny/Jxj9uVM+Ln4F9s0eF7+COC5+VR27dcLOi+z1WoXz4Uqn4+ITnICEF51XJFxn4OmMCmYTAWKTsE7WujuVIE9QOICuM37wSuCuULg7vY7YvK43fncq4bxe4e50EvHu1LIf7LvTCcg0K8sT4W/g+hsVKCY6aYBedE5KuM7A0xkVKG5EHd+EdYoWUEiQJyoAxVTjQCGBm6QAFFOJDWyacaCQcE5TAIqbiEBh2Q82UExEpllZvhH+Bq6/UYHiRicN0IvOmxKuM/B0RgWKW1DHt2K9TQsoJMg3KgDF7caBQgJ3kwJQ3E5sYNONA4WEc7oCUNxKBArLfrCB4kZkmpXlW+Bv4PobFShucdIAvei8NeE6A09nVKCYiTq+A+udWkAhQb5FASjuMg4UErhbFYDiLmIDu9s4UEg471YAijuIQGHZDzZQ3IJMs7I8E/4Grr9ux8VbOtB4b3pc3IdRs7yOi890gpT3OtF5hxOds9KIvhGiz0ZnvA/r/QqILp9Uwd2rgOgPGEd0KYxZCvt+2Pi4+Ezsm/W8O5AfVhFI8O+vw/d7ttGfO+Xj4vdh3+xx8fuI4+IP1LFbJ+y8yF4fVjgf7nc6Lj7bCUh40XlfwnUGns6oYPYIQGwO1rlad6cS5NkKB9Cjxg9eCdx9CnenjxKb12PG704lnI8p3J3OId6dWvaDfXc6G5lmZfkR+Bu4/kYFikecNEAvOuckXGfg6YwKFE+gjp/EOk8LKCTIjygAxXzjQCGBm6MAFPOJDWyBcaCQcC5QAIoniUBh2Q82UDyCTLOy/AT8DVx/owLFE04aoBedTyZcZ+DpjAoUT6OOn8H6rBZQSJCfUACK54wDhQTuSQWgeI7YwBYaBwoJ50IFoHiGCBSW/WADxRPINCvLT8PfwPU3KlA87aQBetH5TMJ1Bp7OqECxCHX8AtYXtYBCgvy0AlC8ZBwoJHDPKADFS8QG9rJxoJBwvqwAFC8QgcKyH2ygeBqZZmV5EfwNXH/djou3cqDx1fS4uA+jFnsdF1/kBClfdaLzBSc6F6cRfSNEX4LO+BrW1xUQXT6pgntVAdHfMI7oUhiLFfb9tvFx8UXYN+t5LyA/rCKQ4L9eh+/3EqM/d8rHxV/Dvtnj4q8Rx8XfqGO3Tth5kb2+rXA+vO50XHyJE5DwovO1hOsMPJ1RwewdgNhSrMu07k4lyEsUDqB3jR+8ErjXFO5O3yU2r+XG704lnMsV7k6XEu9OLfvBvjtdgkyzsvwO/A1cf6MCxTtOGqAXnUsTrjPwdEYFivdRxx9g/VALKCTI7ygAxQrjQCGBW6oAFCuIDWylcaCQcK5UAIoPiEBh2Q82ULyDTLOy/D78DVx/owLF+04aoBedHyRcZ+DpjAoUH6GOP8b6iRZQSJDfVwCKT40DhQTuAwWg+JTYwD4zDhQSzs8UgOJjIlBY9oMNFO8j06wsfwR/A9ffqEDxkZMG6EXnxwnXGXg6owLFatTxF1i/1AIKCfJHCkDxlXGgkMB9rAAUXxEb2NfGgULC+bUCUHxBBArLfrCB4iNkmpXl1fA3cP11Oy7e2oHGb9Pj4j6M+s7ruPhqJ0j5rROdXzjR+V0a0TdC9DXojN9j/UEB0eWTKrhvFRD9R+OILoXxncK+fzE+Lr4a+2Y97wvkh1UEEvwf6vD9XmP05075uPj32Dd7XPx74rj4j3Xs1gk7L7LXXxTOhx+cjouvcQISXnR+n3CdgaczKpitBYitw7pe6+5UgrxG4QD61fjBK4H7XuHu9Fdi8/rN+N2phPM3hbvTdcS7U8t+sO9O1yDTrCyvhb+B629UoFjrpAF60bku4ToDT2dUoPijvI7r4n3X5b/41IYkyGsVgCKjrm2gkMCtUwCKDfe9qe+wcl3bQCHhFI1soAi8fWdb9oMNFGuRaVaW5RCqXH7wBJ9A8YeTBuhFZ6ibbJ2BpzMqUFRFHVfDWl0LKCTIfygARQ3jQJEitbp8oKhBbGA1jQOFhLOmAlBUIwKFZT/YQJH6FcLTmFUV/gauv1GBoqqTBuhFZ7WE6ww8nVGBojbquA7WulpAIUGWL7vZ1DMOFBK4agpAUY/YwOobBwoJZ30FoKhDBArLfrCBoioyzcpybfgbuP66HRffwYHGzZkZ/Svqs/4SPBjVgGlUTESv7QQpN3eis44TnQ3SiL4RojdEZ2yEtbECossnVXCbKyD6FsYRXQqjgcK+tybvmz0uXhv7Zj2vDvLDKgIJfuO6fL8bGv25Uz4u3gj7Zo+LN+J5U7RFXbt1ws6L7HVrhfOhMXHfMcGsoROQ8KKzUcJ1Bp7OqGDWBCDWFGszrbtTCXJDhQNoG+MHrwSukcLd6TbE5rWt8btTCee2CnenTYl3p5b9YN+dNkSmWVluAn8D19+oQNHESQP0orNpwnUGns6oQLE96rg51hZaQCFBbqIAFC2NA4UErqkCULQkNrBWxoFCwtlKASiaE4HCsh9soGiCTLOyvD38DVx/owLF9k4aoBedzROuM/B0RgWKHVDHO2LdSQsoJMjbKwDFzsaBQgLXXAEodiY2sDbGgULC2UYBKHYkAoVlP9hAsT0yzcryDvA3cP2NChQ7OGmAXnTumHCdgaczKlC0Qx23x9pBCygkyDsoAMUuxoFCArejAlDsQmxgmcaBQsKZqQAU7YlAYdkPNlDsgEyzstwO/gauv27HxXd0oDE7PS7uw6gcr+Pi7ZwgZbYTne2d6MxJI/pGiJ6LzpiHNV8B0eWTKrhsBUQvMI7oUhg5Cvve1fi4eDvsm/W89sgPqwgk+Pl1+X7nGv25Uz4unod9s8fF84jj4gV17dYJOy+y110Vzod8p+PiuU5AwovOvITrDDydUcGsE0CsM9YuWnenEuRchQNoN+MHrwQuT+HudDdi8+pq/O5UwtlV4e60M/Hu1LIf7LvTXGSaleVO8Ddw/Y0KFJ2cNEAvOjsnXGfg6YwKFHugjrth7a4FFBLkTgpA0cM4UEjgOisARQ9iA+tpHCgknD0VgKIbESgs+8EGik7INCvLe8DfwPU3KlDs4aQBetHZLeE6A09nVKDYE3W8F9a9tYBCgryHAlDsYxwoJHDdFIBiH2ID29c4UEg491UAir2IQGHZDzZQ7IFMs7K8J/wNXH+jAsWeThqgF517JVxn4OmMChS9Ucd9sPbVAgoJ8p4KQLG/caCQwO2lABT7ExvYAcaBQsJ5gAJQ9CEChWU/2ECxJzLNynJv+Bu4/rodF9/JgcaD0uPiPozq53VcvLcTpDzIic4+TnT2SyP6RojeH51xANaDFRBdPqmCO0gB0Q8xjuhSGP0U9n248XHx3tg363l9kB9WEUjwD67L97u/0Z875ePiA7Bv9rj4AOK4+CF17dYJOy+y18MVzoeDnY6L93cCEl50Dki4zsDTGRXMBgLEBmEdrHV3KkHur3AAHWH84JXADVC4Oz2C2LyGGL87lXAOUbg7HUS8O7XsB/vutD8yzcryQPgbuP5GBYqBThqgF52DEq4z8HRGBYphqOMirMVaQCFBHqgAFCXGgUICN0gBKEqIDazUOFBIOEsVgKKICBSW/WADxUBkmpXlYfA3cP2NChTDnDRALzqLEq4z8HRGBYqjUMdHYz1GCygkyMMUgOJY40AhgStSAIpjiQ3sOONAIeE8TgEojiYChWU/2EAxDJlmZfko+Bu4/kYFiqOcNEAvOo9OuM7A0xkVKIajjkdgPUELKCTIRykAxYnGgUICd7QCUJxIbGAnGQcKCedJCkAxgggUlv1gA8VRyDQry8Phb+D663ZcfGcHGk9Jj4v7MGqk13Hx4U6Q8hQnOkc40TkyjegbIfoodMbRWE9VQHT5pAruFAVEP804okthjFTY95nGx8WHY9+s541AflhFIME/tS7f71FGf+6Uj4uPxr7Z4+KjiePip9W1WyfsvMhez1Q4H051Oi4+yglIeNE5OuE6A09nVDAbAxAbi/UsrbtTCfIohQPobOMHrwRutMLd6dnE5nWO8btTCec5CnenY4l3p5b9YN+djkKmWVkeA38D19+oQDHGSQP0onNswnUGns6oQHEe6vh8rOO0gEKCPEYBKC4wDhQSuLEKQHEBsYGNNw4UEs7xCkBxPhEoLPvBBooxyDQry+fB38D1NypQnOekAXrReX7CdQaezqhAcRHq+GKsl2gBhQT5PAWguNQ4UEjgzlcAikuJDewy40Ah4bxMASguJgKFZT/YQHEeMs3K8kXwN3D9jQoUFzlpgF50XpxwnYGnMypQTEAdX4H1Si2gkCBfpAAUVxkHCgncxQpAcRWxgV1tHCgknFcrAMUVRKCw7AcbKC5CpllZngB/A9dft+PibRxovDY9Lu7DqIlex8UnOEHKa53ovMKJzolpRN8I0SehM07Gep0CossnVXDXKiD69cYRXQpjosK+bzI+Lj4B+2Y97wrkh1UEEvzr6vL9nmT05075uPhk7Js9Lj6ZOC5+fV27dcLOi+z1JoXz4Tqn4+KTnICEF52TE64z8HRGBbMpALGpWKdp3Z1KkCcpHEA3Gz94JXCTFe5ObyY2r1uM351KOG9RuDudSrw7tewH++50EjLNyvIU+Bu4/kYFiilOGqAXnVMTrjPwdEYFittQx7djna4FFBLkKQpAMcM4UEjgpioAxQxiA5tpHCgknDMVgOJ2IlBY9oMNFFOQaVaWb4O/getvVKC4zUkD9KLz9oTrDDydUYHiTtTxXVjv1gIKCfJtCkBxj3GgkMDdrgAU9xAb2L3GgULCea8CUNxFBArLfrCB4jZkmpXlO+Fv4PobFSjudNIAvei8K+E6A09nVKCYjTq+D+v9WkAhQb5TASgeMA4UEri7FIDiAWIDe9A4UEg4H1QAivuIQGHZDzZQ3IlMs7I8G/4Grr9ux8XbOtD4cHpc3IdRj3gdF5/tBCkfdqLzPic6H0kj+kaIPgedcS7WRxUQXT6pgntYAdEfM47oUhiPKOz7SePj4rOxb9bz7kN+WEUgwX+0Lt/vOUZ/7pSPi8/Fvtnj4nOJ4+KP1bVbJ+y8yF6fVDgfHnU6Lj7HCUh40Tk34ToDT2dUMJsHEJuPdYHW3akEeY7CAfSU8YNXAjdX4e70KWLzetr43amE82mFu9P5xLtTy36w707nINOsLM+Dv4Hrb1SgmOekAXrROT/hOgNPZ1SgeBZ1/BzWhVpAIUGepwAUzxsHCgncfAWgeJ7YwBYZBwoJ5yIFoHiOCBSW/WADxTxkmpXlZ+Fv4PobFSieddIAveh8LuE6A09nVKB4EXX8EtaXtYBCgvysAlC8YhwoJHDPKQDFK8QG9qpxoJBwvqoAFC8RgcKyH2ygeBaZZmX5RfgbuP5GBYoXnTRALzpfSrjOwNMZFSiWoI5fw/q6FlBIkF9UAIo3jAOFBO4lBaB4g9jA3jQOFBLONxWA4jUiUFj2gw0ULyLTrCwvgb+B66/bcfF2DjS+nR4X92HUO17HxZc4Qcq3neh8zYnOd9KIvhGiL0VnXIb1XQVEl0+q4N5WQPTlxhFdCuMdhX1/YHxcfAn2zXrea8gPqwgk+O/W5fu91OjPnfJx8WXYN3tcfBlxXHx5Xbt1ws6L7PUDhfPhXafj4kudgIQXncsSrjPwdEYFsw8BYiuwrtS6O5UgL1U4gFYZP3glcMsU7k5XEZvXR8bvTiWcHyncna4g3p1a9oN9d7oUmWZl+UP4G7j+RgWKD500QC86VyRcZ+DpjAoUn6COP8X6mRZQSJA/VACKz40DhQRuhQJQfE5sYKuNA4WEc7UCUHxKBArLfrCB4kNkmpXlT+Bv4PobFSg+cdIAvej8NOE6A09nVKD4EnX8FdavtYBCgvyJAlB8YxwoJHCfKgDFN8QG9q1xoJBwfqsAFF8RgcKyH2yg+ASZZmX5S/gbuP5GBYovnTRALzq/SrjOwNMZFSjWoI6/x/qDFlBIkL9UAIofjQOFBO4rBaD4kdjAfjIOFBLOnxSA4nsiUFj2gw0UXyLTrCyvgb+B66/bcfH2DjT+wszoX1Gf9Zfgwai1XsfF1zhByl+c6Pzeic61SjoDT2dURF+Hzrge668KiC6fVMH9ooDovxlHdCmMtQr7DvW4+2aPi6/BvlnP+x75YRWBBP/Xuny/1xn9uVM+Lr4e+2aPi68njov/VtdunbDzInsVjezz4VdiDmOC2TonIOFF5/qE6ww8nVHBrFK9/6wZWCvX47/41IYkyOsUAKWK8YNXArde4e50w31v6jusWs8mTJTrk3CKRvbdaQZv39mW/WDfna5DpllZrgR/A9ffqEBRqZ6PBuhFZ0bCdQaezqhAUR11XANrTS2gkCBXUvhFU8s4UEjgUl/yc2sRG1ht40Ah4aytABQ1iEBh2Q82UFRCpllZrg5/A9ffqEBR3UkD9KKzRsJ1Bp7OqEBRF3VcD2t9LaCQIFdXAIrNjAOFBK6GAlBsRmxgmxsHCgnn5gpAUY8IFJb9YANFdWSaleW68Ddw/Y0KFHWdNEAvOuslXGfg6YwKFA1Rx42wNtYCCglyXQWg2MI4UEjg6ikAxRbEBralcaCQcG6pABSNiEBh2Q82UNRFpllZbgh/A9dft+PiHRxo3JqZ0b+iPusvwYNRTZhGxUT0hk6QcmsnOhs50dlESWfg6YyK6E3RGZth3UYB0eWTKritFRB9W+OILoXRRGHfzY2PizfEvlnPa4T8sIpAgr9NPb7fTY3+3CkfF2+GfbPHxZvxvCnatp7dOmHnRfbaXOF82Ia475hg1tQJSHjR2SzhOgNPZ1QwawEQa4m1ldbdqQS5qcIB1Nr4wSuBa6Zwd9qa2Lx2MH53KuHcQeHutCXx7tSyH+y706bINCvLLeBv4PobFShaOGmAXnS2TLjOwNMZFSh2Qh3vjLWNFlBIkFsoAEVb40AhgWupABRtiQ2snXGgkHC2UwCKnYlAYdkPNlC0QKZZWd4J/gauv1GBYicnDdCLzp0TrjPwdEYFig6o412wZmoBhQR5JwWgyDIOFBK4nRWAIovYwLKNA4WEM1sBKHYhAoVlP9hAsRMyzcpyB/gbuP5GBYoOThqgF527JFxn4OmMChS5qOM8rPlaQCFB7qAAFAXGgUICt4sCUBQQG1hH40Ah4eyoABR5RKCw7AcbKDog06ws58LfwPXX7bj4Lg407srM6F9Rn/WX4MGoTl7HxXOdIOWuTnTmOdHZKY3oGyF6Z3TGLlh3U0B0+aQKblcFRO9qHNGlMDop7Lub8XHxXOyb9bw85IdVBBL83erx/e5s9OdO+bh4F+ybPS7ehTgu3rWe3Tph50X22k3hfNjN6bh4Zycg4UVnl4TrDDydUcGsO0CsB9aeWnenEuTOCgdQL+MHrwSui8LdaS9i89rT+N2phHNPhbvTHsS7U8t+sO9OOyPTrCx3h7+B629UoOjupAF60dkj4ToDT2dUoNgbdbwP1n21gEKC3F0BKPYzDhQSuB4KQLEfsYH1Ng4UEs7eCkCxDxEoLPvBBoruyDQry3vD38D1NypQ7O2kAXrRuU/CdQaezqhA0Rd1vD/WA7SAQoK8twJQHGgcKCRw+ygAxYHEBnaQcaCQcB6kABT7E4HCsh9soNgbmWZluS/8DVx/owJFXycN0IvO/ROuM/B0RgWK/qjjAVgP1gIKCXJfBaA4xDhQSOD2VwCKQ4gN7FDjQCHhPFQBKAYQgcKyH2yg6ItMs7LcH/4Grr9ux8UzHWg8PD0u7sOogV7Hxfs7QcrDnegc4ETnwDSib4Tog9AZB2M9QgHR5ZMquMMVEH2IcUSXwhiosO8i4+Pi/bFv1vMGID+sIpDgH1GP7/cgoz93ysfFB2Pf7HHxwcRx8SH17NYJOy+y1yKF8+EIp+Pig5yAhBedgxOuM/B0RgWzYoBYCdZSrbtTCfIghQPoSOMHrwRusMLd6ZHE5nWU8btTCedRCnenJcS7U8t+sO9OByHTrCwXw9/A9TcqUBQ7aYBedJYkXGfg6YwKFMegjo/FepwWUEiQixWA4njjQCGBK1EAiuOJDWy4caCQcA5XAIpjiUBh2Q82UBQj06wsHwN/A9ffqEBxjJMG6EXnsQnXGXg6owLFCajjE7GepAUUEuRjFIDiZONAIYE7VgEoTiY2sFOMA4WE8xQFoDiRCBSW/WADxTHINCvLJ8DfwPU3KlCc4KQBetF5YsJ1Bp7OqEAxCnU8GuupWkAhQT5BAShOMw4UErgTFYDiNGIDO904UEg4T1cAitFEoLDsBxsoTkCmWVkeBX8D11+34+JZDjSemR4X92HUGK/j4qOcIOWZTnSOdqJzTBrRN0L0seiMZ2E9WwHR5ZMquDMVEP0c44guhTFGYd/nGx8XH4V9s543GvlhFYEE/+x6fL/HGv25Uz4ufhb2zR4XP4s4Ln5OPbt1ws6L7PV8hfPhbKfj4mOdgIQXnWclXGfg6YwKZuMAYhdgHa91dypBHqtwAF1o/OCVwJ2lcHd6IbF5XWT87lTCeZHC3ekFxLtTy36w707HItOsLI+Dv4Hrb1SgGOekAXrReUHCdQaezqhAcQnq+FKsl2kBhQR5nAJQXG4cKCRwFygAxeXEBjbBOFBIOCcoAMWlRKCw7AcbKMYh06wsXwJ/A9ffqEBxiZMG6EXnpQnXGXg6owLFlajjq7BerQUUEuRLFIDiGuNAIYG7VAEoriE2sGuNA4WE81oFoLiKCBSW/WADxSXINCvLV8LfwPU3KlBc6aQBetF5VcJ1Bp7OqEAxCXU8Get1WkAhQb5SASiuNw4UErirFIDiemIDu8E4UEg4b1AAislEoLDsBxsorkSmWVmeBH8D11+34+LZDjTelB4X92HUFK/j4pOcIOVNTnROdqJzShrRN0L0qeiM07DerIDo8kkV3E0KiH6LcUSXwpiisO/bjY+LT8K+Wc+bjPywikCCf3M9vt9Tjf7cKR8Xn4Z9s8fFpxHHxW+pZ7dO2HmRvd6ucD7c7HRcfKoTkPCic1rCdQaezqhgNh0gNgPrTK27UwnyVIUD6A7jB68EbprC3ekdxOZ1p/G7UwnnnQp3pzOId6eW/WDfnU5FpllZng5/A9ffqEAx3UkD9KJzRsJ1Bp7OqEBxN+r4Hqz3agGFBHm6AlDMMg4UErgZCkAxi9jAZhsHCgnnbAWguIcIFJb9YAPFdGSaleW74W/g+hsVKO520gC96Lwn4ToDT2dUoLgfdfwA1ge1gEKCfLcCUDxkHCgkcPcoAMVDxAb2sHGgkHA+rAAUDxCBwrIfbKC4G5lmZfl++Bu4/kYFivudNEAvOh9IuM7A0xkVKOagjudifVQLKCTI9ysAxWPGgUIC94ACUDxGbGCPGwcKCefjCkAxlwgUlv1gA8X9yDQry3Pgb+D663ZcPMeBxifT4+I+jJrndVx8jhOkfNKJzrlOdM5LI/pGiD4fnXEB1qcUEF0+qYJ7UgHRnzaO6FIY8xT2/ZzxcfE52DfreXORH1YRSPCfqsf3e77Rnzvl4+ILsG/2uPgC4rj40/Xs1gk7L7LX5xTOh6ecjovPdwISXnQuSLjOwNMZFcwWAsSex7pI6+5Ugjxf4QB6wfjBK4FboHB3+gKxeb1o/O5Uwvmiwt3p88S7U8t+sO9O5yPTrCwvhL+B629UoFjopAF60fl8wnUGns6oQPEy6vgVrK9qAYUEeaECUCw2DhQSuOcVgGIxsYEtMQ4UEs4lCkDxChEoLPvBBoqFyDQryy/D38D1NypQvOykAXrR+UrCdQaezqhA8Trq+A2sb2oBhQT5ZQWgeMs4UEjgXlEAireIDext40Ah4XxbASjeIAKFZT/YQPEyMs3K8uvwN3D9jQoUrztpgF50vpFwnYGnMypQLEUdL8P6rhZQSJBfVwCK5caBQgL3hgJQLCc2sPeMA4WE8z0FoFhGBArLfrCB4nVkmpXlpfA3cP11Oy6e60DjB+lxcR9Gfeh1XHypE6T8wInOZU50fphG9I0QfQU640qsqxQQXT6pgvtAAdE/Mo7oUhgfKuz7U+Pj4kuxb9bzliE/rCKQ4K+qx/d7hdGfO+Xj4iuxb/a4+EriuPhH9ezWCTsvstdPFc6HVU7HxVc4AQkvOlcmXGfg6YwKZp8BxD7Hulrr7lSCvELhAPrC+MErgVupcHf6BbF5fWn87lTC+aXC3ennxLtTy36w705XINOsLH8GfwPX36hA8ZmTBuhF5+cJ1xl4OqMCxdeo42+wfqsFFBLkzxSA4jvjQCGB+1wBKL4jNrA1xoFCwrlGASi+IQKFZT/YQPEZMs3K8tfwN3D9jQoUXztpgF50fpNwnYGnMypQ/IA6/hHrT1pAIUH+WgEofjYOFBK4bxSA4mdiA/vFOFBIOH9RAIofiUBh2Q82UHyNTLOy/AP8DVx/owLFD04aoBedPyZcZ+DpjAoU61DH67H+qgUUEuQfFIDiN+NAIYH7UQEofiM2sN+NA4WE83cFoFhPBArLfrCB4gdkmpXldfA3cP11Oy6e50BjqE/U+FfUZ/0leDCqEtOomIi+zglSUitBUed6J++zktL7DDydURE9o/5/1spYq9RXevGp3wL1+fhWlWyoRmFUUth3DfK+2ePi67Bv1vPWIz+sIpDgV6nP9ztDOY+bOi5eGftmj4tX5nlTVLW+3Tph50X2WkPhfKhC3HdMMMtwAjxedFZOuM7A0xkVzGoCxGphra0AZqkNSZAzFA6gOsYPXgmcfDPIz61DbF51jcJEuT4JZ10+TGTX4u0727If7LvTDGSaleWa8Ddw/Y0KFDWdNEAvOmslXGfg6YwKFPVRx5th3VwLKCTINRWAooFxoJDA1VIAigbEBtbQOFBIOBsqAMVmRKCw7AcbKGoi06ws14e/getvVKCo76QBetG5WcJ1Bp7OqEDRGHW8BdYttYBCglxfASi2Mg4UErjNFIBiK2ID29o4UEg4t1YAii2IQGHZDzZQ1EemWVluDH8D19+oQNHYSQP0onOLhOsMPJ1RgaIp6rgZ1m20gEKC3FgBKLY1DhQSuC0UgGJbYgPbzjhQSDi3UwCKZkSgsOwHGygaI9OsLDeFv4Hrr9tx8XwHGpunx8V9GNXC67h4UydI2dyJzmZOdLZII/pGiN4SnbEV1tYKiC6fVME1V0D0HYwjuhRGC4V972x8XLwp9s16XjPkh1UEEvzW9fl+tzT6c6d8XLwV9s0eF29FHBffob7dOmHnRfa6s8L50NrpuHhLJyDhRWerhOsMPJ1RwawNQKwt1nZad6cS5JYKB1B74wevBK6Vwt1pe2Lz6mD87lTC2UHh7rQt8e7Ush/su9OWyDQry23gb+D6GxUo2jhpgF50tk24zsDTGRUoMlHHWViztYBCgtxGAShyjAOFBK6tAlDkEBtYrnGgkHDmKgBFFhEoLPvBBoo2yDQry5nwN3D9jQoUmU4aoBedWQnXGXg6owJFPuq4AGtHLaCQIGcqAEWhcaCQwGUpAEUhsYHtahwoJJy7KgBFAREoLPvBBopMZJqV5Xz4G7j+RgWKfCcN0IvOgoTrDDydUYGiM+q4C9bdtIBCgpyvABRdjQOFBK5AASi6EhvY7saBQsK5uwJQdCEChWU/2ECRj0yzstwZ/gauv27HxQscaOzGzOhfUZ/1l+DBqO5ex8U7O0HKbk50dnGis3sa0TdC9B7ojD2x9lJAdPmkCq6bAqLvaRzRpTC6K+x7H+Pj4p2xb9bzuiA/rCKQ4Peqz/e7h9GfO+Xj4j2xb/a4eE/iuPie9e3WCTsvstd9FM6HXk7HxXs4AQkvOnsmXGfg6YwKZvsCxPbD2lvr7lSC3EPhAOpj/OCVwPVUuDvtQ2xefY3fnUo4+yrcne5HvDu17Af77rQHMs3K8r7wN3D9jQoU+zppgF507pdwnYGnMypQHIA6PhDrQf9fe2cCZFVx9fGeFZgBeTNocIlbRI1bvjcLzKB+iIpLFE1cEpfEBQdGU4JabkExOCQKmpLFcgtigpgYwJSAlmiCmrgkBjQlqOWSoCYqiQFNCWqJJogf533nQk9zX88I/9OezrtdZd2Z1/fd++8+/+7zu23PRQooyMjHCgDFycqBggw3XAAoTgYmsG8pBwoy57cEgOJEIFBojgcaKI5lT6O8fALH12DjGxQoTogkAcai88QS12lwOoMCxSk8jk/l42lSQEFGPkEAKE5XDhRkuBMFgOJ0YAL7jnKgIHN+RwAoTgUCheZ4oIHiBPY0ysuncHwNNr5BgeKUSBJgLDpPLXGdBqczKFCcweP4TD6eJQUUZORTBIDibOVAQYY7VQAozgYmsBHKgYLMOUIAKM4EAoXmeKCB4hT2NMrLZ3B8DTa+0W4Xb41AY1u2XTyOQI2Mdbv4GZEgZVskOs+MROfIDNE7IfoozoztfDxXANGpFAZcmwCin6cc0WlgjBRo9/nKt4ufwe1GXe9M9g9qEJDxz+2Lj/copY87yXbxdm43ert4O3C7+Hl99Y4TtF+orecLzA/nRrpdfFQkIBGLzvYS12lwOoOC2WgGsTF8vEBq7ZSMPEpgArpQ+cRLhmsXWDu9EJi8LlK+dkrmvEhg7XQMcO1UczzQa6ej2NMoL4/m+BpsfIMCxehIEmAsOseUuE6D0xkUKC7mcXwJHy+VAgoy8mgBoLhMOVCQ4cYIAMVlwAR2uXKgIHNeLgAUlwCBQnM80EAxmj2N8vLFHF+DjW9QoLg4kgQYi85LSlynwekMChRjeRxfwccrpYCCjHyxAFCMUw4UZLhLBIBiHDCBXaUcKMicVwkAxRVAoNAcDzRQXMyeRnl5LMfXYOMbFCjGRpIAY9F5RYnrNDidQYFiPI/jq/nYIQUUZOSxAkAxQTlQkOGuEACKCcAE9kPlQEHm/KEAUFwNBArN8UADxVj2NMrL4zm+BhvfaLeLD45A4zXZdvE4AnVtrNvFx0eClNdEovPqSHRemyF6J0SfyJlxEh+vE0B0KoUBd40Aol+vHNFpYFwr0O4blG8XH8/tRl3vavYPahCQ8a/ri4/3RKWPO8l28UncbvR28UnA7eLX99U7TtB+obbeIDA/XBfpdvGJkYBELDonlbhOg9MZFMwmM4hN4eNUqbVTMvJEgQlomvKJlww3SWDtdBowed2ofO2UzHmjwNrpFODaqeZ4oNdOJ7KnUV6ezPE12PgGBYrJkSTAWHROKXGdBqczKFDcxOP4Zj7eIgUUZOTJAkBxq3KgIMNNEQCKW4EJ7DblQEHmvE0AKG4GAoXmeKCBYjJ7GuXlmzi+BhvfoEBxUyQJMBadN5e4ToPTGRQopvM4vp2PM6SAgox8kwBQ3KEcKMhwNwsAxR3ABPZT5UBB5vypAFDcDgQKzfFAA8VN7GmUl6dzfA02vkGBYnokCTAWnbeXuE6D0xkUKGbyOL6Tj7OkgIKMPF0AKO5SDhRkuNsFgOIuYAL7uXKgIHP+XAAo7gQCheZ4oIFiOnsa5eWZHF+DjW+028UPjEDj3dl28TgC9ctYt4vPjAQp745E552R6PxlhuidEH02Z8Y5fJwrgOhUCgPubgFEv0c5otPA+KVAu+9Vvl18Jrcbdb072T+oQUDGn9sXH+/ZSh93ku3ic7jd6O3ic4Dbxe/pq3ecoP1Cbb1XYH6YG+l28dmRgEQsOueUuE6D0xkUzOYxiM3n4wKptVMy8myBCeg+5RMvGW6OwNrpfcDkdb/ytVMy5/0Ca6fzgWunmuOBXjudzZ5GeXkex9dg4xsUKOZFkgBj0Tm/xHUanM6gQPEAj+OFfHxQCijIyPMEgOIh5UBBhpsvABQPARPYr5UDBZnz1wJAsRAIFJrjgQaKeexplJcf4PgabHyDAsUDkSTAWHQuLHGdBqczKFAs4nH8MB8fkQIKMvIDAkDxqHKgIMMtFACKR4EJ7LfKgYLM+VsBoHgYCBSa44EGigfY0ygvL+L4Gmx8gwLFokgSYCw6Hy5xnQanMyhQPMbj+HE+PiEFFGTkRQJA8aRyoCDDPSwAFE8CE9jvlQMFmfP3AkDxOBAoNMcDDRSL2NMoLz/G8TXY+Ea7XfygCDQ+lW0XjyNQf4x1u/hjkSDlU5HofDwSnX/MEL0Toi/mzLiEj08LIDqVwoB7SgDRn1GO6DQw/ijQ7meVbxd/jNuNut7j7B/UICDjP90XH+/FSh93ku3iS7jd6O3iS4DbxZ/pq3ecoP1CbX1WYH54OtLt4osjAYlYdC4pcZ0GpzMomC1lEFvGx+ek1k7JyIsFJqDnlU+8ZLglAmunzwOT1wvK107JnC8IrJ0uA66dao4Heu10MXsa5eWlHF+DjW9QoFgaSQKMReeyEtdpcDqDAsWLPI5f4uPLUkBBRl4qABSvKAcKMtwyAaB4BZjA/qwcKMicfxYAipeAQKE5HmigWMqeRnn5RY6vwcY3KFC8GEkCjEXnSyWu0+B0BgWK5TyOX+Xja1JAQUZ+UQAoXlcOFGS4lwSA4nVgAvurcqAgc/5VACheBQKF5niggeJF9jTKy8s5vgYb36BAsTySBBiLzldLXKfB6QwKFG/wOH6Tj29JAQUZebkAUKxQDhRkuFcFgGIFMIH9XTlQkDn/LgAUbwKBQnM80ECxnD2N8vIbHF+DjW+028UPjkDj29l28TgC9c9Yt4u/EQlSvh2Jzjcj0fnPDNE7IfpKzoyr+PiOAKJTKQy4twUQ/V3liE4D458C7X5P+XbxN7jdqOu9yf5BDQIy/jt98fFeqfRxJ9kuvorbjd4uvgq4XfzdvnrHCdov1Nb3BOaHdyLdLr4yEpCIReeqEtdpcDqDgtlqBrE1fHxfau2UjLxSYAL6QPnES4ZbJbB2+gEweX2ofO2UzPmhwNrpGuDaqeZ4oNdOV7KnUV5ezfE12PgGBYrVkSTAWHSuKXGdBqczKFB8xON4LR8/lgIKMvJqAaD4RDlQkOHWCADFJ8AE9m/lQEHm/LcAUKwFAoXmeKCBYjV7GuXljzi+BhvfoEDxUSQJMBada0tcp8HpDAoU63gcf8rH9VJAQUb+SAAoPlMOFGS4tQJA8RkwgZmcbqAomDOHB4pPgUChOR5ooPiIPY3y8jqOr8HGNyhQrIskAcai89MS12lwOoMCRTmP4wo+VubwHV9oEBl5nQBQVAknw/zWlYLhPhUACrvdW9uH1cqBgsxZLQAUFbh2N2qOBxoo1rGnUV4u5/gabHyj3S7+vxFo7In0aDHq094JMQSqFzJQIRG9PIfvXAmdPSPRWRGJzl5COg1OZ1BEr+HMWMvH3gKITqUw4MjMaHzroxzRaWD0Emh3Dtxu9Hbxcm436noV7B/UICDj987h412j9HEn2S5ey+1GbxevxcWmrU9O7zhB+4XamhOYH3oD2x0SzGoiAYlYdNaWuE6D0xkUzOoYxOr52E9q7ZSMXCMwAW2rfOIlw9F/5eDrbgtMXtspXzslc24nsHZaD1w71RwP9NppDXsa5eU6jq/BxjcoUNRFkgBj0Vlf4joNTmdQoOjP43h7Pu4gBRRk5DoBoNhROVCQ4eoFgGJHYALbSTlQkDl3EgCK7YFAoTkeaKCoY0+jvNyf42uw8Q0KFP0jSYCx6Ny+xHUanM6gQLEzj+Nd+LirFFCQkfsLAMVuyoGCDLe9AFDsBkxguysHCjLn7gJAsQsQKDTHAw0U/dnTKC/vzPE12PgGBYqdI0mAsejcpcR1GpzOoECxB4/jAXzcUwooyMg7CwDFXsqBggy3iwBQ7AVMYHsrBwoy594CQDEACBSa44EGip3Z0ygv78HxNdj4RrtdfEgEGvdBerQY9WnvhBgCtS8yUCERfY9IkHKfSHQOiETnvkI6DU5nUETfjzPj/nw8QADRqRQG3D4CiP415YhOA2NfgXY3gNuN3i6+B7cbdb0B7B/UICDjH5DDx3s/pY87yXbx/bnd6O3i++Ni0/a1nN5xgvYLtbVBYH44ANjukGC2XyQgEYvO/Utcp8HpDApmjQxiTXxsllo7JSPvJzABDVQ+8ZLh9hdYOx0ITF6DlK+dkjkHCaydNgHXTjXHA712uh97GuXlRo6vwcY3KFA0RpIAY9HZVOI6DU5nUKBo5XE8mI8HSgEFGblRACgOUg4UZLgmAaA4CJjADlYOFGTOgwWAYjAQKDTHAw0UjexplJdbOb4GG9+gQNEaSQKMRefgEtdpcDqDAsUQHseH8HGoFFCQkVsFgOJQ5UBBhhssABSHAhPYYcqBgsx5mABQHAIECs3xQANFK3sa5eUhHF+DjW9QoBgSSQKMRechJa7T4HQGBYphPI6P4OORUkBBRh4iABRHKQcKMtwhAkBxFDCBHa0cKMicRwsAxRFAoNAcDzRQDGFPo7w8jONrsPGNdrv4IRFoPAbp0WLUp70TYgjUschAhUT0YZEg5TGR6DwiEp3HCuk0OJ1BEX04Z8bj+Hi8AKJTKQy4YwQQ/RvKEZ0GxrEC7T4R3G70dvFh3G7U9Y5g/6AGARn/+Bw+3sOVPu4k28WP43ajt4sfh4tN2zdyescJ2i/U1hMF5ofjge0OCWbDIwGJWHQeV+I6DU5nUDA7iUHsZD5+S2rtlIw8XGAC+rbyiZcMd5zA2um3gcnrFOVrp2TOUwTWTk8Grp1qjgd67XQ4exrl5ZM4vgYb36BAcVIkCTAWnSeXuE6D0xkUKE7jcXw6H78jBRRk5JMEgOK7yoGCDHeyAFB8F5jAzlAOFGTOMwSA4nQgUGiOBxooTmJPo7x8GsfXYOMbFChOiyQBxqLz9BLXaXA6gwLFWTyOz+bjCCmgICOfJgAU5ygHCjLc6QJAcQ4wgbUpBwoyZ5sAUJwNBArN8UADxWnsaZSXz+L4Gmx8gwLFWZEkwFh0nl3iOg1OZ1CgGMXjuJ2P50oBBRn5LAGgOE85UJDhzhYAivOACex7yoGCzPk9AaBoBwKF5niggeIs9jTKy6M4vgYb32i3iw+NQOP5SI8Woz7tnRBDoEYjAxUS0UdFgpTnR6KzPRKdo4V0GpzOoIg+hjPjBXy8UADRqRQG3PkCiH6RckSngTFaoN2XgNuN3i4+ituNul47+wc1CMj4F+bw8R6j9HEn2S5+AbcbvV38Alxs2i7K6R0naL9QWy8RmB8uBLY7JJiNiQQkYtF5QYnrNDidQcHsUgaxy/h4udTaKRl5jMAE9H3lEy8Z7gKBtdPvA5PXWOVrp2TOsQJrp5cB1041xwO9djqGPY3y8qUcX4ONb1CguDSSBBiLzstKXKfB6QwKFFfyOB7Hx6ukgIKMfKkAUPxAOVCQ4S4TAIofABPYeOVAQeYcLwAU44BAoTkeaKC4lD2N8vKVHF+DjW9QoLgykgQYi85xJa7T4HQGBYoOHscT+PhDKaAgI18pABQ/Ug4UZLhxAkDxI2ACu0Y5UJA5rxEAiglAoNAcDzRQXMmeRnm5g+NrsPENChQdkSTAWHROKHGdBqczKFBM5HE8iY/XSQEFGblDACiuVw4UZLgJAkBxPTCB/Vg5UJA5fywAFJOAQKE5Hmig6GBPo7w8keNrsPGNdrv4oRFovAHp0WLUp70TYgjUZGSgQiL6xEiQ8oZIdE6KROdkIZ0GpzMook/hzDiVj9MEEJ1KYcDdIIDoNypHdBoYkwXafTO43ejt4hO53ajrTWL/oAYBGX9aDh/vKUofd5Lt4lO53ejt4lNxsWm7Mad3nKD9Qm29WWB+mAZsd0gwmxIJSMSic2qJ6zQ4nUHB7BYGsVv5eJvU2ikZeYrABPQT5RMvGW6qwNrpT4DJa7rytVMy53SBtdNbgWunmuOBXjudwp5GefkWjq/BxjcoUNwSSQKMReetJa7T4HQGBYoZPI7v4ONPpYCCjHyLAFD8TDlQkOFuFQCKnwET2EzlQEHmnCkAFHcAgUJzPNBAcQt7GuXlGRxfg41vUKCYEUkCjEXnHSWu0+B0BgWKWTyO7+Ljz6WAgow8QwAofqEcKMhwdwgAxS+ACexu5UBB5rxbACjuAgKF5niggWIGexrl5VkcX4ONb1CgmBVJAoxF510lrtPgdAYFitk8jufwca4UUJCRZwkAxT3KgYIMd5cAUNwDTGC/Ug4UZM5fCQDFHCBQaI4HGihmsadRXp7N8TXY+Ea7XfywCDTei/RoMerT3gkxBGoeMlAhEX12JEh5byQ650Sic56QToPTGRTR53NmXMDH+wQQnUphwN0rgOj3K0d0GhjzBNq9ENxu9Hbx2dxu1PXmsH9Qg4CMf18OH+/5Sh93ku3iC7jd6O3iC3Cxabs/p3ecoP1CbV0oMD/cB2x3SDCbHwlIxKJzQYnrNDidQcHsQQaxh/j4a6m1UzLyfIEJ6DfKJ14y3AKBtdPfAJPXIuVrp2TORQJrpw8B1041xwO9djqfPY3y8oMcX4ONb1CgeDCSBBiLzodKXKfB6QwKFI/wOH6Uj7+VAgoy8oMCQPE75UBBhntIACh+B0xgjykHCjLnYwJA8SgQKDTHAw0UD7KnUV5+hONrsPENChSPRJIAY9H5aInrNDidQYHiCR7HT/Lx91JAQUZ+RAAo/qAcKMhwjwoAxR+ACewp5UBB5nxKACieBAKF5niggeIR9jTKy09wfA02vkGB4olIEmAsOp8scZ0GpzMoUCzmcbyEj09LAQUZ+QkBoHhGOVCQ4Z4UAIpngAnsT8qBgsz5JwGgWAIECs3xQAPFE+xplJcXc3wNNr7Rbhc/PAKNzyI9Woz6tHdCDIFaigxUSERfHAlSPhuJziWR6FwqpNPgdAZF9GWcGZ/j4/MCiE6lMOCeFUD0F5QjOg2MpQLtfgncbvR28cXcbtT1lrB/UIOAjP98Dh/vZUofd5Lt4s9xu9HbxZ/DxabthZzecYL2C7X1JYH54Xlgu0OC2bJIQCIWnc+VuE6D0xkUzF5mEHuFj3+WWjslIy8TmID+onziJcM9J7B2+hdg8lqufO2UzLlcYO30FeDaqeZ4oNdOl7GnUV5+meNrsPENChQvR5IAY9H5SonrNDidQYHiNR7Hr/Pxr1JAQUZ+WQAo/qYcKMhwrwgAxd+ACewN5UBB5nxDACheBwKF5niggeJl9jTKy69xfA02vkGB4rVIEmAsOl8vcZ0GpzMoULzF43gFH/8uBRRk5NcEgOIfyoGCDPe6AFD8A5jA3lYOFGTOtwWAYgUQKDTHAw0Ur7GnUV5+i+NrsPENChRvRZIAY9G5osR1GpzOoECxksfxKj6+IwUUZOS3BIDiXeVAQYZbIQAU7wIT2L+UAwWZ818CQLEKCBSa44EGirfY0ygvr+T4Gmx8o90uPiwCje8hPVqM+rR3QgyBWo0MVEhEXxkJUr4Xic5VkehcLaTT4HQGRfQ1nBnf5+MHAohOpTDg3hNA9A+VIzoNjNUC7V4Lbjd6u/hKbjfqeqvYP6hBQMb/IIeP9xqljzvJdvH3ud3o7eLv42LT9mFO7zhB+4XaulZgfvgA2O6QYLYmEpCIRef7Ja7T4HQGBbOPGcQ+4eO/pdZOychrBCag/yifeMlw7wusnf4HmLzWKV87JXOuE1g7/QS4dqo5Hui10zXsaZSXP+b4Gmx8gwLFx5EkwFh0flLiOg1OZ1CgWM/j+LNkPNfhO77QIDLyxwJAUVanGyjIcJ8IAIXd7q3tw/I63UBB5iSNaKD4DAgUmuOBBoqP2dMoL6/n+BpsfIMCxfpIEmAsOj8rcZ0GpzMoUFTyOK7iY7UUUJCR1wsARQ/lQEGG+0wAKHoAE1hP5UBB5uwpABRVuHY3ao4HGijWs6dRXq7k+BpsfIMCRWVdHAkwFp1VJa7T4HQGBYoaHse1fOwtBRRkZPoPnWz6KAcKMhz9hwaKPsAEto1yoCBzbiMAFLVAoNAcDzRQVLKnUV6u4fgabHyj3S5+RAQac0iPFqM+7Z0QQ6DqkIEKieg1kSBlLhKdtZHorMsQvROi13Nm7MfHbQUQnUphwOUEEH075YhOA6NOoN3bg9uN3i5ew+1GXa+W/YMaBGT8bevw8a5X+riTbBfvx+1Gbxfvh4tN23Z1escJ2i/U1u0F5odtge0OCWb1kYDE2p5x6OwXSX9WGBmdBqczKJjtwCC2Ix93suYIeOcfaXRPkjTY6gUmyS8rTw7U7n4C7d5FebtpIEi0e1ela5+JPmp3PRByaRLZSeD/D+wABLTdlMeE5kbgeCnMtbsJrEenjcOtfVjYkf2DfljYEfiw8GWgF3ePwIu7gr24eyAv5reuNFCcdxXICV+JIOY7gWP+FaGYS7S9Htz2HQTyYT1wDtoj0APb1uocEInOPbdcZ4P7AWmr3/BfpaWV4rWefx5Q5Oc9+efke3tt+H3vDf99dcN/+9Rt+jwpaH9WAftzL2Dcy6w+qbDaXsGfl5vOvki8Qe0ZZtUl/x9+5txdFu60ovx0q8rUeuq28dTlPHV1nrp6T10/T922nrrtPHVf8tT199Rt76nbwVO3o6duJ0/dlz11O3vqdvHU7eqp281Tt7un7iueuj08dQM8dXt66vby1O3tqfuqp24fT92+nrr9PHX7e+oO8NR9zVP3P566vKeuwVPX6Klr8tQ1e+oGeuoGeepaPHWtnrrBnroDPXUHeeoO9tT9r6duiKfuEE/dUE/doZ66wzx1h3vqhnnqjvDUHempO8pTd7Sn7uueumM8dcd66oZ76o7z1B3vqfuGp+6bReqSPL2Ak3Ev/j3J1WV8zlD+Pb91paGXdV309VvzrYN6mc4FrL+pF19Tsn+SawpcP9+DrzOsY9P13bZQ6WM6M5r9nQ3L2Bv5hn7+kvV9+xqGf3avk9wvaWulQFtbN1Bwcv0qgevn8835PkkbOzpfP+k/KpVWXaVTV2XVVVn9Obqs83nXWue5fSfhE7vvJGKzoe8a+qXor7TaRuXwDol75/O13M/fLyvel2XA+/Vx2pfcw763kEcbypz7Gaedxrl/jZGMe76hzLlfosftH9fn1TL9ky9zrm/rqU7pnySWPVLqkmv15N+rrGvZ51dbbbTPt39Ovm9/ljxb5FKu6Xq3h9m8PfZnSf+Slt2cttmxKStyTK7rflbuaLT7xh7fYh7bsMrTK6V/jMGP5+qUfkru3VOibfnGbo/n5P41RnL8bBrPPR09bv+447mXTP/kaS0n8Z7dH5UpfePq6OForBHSmMYNiaY0bkh00Dk/sNjAbqMxm3tQKnd314PJ/WvM5vGQ8GClo6cr7uwh0z/57szBLg+6vrRjZ/vUzin2+T2sNrq+tp+JqpzPkufsnEmft2wNaWPc/szOKUOctqWxz5bmFLdvjNkUUyGP5WU905iXzRv5Rtl5tzmfNmcanP6Nz8W1Mv2z8fq9HW+Brt+cjINy5/pUaLx80/k8qbPHu/3dHla9ff6RZZuueRJ/1jfl++7cgxifvnnPPqfW0VWd0q60Oa7auXfanNrT0eLOXZUpOu257vNcM/GKXZfWlqQuye3VRc5PrlflnH82H0nHNCv/F/R2bPq+nd8Kbe3o3L6h/Hl+q0pzA+m4yeEQm/WqOjq3O80PdrsTP6Q91/R26uy5v9pqb9rYGgppb77djZV9D3u+KDYOqoucn1yvyjl/NB/teKflH2AbG119Nj+leTpt7NrPyIVrdGze1i/Cm4meQl93dO6/bay6Cud8O1/mnPPTvGk/6/ax2uv2E669Te3CeWtjXuwjc/1W9znGng+oz8aZ9HjZebEsJV5VzvnVVl4cz5/1Tfm+u87j7lkwRnbtdUOXt5Y59zMm/fkq+azGbD7/SDxfpa3r2/1T7vRdpUerzLPpwOYy5/q21rT1RVk9g9p16WnR1j8NyvS06dLTmM/i5SstjZkeX1EXr8HK9DRl491XBinrH3X5VFu8lI2vQQOV6VHGP00jsvnHV1rOUaZn5NY+CyWaqMju/WgcVObcL9Fqf2bfX9veD3dtMU2rzLrKJt/59oXYWmX1NDbq0jNIWf9syntK9IxSpqc587OvbMrDWf+klZaB2fjy9k9TNh969bRk/vHq0Ta+lOWLLL/7S4u2eGnzs7b5R1n/tCjjDW3809iW9Y+vtGgbX9ryhbL5WV2+aM3Gl69oez5tUva806RtPty4Ttzdtc7e1rkXXfy9Cy41Tql2fi+3hCfiqfQvcl5S7D+qtAXuWeR77qZH+7vG+d29t7G0FfvOninXT9ssnWzCpc1hycYtezOe+0cBOeu6Fc75xmzef3Up5+ecc4x1775WXZ1z3jYpba9OuZartdps3lf2d6uc87fhk6hv7ilLv6b9ma25WPuri5yfczQk59dbGqaVpV+zIkUX/exuJrXr3D+qrLfu78aTfnY3/iXn97f03cs/p21QTe79RWxQTbQW9Hd0bnc/q64i5Xw3jtumnN/POifps5xzvh2vtA2t9Z5r2j6xz7Hj2c/R6XrM3phvfy+Z16qc8wfwzcivhzu+S86xP7PHqLtZ1h5/aef3dTQk5381xftp3kr67ovwlj0PuN7yzXlUXG+ledHuJ9dbxTxSbI7s5Zxj/2zHoDvjPzm/KWX8b2n767vZ/rQcUW/S7502FujnPkXubXvUPsf1aHL+gSk5Qtv8Z49X16NpfW6f3x2P2n3v86hv/kvumTbfpP0RQZn13WRDe9pm922s67qb3cusNrqbDOhn9w+T0nSkwW/aPJk2ppLzEz+n+a2XSR/fQ/n3/FaVhrw7R9v9m6bHHV/lJj2v+OajtOvXOX1hf78Ye3b3jxSS809MmavSxqrd91QqrbqY8klX82nSZzlTfBx/3jHoer8Yc9t/aGKff4YVI5d3k+/XmnQPudzRx7pHd3Jacv6Ibvrki5zTfX90lTbv2Od359nMHn/unO7zkD1W3RxblnIfW4s7j5en3If8ZP8xL5UeHZ2vWzhanyX9k+jpaZ/v1PWy6io7Ot+nhn+vtO5jXyvRUeWcfzlfYOOYsL6TfD+Xcv9q5/6ddKd8ZveXe62KlM/sNYgL+UsUA0k/t7T+/4tsC5r4+lWWPrtUWvX2+VfxBdw/hk/8N3QLdba3jGhobxrRPmLgiJEjm9tG1DvXt/vM7qdqgX7K8x+NFtrP168wm/op6Rv7/mn+Ts5LtPaS0Zp3x4gdU9tzSVvKnfPdn90xNNXKBXYbk3bYn9nX35gzrLq0OSLRmDZGazs+37V6OtfqsRXXSnTlUs7vsYW60q7lzjWfZ+6YYM0d6DHZPHBES9uIloaGwc0No5obBnY1JtPiZ+dsKkm/2fN4dUrbqpzzbyvb1ObpDhdUpdyPzpvrOa+syLFwjZTPKjs6f5YWIzveyfnJvWtSNCZ1thdsnqDSm3+3+8u+VqKjyjn/bifv2eMz+X6aF+2x7d4r7f7dGeu1KedTfH7m5BK77cD5ceNLndxcYX+W1pbDU9pyeJG2zBUch42trYMGN56Tb24Z2dY+srmpq3GIvn/bwEHntG2YDPKjCv/OQGNX95/FP8f9wt3mllAv3K2QuX6j7MvS0l+4a7fFfRGP7ZfkO2kvIziC6+jZK3n+oZ9z1vWoHGndd+O8bDZ/fgF6YpBwzDa+PNbVn7SNivTLY2c4fWk/H6Dameh3/3gord1unb1O7F6nOy8PlIndlr/cQmL+ynfxcou0uTt7uUVSspdbdNE/2cstvCV7uYW/ZC+38Jfs5RZd6MlebuEt2cst/CV7uUUXerKXW3hL9nILf4nr5RbdeRYyZvPnyOzlFtnLLfwle7lFF3qyP37168lebuEt2cst/CV7uUUX/ZO93MKvJ3u5hV9P9nILv54sv3tL9nKLLvRkL7fwluzlFl3oyV5u4S3Zyy260JO93MLfP9nLLbwle7lFF3qyl1skC7v/TS+3sO+X6Inhj1vu5N+/6D9uWcg/R76BdmSoDbQy/3JpfpDwv1yauoE27V9n3NINtH1M5zmGypFOnT2pHeXU2ZPg0U6dPb98netIb/LSDfr5S5Z+Ksd0bGpbmVN3rFVX7tQNt+qStkhubt7g3RGy/5Mv39QvRX+V1TYq0ht955tNxfZeuenc165PbG+Wm8196+aLXs659ngq7+K6ZZ5zazzXrXLOdV+6U5PSbvf3cke/7Xv3Xz+kMpSP+a0rDSalPW4fVxfpi4qU9vYs0hdpfezGucw51/aEG4/yIvcpxhD27762VThtK0+5Tnc2fsvk0e5v/HYhViLv5q3/YV/u6HH7p9zpu0qP1mzjd7bxO9v43VXJNn77S7bx21+yjd9d6Mk2fntLtvHbX7KN313oyTZ+e0u28dtf9G783tJnIWM2f47MNn5nG7/9Jdv43YWebGOYX0+28dtbso3f/pJt/O6if7KN33492cZvv55s47dfT5bfvSXb+N2Fnmzjt7dkG7+70JNt/PaWbON3F3qyjd/+/sk2fntLtvG7Cz3Zxu/k9//Wf9Wwxqkrc65v19mL3Mlmuxg2jD/Av3/RG8b/D5xcD+yzhRgA","debug_symbols":"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zOdet2c+97o987nX7ZnPvW7PfO51e+Zzr9szn3vdnvnc6/bM5163Zz73uj3zudftmc+9bs987nV75nOv2zOfe92e+dzr9sznXrdnPve6PfO51+2Zz71uz3zudXvmc6/bM597PZ5V9gCfez2egT3A516PZ2AP8LnX4xnYA3zu9XgG9gCfez2egT3A516PZ409wOdej2eNPcDnXo9njT3A516PZ409wOdej2eNPcDnXo9nnT3A516PZ509wOdej2edPcDnXo9nnT3A516PZ509wOdej2fKHuBzr8czZQ/wudfjmbIH+Nzr8UzZA3zu9Xim7AE+93o8M/YAn3s9nhl7gM+9Hs+MPcDnXo9nxh7gc6/HM2MP8LnX49lgD/C51+PZYA/wudfj2WAP8LnX49lgD/C51+PZYA/wudfj2WQP8LnX49lkD/C51+PZZA/wudfj2WQP8LnX49lkD/C51+2Zz71uz3zudXvmc6/bM5973Z753Ov2zOdet2c+97o987nX7ZnPvW7PfO51e+Zzr9szn3vdnvnc6/bM5163Zz73uj3zudftmc+9bs987nV75nOv2zOfe92e+dzr9sznXrdnPve6PfO51+2Zz71uz3zudXvmc6/bM597PZ5V9gCfez2egT3A516PZ2AP8LnX4xnYA3zu9XgG9gCfez2egT3A516PZ409wOdej2eNPcDnXo9njT3A516PZ409wOdej2eNPcDnXo9nnT3A516PZ509wOdej2edPcDnXo9nnT3A516PZ509wOdej2fKHuBzr8czZQ/wudfjmbIH+Nzr8UzZA3zu9Xim7AE+93o8M/YAn3s9nhl7gM+9Hs+MPcDnXo9nxh7gc6/HM2MP8LnX49lgD/C51+PZYA/wudfj2WAP8LnX49lgD/C51+PZYA/wudfj2WQP8LnX49lkD/C51+PZZA/wudfj2WQP8LnX49lkD/C51+2Zz71uz3zudXvmc6/bM5973Z753Ov2zOdet2c+97o987nX7ZnPvW7PfO51e+Zzr9szn3vdnvnc6/bM5163Zz73uj3zudftmc+9bs987nV75nOv2zOfe92e+dzr9sznXrdnPve6PfO51+2Zz71uz3zudXvmc6/bM597PZ5V9gCfez2egT3A516PZ2AP8LnX4xnYA3zu9XgG9gCfez2egT3A516PZ409wOdej2eNPcDnXo9n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kAlDyIQhZMIQMmEImTCETBhCJgwhE4aQCUPIhCFkwhAyYQiZMIRMGEImDCEThpAJQ8iEIWTCEDJhCJkwhEwYQiYMIROGkAlDyIQhZMIQMmEImTCETBhCJgwhE4aQCUPIhCFkwhAyYQiZMIRMGEImDCEThpAJQ8iEIWTCEDJhCJkwhEwYQiYMIROGkAlDyIQhZMIQMmEImTCETBhCJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJoxKJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjEYmjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mjE4mDCUThpIJQ8mEoWTCUDJhKJkwlEwYSiYMJROGkglDyYShZMJQMmEomTCUTBhKJgwlE4aSCUPJhKFkwlAyYSiZMJRMGEomDCUThpIJQ8mEoWTCUDJhKJkwlEwYSiYMJROGkglDyYShZMJQMmEomTCUTBhKJgwlE4aSCUPJhKFkwlAyYSiZMJRMGEomDCUThpIJQ8mEoWTCUDJhKJkwlEwYSiYMJROGkglDyYShZMJQMmEomTCUTBhKJgwlE4aSCUPJhKFkwlAyYSiZMJRMGEomDCUThpIJQ8mEoWTCUDJhKJkwlEwYSiYMJROGkglDyYShZMJQMmEomTCUTBhKJgwlE4aSCUPJhKFkwlAyYSiZMJRMGEomDCUThpIJQ8mEocmELZmwJRO2ZMKWTNiSCVsyYUsmbMmELZmwJRO2ZMKWTNiSCVsyYUsmbMmELZmwJRO2ZMKWTNiSCVsyYUsmbMmELZmwJRO2ZMKWTNiSCVsyYUsmbMmELZmwJRO2ZMKWTNiSCVsyYUsmbMmELZmwJRP2udfr4sVLd3L/7Ho29TPz7yXqup4l6ifpWXLK9Wy6FSZLz5Jtn2fJKdez2S6RZcuye/n3n3/6n9/9+Zff/duvf/jvn/7lb9f//Y+//vH3f/nlT388//cv/++/4l/+7c+//PrrL//52//6859+/4d//+uf//DbX//0+/VvP5XzP/96XXb/fF2I/ubnn65T+dfrtsPP1ztw/T+s/3e93deZr39bP3qdws/Xu7r+7/rZ65r1euT4zd/9oX/bP7N+peKFjtZ/rPkfrwdezOU3f//733/z9/8P","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"51":{"source":"use noir_edwards::{ScalarField, bjj::BabyJubJub, Curve, CurveTrait};\nuse super::utils::poseidon2_hash;\n\n// [8]G precalculated\nglobal BASE8_POINT: [Field; 2] = [\n    5299619240641551281634865583518297030282874472190772894086521144482721001553,\n    16950150798460657717958625567821834550301663161624707787222815936182638968203,\n];\n\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n\n#[field(bn254)]\npub fn derive_public_key(private_key: Field) -> [Field; 2] {\n    let private_scalar: ScalarField<64> = ScalarField::from(private_key);\n    let base8_point: BabyJubJub = Curve::new(BASE8_POINT[0], BASE8_POINT[1]);\n    let point = base8_point.mul(private_scalar);\n    [point.x, point.y]\n}\n\n#[field(bn254)]\npub fn derive_shared_key(private_key: Field, public_key_packed: [Field; 2]) -> Field {\n    let private_scalar: ScalarField<64> = ScalarField::from(private_key);\n    let point: BabyJubJub = Curve::new(public_key_packed[0], public_key_packed[1]);\n    let shared_key = point.mul(private_scalar);\n    shared_key.x\n}\n\n#[test]\nfn test_e2e() {\n    let a_key = poseidon2_hash([0]);\n    let a_pubkey = derive_public_key(a_key);\n\n    let b_key = poseidon2_hash([1]);\n    let b_pubkey = derive_public_key(b_key);\n\n    let key_1 = derive_shared_key(a_key, b_pubkey);\n    let key_2 = derive_shared_key(b_key, a_pubkey);\n\n    assert(key_1 == key_2);\n\n    println(f\"Alice public key: {a_pubkey}\");\n    println(f\"Alice private key: {a_key}\");\n    println(\"\");\n    println(f\"Bob public key: {b_pubkey}\");\n    println(\"\");\n    println(f\"Shared Key 1: {key_1}\");\n    println(f\"Shared Key 2: {key_2}\");\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/ecdh.nr"},"54":{"source":"use poseidon::{poseidon2::Poseidon2};\n\n#[field(bn254)]\npub fn poseidon2_hash<let N: u32>(value: [Field; N]) -> Field {\n    Poseidon2::hash(value, N)\n}\n\n#[field(bn254)]\npub fn commit<let N: u32>(value: [Field; N], salt: Field) -> Field {\n    poseidon2_hash([poseidon2_hash(value), salt])\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/utils.nr"},"56":{"source":"mod scalar_field;\nmod test;\npub mod bjj;\n\npub use crate::scalar_field::ScalarField;\nuse std::ops::{Add, Neg, Sub};\n\npub struct Curve<Params> {\n    pub x: Field,\n    pub y: Field,\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### T R A I T S\n// ####################################################################################################################\n// ####################################################################################################################\n\n/// Parametrises a Twisted Edwards curve\ntrait TECurveParameterTrait {\n    fn a() -> Field; // twisted edward curve parameter a\n    fn d() -> Field; // twisted edward curve parameter d\n    fn gen() -> (Field, Field); // generator point x/y coordinates\n}\n\n/// Defines methods that a valid Curve implementation must satisfy\npub trait CurveTrait<Params>: Add + Sub + Eq + Neg + Default {\n    fn new(x: Field, y: Field) -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn dbl(self) -> Self;\n    fn mul<let NScalarSlices: u32>(self, x: ScalarField<NScalarSlices>) -> Self;\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self;\n\n    fn eq(self, x: Self) -> bool {\n        self == x\n    }\n    fn is_zero(self) -> bool {\n        self == Self::zero()\n    }\n\n    fn is_on_curve(self) -> bool;\n    fn assert_is_on_curve(self);\n    fn assert_equal(self, other: Self);\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### C O N S T R A I N E D    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> std::default::Default for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Returns point at infinity\n    ///\n    /// Cost: 0 gates\n    fn default() -> Self {\n        Curve::zero()\n    }\n}\n\nimpl<Params> std::ops::Add for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self + other`\n    ///\n    /// Cost: 7 gates\n    fn add(self, other: Self) -> Self {\n        Curve::add_internal(self, other, Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::ops::Neg for Curve<Params> {\n    /// Negate a point\n    ///\n    /// Cost: usually 0, will cost 1 gate if the `x` coordinate needs to be converted into a witness\n    fn neg(self) -> Self {\n        Curve { x: -self.x, y: self.y }\n    }\n}\n\nimpl<Params> std::ops::Sub for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self - other`\n    ///\n    /// Cost: 7 gates\n    fn sub(self, other: Self) -> Self {\n        Curve::add_internal(self, other.neg(), Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::cmp::Eq for Curve<Params> {\n    /// Compute `self == other`\n    ///\n    /// Cost: 6 gates\n    fn eq(self, other: Self) -> bool {\n        (self.x == other.x) & (self.y == other.y)\n    }\n}\n\nimpl<Params> std::convert::From<(Field, Field)> for Curve<Params> {\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    ///\n    /// Cost: 0 gates\n    fn from((x, y): (Field, Field)) -> Self {\n        Curve { x, y }\n    }\n}\n\nimpl<Params> CurveTrait<Params> for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n\n    /// Construct a new point\n    ///\n    /// If you know the x/y coords form a valid point DO NOT USE THIS METHOD\n    /// This method calls `assert_is_on_curve` which costs 3 gates.\n    /// Instead, directly construct via Curve{x, y} or use from((x, y))\n    ///\n    /// Cost: 3 gates\n    fn new(x: Field, y: Field) -> Self {\n        let result = Curve { x, y };\n        result.assert_is_on_curve();\n        result\n    }\n\n    /// Return the Identity element (point at infinity)\n    ///\n    /// Cost: 0 gates\n    fn zero() -> Self {\n        Curve { x: 0, y: 1 }\n    }\n\n    /// Return the Generator of the group\n    ///\n    /// Cost: 0 gates (assuming Params trait returns values known at compile time!)\n    fn one() -> Self {\n        let (x, y) = Params::gen();\n        Curve { x, y }\n    }\n\n    /// Validate a point is on the curve\n    ///\n    /// cheaper than `is_on_curve` (assert is cheaper than returning a bool)\n    ///\n    /// Cost: 3 gates\n    fn assert_is_on_curve(self) {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        assert(t2 == t3);\n    }\n\n    /// Constrain two points to equal each other\n    ///\n    /// Cheaper than `assert(self == other)` because no need to return a bool\n    ///\n    /// Cost: 0-2 gates (can do these asserts with just copy constraints)\n    fn assert_equal(self, other: Self) {\n        assert(self.x == other.x);\n        assert(self.y == other.y);\n    }\n\n    /// Return a bool that describes whether the point is on the curve\n    ///\n    /// If you don't need to handle the failure case, it is cheaper to call `assert_is_on_curve`\n    ///\n    /// Cost: 5 gates\n    fn is_on_curve(self) -> bool {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        (t2 == t3)\n    }\n\n    /// Compute `self + self`\n    ///\n    /// Cost: 5 gates\n    fn dbl(self) -> Self {\n        Curve::dbl_internal(self, Params::a(), Params::d())\n    }\n\n    /// Compute `self * scalar`\n    ///\n    /// Uses the Straus method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows:\n    ///      1: computing the Straus point lookup table (169 gates)\n    ///      2: 252 point doublings (1260 gates)\n    ///      3: 63 point additions (441 gates)\n    ///      4: 126 table reads with runtime index (252 gates)\n    ///\n    /// Cost: 2122 gates + cost of creating ScalarField (110 gates)\n    fn mul<let NScalarSlices: u32>(self: Self, scalar: ScalarField<NScalarSlices>) -> Self {\n        // define a, d params locally to make code more readable (shouldn't affect performance)\n        let a = Params::a();\n        let d = Params::d();\n\n        // Construct tables of precomputed point coordinates.\n        let (table_x, table_y): ([Field; 16], [Field; 16]) = self.compute_straus_point_table(a, d);\n\n        // Initialize the accumulator with the point that maps to the first (most significant) scalar slice\n        let idx = scalar.base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: table_x[idx], y: table_y[idx] };\n\n        // Execute a double-and-add subroutine\n        // 1. Compute `accumulator = accumulator * 16`\n        // 2. Extract 4-bits from the scalar multiplier and\n        //    use them to retrieve the corresponding point from our point table\n        // Note: this is similar to the \"double and add\" scalar multiplication method, except we use base16 instead of base2!\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            let idx = scalar.base4_slices[i] as u32;\n            let x = table_x[idx];\n            let y = table_y[idx];\n            accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n        }\n\n        // todo fix\n        if (scalar.skew) {\n            accumulator = accumulator - self;\n        }\n        accumulator\n    }\n\n    /// compute `points[0] * scalar[0] + ... + points[N-1] * scalar[N-1]`\n    ///\n    /// Is cheaper than `mul` when processing >1 point due to reduced number of point doublings\n    /// uses the Straus MSM method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows\n    /// PER POINT costs:\n    ///      1: computing the Straus point lookup table (169N gates)\n    ///      2: 63 point additions (441N gates)\n    ///      3: 126 table reads with runtime index (252N gates)\n    ///\n    /// Additional costs:\n    ///      1. 252 point doublings 1260 gates\n    ///\n    /// Cost: 1260 + 862N + cost of creating ScalarField (110N gates)\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self {\n        let a = Params::a();\n        let d = Params::d();\n\n        // Generalized version of `mul` for multiple points.\n        let mut point_tables: [([Field; 16], [Field; 16]); N] = [([0; 16], [0; 16]); N];\n        for j in 0..N {\n            point_tables[j] = points[j].compute_straus_point_table(a, d);\n        }\n\n        let idx = scalars[0].base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: point_tables[0].0[idx], y: point_tables[0].1[idx] };\n        for j in 1..N {\n            let idx = scalars[j].base4_slices[0] as u32;\n            let P = Curve { x: point_tables[j].0[idx], y: point_tables[j].1[idx] };\n            accumulator = accumulator.add_internal(P, a, d);\n        }\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            for j in 0..N {\n                let idx = scalars[j].base4_slices[i] as u32;\n                let x = point_tables[j].0[idx];\n                let y = point_tables[j].1[idx];\n                accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n            }\n        }\n\n        for j in 0..N {\n            if (scalars[j].skew == true) {\n                accumulator = accumulator - points[j];\n            }\n        }\n        accumulator\n    }\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### H E L P E R    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> Curve<Params> {\n\n    /// add two points together\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `add` :(\n    fn add_internal(self, other: Self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let x2 = other.x;\n        let y1 = self.y;\n        let y2 = other.y;\n        let (x, y, lambda) = unsafe { __add_unconstrained(x1, x2, y1, y2, a, d) };\n        let x1x2 = x1 * x2;\n        let x1y2 = x1 * y2;\n        std::as_witness(x1x2);\n        std::as_witness(x1y2);\n        let x_lhs = x * lambda * d + x - x1y2; // equals y1x2\n        let y_lhs = y * lambda * -d + y + x1x2 * a; // equals y1y2\n        let y1x2 = y1 * x2;\n        let y1y2 = y1 * y2;\n        std::as_witness(y1x2);\n        std::as_witness(y1y2);\n        let y1y2x1x2 = y1y2 * x1x2;\n        assert(x_lhs == y1x2);\n        assert(y_lhs == y1y2);\n        assert(y1y2x1x2 == lambda);\n        Self { x, y }\n    }\n\n    /// add a point to itself\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `dbl` :(\n    fn dbl_internal(self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let y1 = self.y;\n        let (x3, y3, _) = unsafe { __add_unconstrained(x1, x1, y1, y1, a, d) };\n        let x1x1a = x1 * x1 * a;\n        std::as_witness(x1x1a);\n        // t1 = a*x_1^2 + y_1^2\n        let t1 = y1 * y1 + x1x1a;\n        std::as_witness(t1);\n        // t3 = y_3 * (2 - a*x_1^2 + y_1^2) + 2*a*x_1^2\n        let t3 = y3 + y3 - t1 * y3 + x1x1a * 2;\n        // t3 == t1 implies y_3 * (2 - a*x_1^2 - y_1^2) + 2*a*x_1^2 == a*x_1^2 + y_1^2\n        // i.e. y_3 = y_1^2 - a*x_1^2 / (2 - a*x_1^2 - y_1^2)\n        assert(t3 == t1);\n        let t4 = x1 * y1;\n        std::as_witness(t4);\n        // x3 * t1 - t4 == t4 implies x_3 * (y_1^2 + a * x_1^2) = 2 * x_1 * y_1\n        // i.e. x_3 = 2 * x_1 * y_1 / (y_1^2 + a * x_1^2)\n        let t2 = x3 * t1 - t4;\n        assert(t2 == t4);\n        Self { x: x3, y: y3 }\n    }\n\n    /// Compute a 4-bit lookup table of point multiples for the Straus windowed scalar multiplication algorithm.\n    ///\n    /// Table contains [0, P, 2P, ..., 15P], which is used in the scalar mul algorithm to minimize the total number of required point additions\n    ///\n    /// It is cheaper to use ([Field; 16], [Field; 16]) than it is ([Curve; 16]).\n    /// This is because the compiler will represent [Curve; 16] in 1 ROM array (vs 2 for [Field; 16], [Field; 16]).\n    /// This means that any index into the ROM array for [Curve; 16] requires an additional arithmetic gate to process.\n    ///\n    ///      For example consider `let P: Curve = table[idx]`\n    ///      `table` will be a ROM array with 32 elements in it.\n    ///      The x-coordinates will be located at `2 * idx`\n    ///      The y-coordinates will be located at `2 * idx + 1`\n    ///      If `idx` is not known at compile time (for Straus it isnt), 2 arithmetic gates are required to evaluate `2 * idx`, `2 * idx + 1`\n    ///      before they can be used as arguments in a memory lookup protocol\n    ///\n    ///      Now consider `let P_x = table_x[idx]; let P_y = table_y[idx]`\n    ///      In this example, `idx` can be directly used as the argument into a memory lookup protocol for both tables.\n    ///\n    ///      For the Barretenberg backend, the cost of a Read-Only memory lookup is 2 gates,\n    ///      so splitting the x/y coordinates into separate tables means that the cost to lookup a point is 4 gates\n    ///      2 extra arithmetic gates would increase the cost by 50%, which we avoid by returning `([Field; 16], [Field; 16])` instead of `([Curve; 16])`\n    ///\n    /// Key cost components are as follows:\n    ///      1: Defining two size-16 lookup tables (2 gates per element, 32 elements = 64 gates)\n    ///      2: 15 point additions (7 * 5 = 105)\n    ///\n    /// Total Cost: 169 gates\n    fn compute_straus_point_table(self, a: Field, d: Field) -> ([Field; 16], [Field; 16]) {\n        let mut table_x: [Field; 16] = [0; 16];\n        let mut table_y: [Field; 16] = [0; 16];\n        table_x[8] = self.x;\n        table_y[8] = self.y;\n        let D = self.dbl_internal(a, d);\n        for i in 1..8 {\n            let Q = Self { x: table_x[7 + i], y: table_y[7 + i] };\n            let V = D.add_internal(Q, a, d);\n            table_x[8 + i] = V.x;\n            table_y[8 + i] = V.y;\n        }\n        for i in 0..8 {\n            table_x[i] = -table_x[15 - i];\n            table_y[i] = table_y[15 - i];\n        }\n        (table_x, table_y)\n    }\n}\n\n/// add points together, return output + lambda ter\nunconstrained fn __add_unconstrained(\n    x1: Field,\n    x2: Field,\n    y1: Field,\n    y2: Field,\n    a: Field,\n    d: Field,\n) -> (Field, Field, Field) {\n    let lambda = y1 * y2 * x1 * x2;\n    let y = (x1 * x2 * a - y1 * y2) / (lambda * d - 1);\n    let x = (x1 * y2 + y1 * x2) / (lambda * d + 1);\n    (x, y, lambda)\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/lib.nr"},"57":{"source":"use std::static_assert;\n\n/// ScalarField represents a scalar multiplier as a sequence of 4-bit slices\n///\n/// There is nuance to ScalarField, because twisted edwards curves generally have prime group orders that easily fit into a Field\n/// We can therefore obtain cheap conversions by simply summing up the bit slices and validate they equal the input scalar\n/// However...when converting arbitrary field elements (i.e. scalars that are multiples of a TE curve group order),\n/// we must perform additional checks when converting into 4-bit slices, as we must validate that the sum of the slices is smaller than the Field modulus (when evaluated over the integers)\n/// This is expensive and we would rather not do it! therefore ScalarField<N> is flexible.\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n///\n/// N.B. ScalarField bit values are not constrained to be smaller than the TE curve group order.\n/// ScalarField is used when performing scalar multiplications, where all operations wrap modulo the curve order\npub global TWO_POW_128: Field = 0x100000000000000000000000000000000;\npub global PLO: Field = 0x2833e84879b9709143e1f593f0000001;\npub global PHI: Field = 0x30644e72e131a029b85045b68181585d;\n\npub struct ScalarField<let N: u32> {\n    pub(crate) base4_slices: [u8; N],\n    pub(crate) skew: bool,\n}\n\nunconstrained fn get_wnaf_slices<let N: u32>(x: Field) -> ([u8; N], bool) {\n    let mut result: [u8; N] = [0; N];\n    let mut nibbles: [u8; N] = to_le_radix_16(x);\n\n    let skew: bool = nibbles[0] & 1 == 0;\n    nibbles[0] += skew as u8;\n    result[N - 1] = (nibbles[0] + 15) / 2;\n    for i in 1..N {\n        let mut nibble: u8 = nibbles[i];\n        result[N - 1 - i] = (nibble + 15) / 2;\n        if (nibble & 1 == 0) {\n            result[N - 1 - i] += 1;\n            result[N - i] -= 8;\n        }\n    }\n    (result, skew)\n}\n\nunconstrained fn from_wnaf_slices<let N: u32>(x: [u8; N], skew: bool) -> Field {\n    let mut result: Field = 0;\n\n    for i in 0..N {\n        result *= 16;\n        result += (x[i] as Field) * 2 - 15;\n    }\n    result -= skew as Field;\n    result\n}\n\nunconstrained fn get_borrow_flag(lhs_lo: Field, rhs_lo: Field) -> bool {\n    lhs_lo.lt(rhs_lo + 1)\n}\n\nunconstrained fn to_le_radix_16<let N: u32>(value: Field) -> [u8; N] {\n    // Round up on odd values of `N` to ensure space for last nibble.\n    let bytes = value.to_le_bytes::<(N + 1) / 2>();\n    let mut result: [u8; N] = [0; N];\n    for index in 0..(N / 2) {\n        result[index * 2] = bytes[index] & 0x0F; // Extract low nibble (bits 0-3)\n        result[index * 2 + 1] = (bytes[index] >> 4); // Extract high nibble (bits 4-7)\n    }\n    if (N & 1) == 1 {\n        let last_nibble = bytes[bytes.len() - 1];\n        // The last byte must have the top 4 bits empty.\n        (last_nibble as Field).assert_max_bit_size::<4>();\n        result[N - 1] = last_nibble;\n    }\n    result\n}\n\nimpl<let N: u32> std::convert::From<Field> for ScalarField<N> {\n\n    /// Construct from a field element\n    ///\n    /// if N >= 64 we perform extra checks to ensure the slice decomposition represents the same integral value as the input\n    /// (e.g. sum of slices != x + modulus)\n    fn from(x: Field) -> Self {\n        // the field elements have 254 bits max, so we do not need to support N > 64\n        static_assert(N <= 64, \"N must be at most 64\");\n        let mut result: Self = ScalarField { base4_slices: [0; N], skew: false };\n        let (slices, skew): ([u8; N], bool) = unsafe { get_wnaf_slices(x) };\n        result.base4_slices = slices;\n        result.skew = skew;\n        if (N < 64) {\n            let mut acc: Field = (slices[0] as Field) * 2 - 15;\n            for i in 1..N {\n                acc *= 16;\n                acc += (slices[i] as Field) * 2 - 15;\n            }\n            assert(acc - skew as Field == x);\n        } else {\n            // TODO: if num bits = 64, validate in sum of the bits is smaller than the Field modulus\n            let mut lo: Field = 0;\n            let mut hi: Field = 0;\n\n            for i in 0..32 {\n                lo *= 16;\n                lo += (slices[32 + i] as Field) * 2 - 15;\n                hi *= 16;\n                hi += (slices[i] as Field) * 2 - 15;\n            }\n\n            lo -= skew as Field;\n            // Validate that the integer represented by (lo, hi) is smaller than the integer represented by (plo, phi)\n\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            // Safety: we assert that the absolute value has less than 128 bits\n            let is_positive: bool = unsafe { get_borrow_flag(lo, TWO_POW_128) };\n\n            let abs_lo = (is_positive as Field) * lo + (1 - is_positive as Field) * (-lo);\n\n            abs_lo.assert_max_bit_size::<128>();\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            let borrow = unsafe { get_borrow_flag(PLO, abs_lo) as Field };\n            // we only need to check the rlo has 128 bits or less if lo is positive. if negative, the lo is already less than PLO\n            let rlo = is_positive as Field * (PLO - lo + borrow * TWO_POW_128 - 1)\n                + (1 - is_positive as Field) * (-lo); // -1 because we are checking a strict <, not <=\n            // is lo is positive, we need to check the hi is less than phi with the borrow flag subtracted\n            // if lo is negative, we have to check that hi * 2^128 < phi * 2^128 + abs_lo + plo\n            // to do this we first make a flag to check that abs_lo + plo is larger than 2^128 or not\n            // if they are larger, we check that hi < phi + 1 and otherwise we check that hi < phi\n            // Safety: we assert the when the flag is positive we have less than 128 bits\n            let threshold_flag: bool = unsafe { get_borrow_flag(abs_lo + PLO, TWO_POW_128) };\n            (threshold_flag as Field * (abs_lo + PLO)).assert_max_bit_size::<128>();\n            let rhi = is_positive as Field * (PHI - hi - borrow)\n                + (1 - is_positive as Field) * (PHI - hi + threshold_flag as Field);\n            // the rlo value would have 128 bits or less if positive and more if negative as the modulus is 254 bits\n            rlo.assert_max_bit_size::<128>();\n            rhi.assert_max_bit_size::<128>();\n        }\n        for i in 0..N {\n            (result.base4_slices[i] as Field).assert_max_bit_size::<4>();\n        }\n        result\n    }\n}\n\nimpl<let N: u32> std::convert::Into<Field> for ScalarField<N> {\n\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    fn into(self: Self) -> Field {\n        let mut acc: Field = 0;\n        for i in 0..N {\n            acc = acc * 16;\n            acc = acc + (self.base4_slices[i] as Field) * 2 - 15;\n        }\n        acc -= self.skew as Field;\n        acc\n    }\n}\n\nimpl<let N: u32> ScalarField<N> {\n\n    pub fn new() -> Self {\n        Self { base4_slices: [0; N], skew: false }\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.base4_slices[idx]\n    }\n}\n\n#[test]\nunconstrained fn test_wnaf() {\n    let result: Field = 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0;\n    let (t0, t1) = get_wnaf_slices::<64>(result);\n    let expected = from_wnaf_slices(t0, t1);\n    assert_eq(result, expected);\n}\n\n#[test]\nfn test_regression_wnaf() {\n    let a = 0x7b;\n    let s: ScalarField<64> = ScalarField::<64>::from(a);\n    let b: Field = ScalarField::<64>::into(s);\n    assert_eq(a, b);\n}\n\n#[test]\nunconstrained fn to_le_radix_16_works_with_odd_N() {\n    let input = 0x0f00;\n    let nibbles: [u8; 3] = to_le_radix_16(input);\n    assert_eq(nibbles, [0x0, 0x0, 0xf]);\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/scalar_field.nr"},"65":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"67":{"source":"use common::{ecdh::{derive_public_key, derive_shared_key}, utils::poseidon2_hash};\n\nfn main(buyer_pub: pub [Field; 2], seller_pub: [Field; 2], buyer_priv: Field) -> pub Field {\n    assert(buyer_pub == derive_public_key(buyer_priv));\n    // return poseidon hash of shared key\n    poseidon2_hash([derive_shared_key(buyer_priv, seller_pub)])\n}\n\n#[test]\nfn test_main() {}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/ask/src/main.nr"}}};

export async function ask(buyer_pub: Field[], seller_pub: Field[], buyer_priv: Field, foreignCallHandler?: ForeignCallHandler): Promise<Field> {
  const program = new Noir(ask_circuit);
  const args: InputMap = { buyer_pub, seller_pub, buyer_priv };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field;
}
export type decrypt_packetInputType = {
  ciphers: Field[];
  key: Field[];
  nonce: Field;
}

export type decrypt_packetReturnType = Field[];
export const decrypt_packet_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"ciphers","type":{"kind":"array","length":511,"type":{"kind":"field"}},"visibility":"private"},{"name":"key","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":510,"type":{"kind":"field"}},"visibility":"private"},"error_types":{"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZrdTiM5EIXfpa9z4SqX/3iVERoFyIwiRQFlYKQV4t3XTlwnzK7aGHu4oYpO/B13u45jx3ldHnZ3Lz+/748/Hn8tN99el7vT/nDY//x+eLzfPu8fj/nq62LKH/LLDb1tFtJ/fM7DJcTlJuSQlpu4WTi/PeY3sr6RLy/JW76o3O/Pp92uvOGdUJZ/2p52x+fl5vhyOGyW39vDy/lNv562x3N83p7yq2az7I4POWbgj/1hV7K3zbW1WW9KZIRr85x7BwTFXkZMthJiStf2obd9sr62Ty6stbdffA9GCZH9Wh/censvUtt7Z0faR9L2MQ611yIIxg6MgTc6hl6uZeT4j/ZpvT0brx3I6fUO3J+VSI0uBBf0GQSXZG0QidYR1sZUEdam1VoibiAMB0UYa4cQ5KIiKKQxRAKCab0XjYpgz/o42TduxDeMlawiKEkcQbAx17rg9V7EdYQLKE0yq1XR7IP4a22ujgebr+wDeS0rpihDj5I8TSNQmcMIhsXY8mpNcKMyyeJpkk00hBDCjC/8FxBuDMEJCJFBRATCpekbGUWE643EOItwZgzh6IoQXl0JyKRP232AybJXVofU+tm5ojlzO8wVfn2+snHapTZN10QT0TegQpMPs92HrgEV+5UDGqzT0Qh+9VHK/Jwp8xOezE94Mj/hyfyEJ/MTnsxPeDI/4bnZ2pT5Cc+5WX+0VrscBKvduDqgZVacXO26OL1UdWnySbj5edvTdGk3EX116Wfrst2Hrrr0s3XZLqquD2IfprdQLURnXfrZumz3oWsLFegr+9C3hfoAQdOIri1UE9Fn8uCnlwNNRN8Wqh/hxhBdK4oPED0riu4bGUV0Tbu9iMaKoonom7nj7KzZ7kPXzB3DV87cfSvumKYt1kT0Wawf4cYQXRb7ANFjse4bGUV0WawX0bBYnN/UptlvNOP8ppbM7Feand/4k3Fr3/i3CGQZhGRGCIy6ZLYyRMDhE/O70fwEQVg3LyzejhAcipJdGiMk3IU3MtmHQYInjIV/d4b2mT54i+cQhggeG0kONPQkk8FzeL9e/wzhusZMgYYIAR9eKdrZPvyHcJv/297vT/870iZ7PswugS/Blglzs0iZWDaLK1uYzeIvIVxCLN7dLOkSyBQT5EhlLHLkGjOpfCCT1JhZtpyQ+xozrRzhloNz0eNxuRydn2PmlQ0Ic42Z58p1qTHzXLnuayzn8OV6rDHzfL5uTY1UI9doywlqjlLOT3N0NWZeyP2xocZysJ/7bzMv5H6LqTHzYuYI15h5MfNEasy8lHnia8y8lJ+exBpTmazzA3RGkzIS5UzasSZWkzIeJqs4p4nXJGgSNUk18UYT0oQ1sZoo2SvZK9kr2SvZKzkoOSg5KDkoOSg5KDkoOSg5KDkoOSo5KjkqOSo5KjkqOSo5KjkqOSo5KTkpOSk5KTkpOSk5KTkpOSk5KTl/5iIjZIzMIhNkDplHFpBFZNAgaBA0CBoEDYIGQYOgQdAgaBA0GBoMDYYGQ4OhwdBgaDA0GBoMDQsNCw0LDQsNCw0LDQsNCw0LDQsNgYZAQ6Ah0BBoCDQEGgINgYZAw0HDQcNBw0ED1iV4l2BegnsJ9iX4l2BggoMJFiZ4mGBigosJNib4mGBkgpMJViZ4mWBmgpsJdib4mWBogqMJliZ4mmBqgqsJtib4mmBsgrMJ1iZ4m2BugrsJ9ib4m2BwgsMJFid4nGBygssJNif4nOFzhs8ZPmf4nOFzhs8ZPmf4nOFzhs8ZPmf4nOFzhs8ZPmf4nOFzhs8ZPmf4nOFzhs8ZPmf4nOFzhs/57POyr+Ozz89Lh7PPqazefm9P++3dYVcWGGUJ8nK81/VG/vf5nyd9RX9k93R6vN89vJx2ZW3y7pd2+e+3vNhgucXv7cqlvNLgdItf1p0vhY3l27eyyvkX","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use super::utils::poseidon2_hash;\nuse poseidon::poseidon2_permutation;\n\n#[field(bn254)]\nfn compute_pad(key: Field, nonce: Field, counter: u32) -> Field {\n    poseidon2_hash([key, nonce, counter as Field])\n}\n\n#[field(bn254)]\npub fn encrypt_single(plains: Field, key: Field, nonce: Field, counter: u32) -> Field {\n    plains + compute_pad(key, nonce, counter)\n}\n\n#[field(bn254)]\npub fn decrypt_single(ciphers: Field, key: Field, nonce: Field, counter: u32) -> Field {\n    ciphers - compute_pad(key, nonce, counter)\n}\n\n#[field(bn254)]\npub fn encrypt<let N: u32>(plains: [Field; N], key: Field, nonce: Field) -> [Field; N] {\n    plains.mapi(|i, p| encrypt_single(p, key, nonce, i))\n}\n\n#[field(bn254)]\npub fn decrypt<let N: u32>(ciphers: [Field; N], key: Field, nonce: Field) -> [Field; N] {\n    ciphers.mapi(|i, c| decrypt_single(c, key, nonce, i))\n}\n\n#[field(bn254)]\npub fn poseidon_encrypt<let N: u32>(\n    plains: [Field; N],\n    key: [Field; 2],\n    nonce: Field,\n) -> [Field; N + 1] {\n    assert(nonce.lt(0x100000000000000000000000000000000));\n\n    let padded_nonce = nonce + (N as Field) * 0x100000000000000000000000000000000;\n    let mut state: [Field; 4] = [0, key[0], key[1], padded_nonce];\n\n    let state_len = state.len();\n    assert(N >= state_len - 1);\n\n    let mut ciphers: [Field; N + 1] = [0; N + 1];\n\n    for i in 0..(N / (state_len - 1)) {\n        state = poseidon2_permutation(state, state_len);\n\n        for j in 1..state_len {\n            let index = i * (state_len - 1) + j - 1;\n            state[j] += plains[index];\n            ciphers[index] = state[j];\n        }\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    for i in (N - (N % (state_len - 1)))..N {\n        let index = (i % (state_len - 1)) + 1;\n        state[index] += plains[i];\n        ciphers[i] = state[index];\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    ciphers[N] = state[1];\n    ciphers\n}\n\n#[field(bn254)]\npub fn poseidon_decrypt<let N: u32>(\n    ciphers: [Field; N + 1],\n    key: [Field; 2],\n    nonce: Field,\n) -> [Field; N] {\n    assert(nonce.lt(0x100000000000000000000000000000000));\n\n    let padded_nonce = nonce + (N as Field) * 0x100000000000000000000000000000000;\n    let mut state: [Field; 4] = [0, key[0], key[1], padded_nonce];\n\n    let state_len = state.len();\n    assert(N >= state_len - 1);\n\n    let mut plains: [Field; N] = [0; N];\n\n    for i in 0..(N / (state_len - 1)) {\n        state = poseidon2_permutation(state, state_len);\n\n        for j in 1..state_len {\n            let index = i * (state_len - 1) + j - 1;\n            plains[index] = ciphers[index] - state[j];\n            state[j] = ciphers[index];\n        }\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    for i in (N - (N % (state_len - 1)))..N {\n        let index = (i % (state_len - 1)) + 1;\n        plains[i] = ciphers[i] - state[index];\n        state[index] = ciphers[i];\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    assert(ciphers[N] == state[1]);\n    plains\n}\n\n#[test]\nfn test_e2e() {\n    let key = 0x1ff18c97cd54b27391280a1f24cc94ef8c05e421525eb05bd4ded690735bf961;\n    let nonce = 1337;\n\n    let msg = [22405534230753963835153736737; 256]; // \"Hello world!\"\n    let encrypted = encrypt(msg, key, nonce);\n    let new_msg = decrypt(encrypted, key, nonce);\n\n    assert(msg == new_msg);\n\n    println(f\"Key: {key}\");\n    println(f\"nonce: {nonce}\");\n\n    println(f\"Original: {msg}\");\n    println(f\"Encrypted: {encrypted}\");\n    println(f\"Decrypted: {new_msg}\");\n}\n\n#[test]\nfn test_e2e_poseidon() {\n    let key: [Field; 2] = [\n        0x1ff18c97cd54b27391280a1f24cc94ef8c05e421525eb05bd4ded690735bf961,\n        0x1ff18c97cd54b27391280a1f24cc94ef8c05e421525eb05bd4ded690735bf961,\n    ];\n    let nonce = 1337;\n\n    let msg = [22405534230753963835153736737; 1024]; // \"Hello world!\"\n    let encrypted = poseidon_encrypt(msg, key, nonce);\n    let new_msg = poseidon_decrypt(encrypted, key, nonce);\n\n    assert(msg == new_msg);\n\n    println(f\"Key: {key}\");\n    println(f\"nonce: {nonce}\");\n\n    println(f\"Original: {msg}\");\n    println(f\"Encrypted: {encrypted}\");\n    println(f\"Decrypted: {new_msg}\");\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/cipher.nr"},"52":{"source":"use super::cipher::poseidon_decrypt;\n\n#[export]\npub fn get_key_commitment(key: [Field; 2], salt: Field) -> Field {\n    super::utils::commit(key, salt)\n}\n\n// #[export]\n// fn encrypt_key(master_key: Field, key: Field, nonce: Field) -> Field {\n//     super::cipher::encrypt_single(master_key, key, nonce, 0)\n// }\n\n// #[export]\n// fn decrypt_key(enc_master_key: Field, key: Field, nonce: Field) -> Field {\n//     super::cipher::decrypt_single(enc_master_key, key, nonce, 0)\n// }\n\n#[export]\npub fn decrypt_packet(\n    ciphers: [Field; 510 + 1],\n    key: [Field; 2],\n    nonce: Field,\n) -> [Field; 510] {\n    poseidon_decrypt(ciphers, key, nonce)\n}\n\n#[export]\nfn derive_public_key(private_key: Field) -> [Field; 2] {\n    super::ecdh::derive_public_key(private_key)\n}\n\n#[export]\nfn derive_shared_key(private_key: Field, public_key_packed: [Field; 2]) -> Field {\n    super::ecdh::derive_shared_key(private_key, public_key_packed)\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/exports.nr"}}};

export async function decrypt_packet(ciphers: Field[], key: Field[], nonce: Field, foreignCallHandler?: ForeignCallHandler): Promise<Field[]> {
  const program = new Noir(decrypt_packet_circuit);
  const args: InputMap = { ciphers, key, nonce };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field[];
}
export type derive_public_keyInputType = {
  private_key: Field;
}

export type derive_public_keyReturnType = Field[];
export const derive_public_key_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"private_key","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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u69XeF9fpPev+L5e+X29Avx6Jfj1ivDrleHXK8SvpGlFC9v1yha26x0uPEfStOOF7fokTTtg2K5P0rQjhu36JE0rZHi6vkjTuUjTuUjTChqeri/StKOG7foiTTts2K4v0rTjhu36Jk07cNiub9K0I4ft+iZNO3TYrm/StGOH52UTpOk00nQaaTqNNJ1Gmlb48HTdSNOOH54jadoBxHbdSNOOILbrTpp2CLFdd9K0Yoin606aTidNp5OmFUU8XXfStMOI7XqQph1HbNeDNO1AYrsepGlHEtv1IE07lNiuB2nascR2PUnTDia260maVjTxdD1J05mk6UzStOKJp+tJmnZA8RxJ044o9mUrgzTtkGJfuDJI044p9qUrgzStoGK7XknFdn0JabqENK2wYrteacV2veOK5XrnFcv1DiyW651YLNc7sliud2axXO/QYrneqcVyvWOL5XrnFsv1Di6W651cLNc7upj9a6RphRfb9aWk6Zqk6ZqkaQUYzwuFJmnaEcZzJE07xNiuT9K0Y4zt+iRNO8h4/gvwpGlFGU/XF2m6Fmm6FmlaccbT9UWadqCxXV+kaUca2/VNmnaosV3fpGnHGtv1TZp2sLFd36RpRxvb9U2adrixXTfStOKNp+tGmi4jTZeRphVxPF030rRDjudImnbMsV130rSDjudFWqRpRx3bdSdNK+x4uu6k6XLSdDlpWoHH0/UgTTvy2K4Hadqhx3Y9SNOOPbbrQZp28LFdD9K0o4/tepKmHX5s15M07fhju56kaQUgT9eTNF1Jmq4kTSsE2a5XCrJd7xjkOZKmHYQs1zsJWa53FLJc7yxkud5hyNm6pGnFIXF5HGm6hTTdQppWJPK8RE5I0w5F9kVyQpp2LLIvkxPStIOR5XonI8v1jkaW652NLNc7HBl9uR5p2vHIcr3zkdlipGklJNv1iki263uSpnuSpnuSphWTPF2fpGkHJc+RNO2oZLs+SdMOS7brizTtuGS7vkjTCkyeri/SdC/SdC/StEKTp+uLNO3YZLu+SdMOTrbrmzTt6GS7vknTDk+265s07fhku75J0w5QtutGmnaEsl030rRClKfrRppuI023kaYVpDxdN9K0o5TnSJp2mLJdd9K045TtupOmHahs1500rUjl6bqTpjtI0x2kacUqT9eDNO1gZbsepGlHK9v1IE07XNmuB2na8cp2PUnTDli260madsSyXU/StEOW7XqSphWzPF1P0tQGaWqDNK2oZbteWct2vcOW50iadtxSW4E07cBlud6Jy9nXvpKmJqRphS7b9UpdtusmpKkJaVrBy3a9kpftekcvy/XOXpbrHb4s1zt92VfiKmna+cvzWlzStBOYfTWukqadwezrcZU07RRmX5E7SdPKYbbrFcRs122SpjZJU5ukaYUxT9cnadpxzHMkTTuQ2a4v0rQjme36Ik07lNmuL9K0Ypmn64s0tUWa2iJNK5p5ur5J0w5ntuubNO14Zru+SdMOaLbrmzTtiGa7vknTDmm260aadkyzXTfStIOa7bqRphXVPF030tSMNDUjTSuuebrupGkHNs+RNO3IZrvupGmHNtt1J007ttmuO2lawc3T9SBNLUhTC9K0wpun60GadnyzXQ/StAOc7XqQph3hbNeTNO0QZ7uepGnHONv1JE07yNmuJ2naUc7z8nPStMKc5wXogzT1QZr6IE0r0HlehD5I0450niNp2qHOvhB9kKYd6yzXO9dZrnews1x3IU0r2tmuu5CmLqSpC2nqQpq6kKYd8CzXO+FZrnfEs1zvjGe53iHPcr1Tnt4/S5p2zrNc76Bn9E2Qph31LNc761mud9izXK+05+n6JE19kqY+SVOfpKlP0tQnadqhz3MkTTv22a4v0rSDn+36Ik07+tmuL9K0wp+n64s09U2a+iZNfZOmvknTjoC265s07RBou75J046BtuubNO0gaLtupGlHQdt1I007DNquG2nacdB23UjTCoSerhtp6k6aupOm7qSpO2nasdBzJE07GNquO2na0dB23UnTDoe260GaVjz0dD1IUw/S1IM09SBNPUjTDom260Gadky0XU/StIOi7XqSph0VbdeTNO2waLuepGnHRdv1JE07MFquV2K0Xa/IaLsegzSNQZrGIE1jkKYxSNO4ClniamSJq5Ilrk6WuEpZ4mpliauWJa5elriKWeJqZomrmiWubpa4ylniameJq54lrn6WuApa4mpoiauiJa6OlrhKWuJqaYmrpiWunpa4ilriamqJq6olrq6WuMpa4mpriauuJa6+lrgKW+JqbImrsiWuzpa4Slviam2Jq7Ylrt6WuIpb4mpuiau6Ja7ulrjKW+Jqb4mrviWu/pa4ClzianCJq8Ilrg6XuEpc4mpxiavGJa4el7iKXOJqcomryiWuLpe4ylzianOJq84lrj6XuApd4mp0iavSJa5Ol7hKXeJqdYmr1iVe9Lq8KHZ50ezyotrlRbfLi3KXF+0uL+pdXva7kKZxNbzEVfESV8dLXCUvcbW8xFXzElfPS1xFL3E1vcRV9RLsepFk2Ysk214kWfciyb4XSRa+SLLxRZKVL5LsfJFk6YskW18kWfsiyd4XSRa/SLL5RZLVL5LsfpFk+Ysk218kWf8iyf4XSRbASLIBRpIVMJLsgJFkCYwkW2AkWQMjyR4YSRbBSLIJRpJVMJLsgpFkGYwk22AkWQcjyT4YSRbCSLIRRpKVMJLshJFkKYwkW2EkWQsjyV4YSRbDSLIZRpLVMJLshpFkOYwk22EkWQ8jyX4YSRbESLIhRpIVMZLsiJFkSYwkW2IkWRMjyZ4YSRbFSLIpRpJVMZLsipFkWYwk22IkWRcjyb4YSRbGSLIxRpKVMZLsjJFkaYwkW2MkWRsjyd4YSRbHSLI5RpLVMZLsjpFkeYwk22MkWR8jyf4YSRbISLJBRpIVMpLskJFkiYwkW2QkWSMjyR4ZSRbJSLJJRpJVMpLskpFkmYwk22QkWScjyT4ZHSyU0cFGGR2slNHBThkdLJXRwVYZHayV0cFeGR0sltHBZhkdrJbRwW4ZHSyX0cF2GR2sl9HBfhkdLJjRwYYZHayY0cGOGR0smdHBlhkdrJnRwZ4ZHSya0cGmGR2smtHBrhkdLJvRwbYZHayb0cG+GR0snNHBxhkdrJzRwc4ZHSyd0cHWGR2sndHB3hkdLJ7RweYZHaye0cHuGR0sn9HB9hkdrJ/Rwf4ZHSyg0cEGGh2soNHBDhodLKHRwRYaHayh0cEeGh0sotHBJhodrKLRwS4aHSyj0cE2Gh2so9HBPhodLKTRwUYaHayk0cFOGh0spdHBVhodrKXRwV4aHSym0cFmGh2sptHBbhodLKfRwXYaHayn0cF+Gh0sqNHBhhodrKjRwY4aHSyp0cGWGh2sqdHBnhodLKrRwaYaHayq0cGuGh0sq9HBthodrKvRwb4aHSys0cHGGh2srNHBzhoVltaosLVGhbU1KuytUWFxjQqba1RYXaPC7hoVlteosL1GhfU1KuyvUWGBjQobbFRYYaPCDhsVltiosMVGhTU2KuyxUWGRjQqbbFRYZaPCLhsVltmosM1GhXU2KuyzUWGhjQobbVRYaaPCThsVltqosNVGhbU2Kuy1UWGxjQqbbVRYbaPCbhsVltuosN1GhfU2Kuy3UWHBjQobblRYcaPCjhsVltyosOVGhTU3Kuy5UWHRjQqbblRYdaPCrhsVlt2osO1GhXU3Kuy7UWHhjQobb1RYeaPCzhsVlt6osPVGhbU3Kuy9UWHxjQqbb1RYfaPC7hsVlt+osP1GhfU3Kuy/UWEBjgobcFRYgaPCDhwVluCosAVHhTU4KuzBUWERjgqbcFRYhaPCLhwVluGosA1HhXU4KuzDUWEhjgobcVRYiaPCThwVluKosBVHhbU4KuzFUWUxjiqbcVRZjaPKbhxVluOosh1HlfU4quzHUWVBjiobclRZkaPKjhxVluSosiVHlTU5quzJUWVRjiqbclRZlaPKrhxVluWosi1HlXU5quzLUWVhjiobc1RZmaPKzhxVluaosjVHlbU5quzNUWVxjiqbc1RZnaPK7hxVlueosj1HlfU5quzPUWWBjiobdFRZoaPKDh1VluioskVHlTU6quzRUWWRjiqbdLRyr9pW17V6bXVdrKd1w3U9Tpta1+PM/rXj1trfytCf43Frq8XiGo9bW3XfKqtW/+rSf3//y4/f/+mnH/7x7Xf/OkrPf/35z2g4f/zvP//n7/ibP/3y408//fjXP/79l7/9+Ye//PrLD0cb+j/OIvT6z+/V8jvN8YfvjlL03z/u83dq+w9Viv77x4P33ePsjr+rH32c0sOf43/rZ/PxvzmPonU51PpnHn9mxx8p/+jxW49f+vdRyf6/","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"51":{"source":"use noir_edwards::{ScalarField, bjj::BabyJubJub, Curve, CurveTrait};\nuse super::utils::poseidon2_hash;\n\n// [8]G precalculated\nglobal BASE8_POINT: [Field; 2] = [\n    5299619240641551281634865583518297030282874472190772894086521144482721001553,\n    16950150798460657717958625567821834550301663161624707787222815936182638968203,\n];\n\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n\n#[field(bn254)]\npub fn derive_public_key(private_key: Field) -> [Field; 2] {\n    let private_scalar: ScalarField<64> = ScalarField::from(private_key);\n    let base8_point: BabyJubJub = Curve::new(BASE8_POINT[0], BASE8_POINT[1]);\n    let point = base8_point.mul(private_scalar);\n    [point.x, point.y]\n}\n\n#[field(bn254)]\npub fn derive_shared_key(private_key: Field, public_key_packed: [Field; 2]) -> Field {\n    let private_scalar: ScalarField<64> = ScalarField::from(private_key);\n    let point: BabyJubJub = Curve::new(public_key_packed[0], public_key_packed[1]);\n    let shared_key = point.mul(private_scalar);\n    shared_key.x\n}\n\n#[test]\nfn test_e2e() {\n    let a_key = poseidon2_hash([0]);\n    let a_pubkey = derive_public_key(a_key);\n\n    let b_key = poseidon2_hash([1]);\n    let b_pubkey = derive_public_key(b_key);\n\n    let key_1 = derive_shared_key(a_key, b_pubkey);\n    let key_2 = derive_shared_key(b_key, a_pubkey);\n\n    assert(key_1 == key_2);\n\n    println(f\"Alice public key: {a_pubkey}\");\n    println(f\"Alice private key: {a_key}\");\n    println(\"\");\n    println(f\"Bob public key: {b_pubkey}\");\n    println(\"\");\n    println(f\"Shared Key 1: {key_1}\");\n    println(f\"Shared Key 2: {key_2}\");\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/ecdh.nr"},"52":{"source":"use super::cipher::poseidon_decrypt;\n\n#[export]\npub fn get_key_commitment(key: [Field; 2], salt: Field) -> Field {\n    super::utils::commit(key, salt)\n}\n\n// #[export]\n// fn encrypt_key(master_key: Field, key: Field, nonce: Field) -> Field {\n//     super::cipher::encrypt_single(master_key, key, nonce, 0)\n// }\n\n// #[export]\n// fn decrypt_key(enc_master_key: Field, key: Field, nonce: Field) -> Field {\n//     super::cipher::decrypt_single(enc_master_key, key, nonce, 0)\n// }\n\n#[export]\npub fn decrypt_packet(\n    ciphers: [Field; 510 + 1],\n    key: [Field; 2],\n    nonce: Field,\n) -> [Field; 510] {\n    poseidon_decrypt(ciphers, key, nonce)\n}\n\n#[export]\nfn derive_public_key(private_key: Field) -> [Field; 2] {\n    super::ecdh::derive_public_key(private_key)\n}\n\n#[export]\nfn derive_shared_key(private_key: Field, public_key_packed: [Field; 2]) -> Field {\n    super::ecdh::derive_shared_key(private_key, public_key_packed)\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/exports.nr"},"56":{"source":"mod scalar_field;\nmod test;\npub mod bjj;\n\npub use crate::scalar_field::ScalarField;\nuse std::ops::{Add, Neg, Sub};\n\npub struct Curve<Params> {\n    pub x: Field,\n    pub y: Field,\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### T R A I T S\n// ####################################################################################################################\n// ####################################################################################################################\n\n/// Parametrises a Twisted Edwards curve\ntrait TECurveParameterTrait {\n    fn a() -> Field; // twisted edward curve parameter a\n    fn d() -> Field; // twisted edward curve parameter d\n    fn gen() -> (Field, Field); // generator point x/y coordinates\n}\n\n/// Defines methods that a valid Curve implementation must satisfy\npub trait CurveTrait<Params>: Add + Sub + Eq + Neg + Default {\n    fn new(x: Field, y: Field) -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn dbl(self) -> Self;\n    fn mul<let NScalarSlices: u32>(self, x: ScalarField<NScalarSlices>) -> Self;\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self;\n\n    fn eq(self, x: Self) -> bool {\n        self == x\n    }\n    fn is_zero(self) -> bool {\n        self == Self::zero()\n    }\n\n    fn is_on_curve(self) -> bool;\n    fn assert_is_on_curve(self);\n    fn assert_equal(self, other: Self);\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### C O N S T R A I N E D    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> std::default::Default for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Returns point at infinity\n    ///\n    /// Cost: 0 gates\n    fn default() -> Self {\n        Curve::zero()\n    }\n}\n\nimpl<Params> std::ops::Add for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self + other`\n    ///\n    /// Cost: 7 gates\n    fn add(self, other: Self) -> Self {\n        Curve::add_internal(self, other, Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::ops::Neg for Curve<Params> {\n    /// Negate a point\n    ///\n    /// Cost: usually 0, will cost 1 gate if the `x` coordinate needs to be converted into a witness\n    fn neg(self) -> Self {\n        Curve { x: -self.x, y: self.y }\n    }\n}\n\nimpl<Params> std::ops::Sub for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self - other`\n    ///\n    /// Cost: 7 gates\n    fn sub(self, other: Self) -> Self {\n        Curve::add_internal(self, other.neg(), Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::cmp::Eq for Curve<Params> {\n    /// Compute `self == other`\n    ///\n    /// Cost: 6 gates\n    fn eq(self, other: Self) -> bool {\n        (self.x == other.x) & (self.y == other.y)\n    }\n}\n\nimpl<Params> std::convert::From<(Field, Field)> for Curve<Params> {\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    ///\n    /// Cost: 0 gates\n    fn from((x, y): (Field, Field)) -> Self {\n        Curve { x, y }\n    }\n}\n\nimpl<Params> CurveTrait<Params> for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n\n    /// Construct a new point\n    ///\n    /// If you know the x/y coords form a valid point DO NOT USE THIS METHOD\n    /// This method calls `assert_is_on_curve` which costs 3 gates.\n    /// Instead, directly construct via Curve{x, y} or use from((x, y))\n    ///\n    /// Cost: 3 gates\n    fn new(x: Field, y: Field) -> Self {\n        let result = Curve { x, y };\n        result.assert_is_on_curve();\n        result\n    }\n\n    /// Return the Identity element (point at infinity)\n    ///\n    /// Cost: 0 gates\n    fn zero() -> Self {\n        Curve { x: 0, y: 1 }\n    }\n\n    /// Return the Generator of the group\n    ///\n    /// Cost: 0 gates (assuming Params trait returns values known at compile time!)\n    fn one() -> Self {\n        let (x, y) = Params::gen();\n        Curve { x, y }\n    }\n\n    /// Validate a point is on the curve\n    ///\n    /// cheaper than `is_on_curve` (assert is cheaper than returning a bool)\n    ///\n    /// Cost: 3 gates\n    fn assert_is_on_curve(self) {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        assert(t2 == t3);\n    }\n\n    /// Constrain two points to equal each other\n    ///\n    /// Cheaper than `assert(self == other)` because no need to return a bool\n    ///\n    /// Cost: 0-2 gates (can do these asserts with just copy constraints)\n    fn assert_equal(self, other: Self) {\n        assert(self.x == other.x);\n        assert(self.y == other.y);\n    }\n\n    /// Return a bool that describes whether the point is on the curve\n    ///\n    /// If you don't need to handle the failure case, it is cheaper to call `assert_is_on_curve`\n    ///\n    /// Cost: 5 gates\n    fn is_on_curve(self) -> bool {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        (t2 == t3)\n    }\n\n    /// Compute `self + self`\n    ///\n    /// Cost: 5 gates\n    fn dbl(self) -> Self {\n        Curve::dbl_internal(self, Params::a(), Params::d())\n    }\n\n    /// Compute `self * scalar`\n    ///\n    /// Uses the Straus method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows:\n    ///      1: computing the Straus point lookup table (169 gates)\n    ///      2: 252 point doublings (1260 gates)\n    ///      3: 63 point additions (441 gates)\n    ///      4: 126 table reads with runtime index (252 gates)\n    ///\n    /// Cost: 2122 gates + cost of creating ScalarField (110 gates)\n    fn mul<let NScalarSlices: u32>(self: Self, scalar: ScalarField<NScalarSlices>) -> Self {\n        // define a, d params locally to make code more readable (shouldn't affect performance)\n        let a = Params::a();\n        let d = Params::d();\n\n        // Construct tables of precomputed point coordinates.\n        let (table_x, table_y): ([Field; 16], [Field; 16]) = self.compute_straus_point_table(a, d);\n\n        // Initialize the accumulator with the point that maps to the first (most significant) scalar slice\n        let idx = scalar.base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: table_x[idx], y: table_y[idx] };\n\n        // Execute a double-and-add subroutine\n        // 1. Compute `accumulator = accumulator * 16`\n        // 2. Extract 4-bits from the scalar multiplier and\n        //    use them to retrieve the corresponding point from our point table\n        // Note: this is similar to the \"double and add\" scalar multiplication method, except we use base16 instead of base2!\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            let idx = scalar.base4_slices[i] as u32;\n            let x = table_x[idx];\n            let y = table_y[idx];\n            accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n        }\n\n        // todo fix\n        if (scalar.skew) {\n            accumulator = accumulator - self;\n        }\n        accumulator\n    }\n\n    /// compute `points[0] * scalar[0] + ... + points[N-1] * scalar[N-1]`\n    ///\n    /// Is cheaper than `mul` when processing >1 point due to reduced number of point doublings\n    /// uses the Straus MSM method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows\n    /// PER POINT costs:\n    ///      1: computing the Straus point lookup table (169N gates)\n    ///      2: 63 point additions (441N gates)\n    ///      3: 126 table reads with runtime index (252N gates)\n    ///\n    /// Additional costs:\n    ///      1. 252 point doublings 1260 gates\n    ///\n    /// Cost: 1260 + 862N + cost of creating ScalarField (110N gates)\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self {\n        let a = Params::a();\n        let d = Params::d();\n\n        // Generalized version of `mul` for multiple points.\n        let mut point_tables: [([Field; 16], [Field; 16]); N] = [([0; 16], [0; 16]); N];\n        for j in 0..N {\n            point_tables[j] = points[j].compute_straus_point_table(a, d);\n        }\n\n        let idx = scalars[0].base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: point_tables[0].0[idx], y: point_tables[0].1[idx] };\n        for j in 1..N {\n            let idx = scalars[j].base4_slices[0] as u32;\n            let P = Curve { x: point_tables[j].0[idx], y: point_tables[j].1[idx] };\n            accumulator = accumulator.add_internal(P, a, d);\n        }\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            for j in 0..N {\n                let idx = scalars[j].base4_slices[i] as u32;\n                let x = point_tables[j].0[idx];\n                let y = point_tables[j].1[idx];\n                accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n            }\n        }\n\n        for j in 0..N {\n            if (scalars[j].skew == true) {\n                accumulator = accumulator - points[j];\n            }\n        }\n        accumulator\n    }\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### H E L P E R    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> Curve<Params> {\n\n    /// add two points together\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `add` :(\n    fn add_internal(self, other: Self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let x2 = other.x;\n        let y1 = self.y;\n        let y2 = other.y;\n        let (x, y, lambda) = unsafe { __add_unconstrained(x1, x2, y1, y2, a, d) };\n        let x1x2 = x1 * x2;\n        let x1y2 = x1 * y2;\n        std::as_witness(x1x2);\n        std::as_witness(x1y2);\n        let x_lhs = x * lambda * d + x - x1y2; // equals y1x2\n        let y_lhs = y * lambda * -d + y + x1x2 * a; // equals y1y2\n        let y1x2 = y1 * x2;\n        let y1y2 = y1 * y2;\n        std::as_witness(y1x2);\n        std::as_witness(y1y2);\n        let y1y2x1x2 = y1y2 * x1x2;\n        assert(x_lhs == y1x2);\n        assert(y_lhs == y1y2);\n        assert(y1y2x1x2 == lambda);\n        Self { x, y }\n    }\n\n    /// add a point to itself\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `dbl` :(\n    fn dbl_internal(self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let y1 = self.y;\n        let (x3, y3, _) = unsafe { __add_unconstrained(x1, x1, y1, y1, a, d) };\n        let x1x1a = x1 * x1 * a;\n        std::as_witness(x1x1a);\n        // t1 = a*x_1^2 + y_1^2\n        let t1 = y1 * y1 + x1x1a;\n        std::as_witness(t1);\n        // t3 = y_3 * (2 - a*x_1^2 + y_1^2) + 2*a*x_1^2\n        let t3 = y3 + y3 - t1 * y3 + x1x1a * 2;\n        // t3 == t1 implies y_3 * (2 - a*x_1^2 - y_1^2) + 2*a*x_1^2 == a*x_1^2 + y_1^2\n        // i.e. y_3 = y_1^2 - a*x_1^2 / (2 - a*x_1^2 - y_1^2)\n        assert(t3 == t1);\n        let t4 = x1 * y1;\n        std::as_witness(t4);\n        // x3 * t1 - t4 == t4 implies x_3 * (y_1^2 + a * x_1^2) = 2 * x_1 * y_1\n        // i.e. x_3 = 2 * x_1 * y_1 / (y_1^2 + a * x_1^2)\n        let t2 = x3 * t1 - t4;\n        assert(t2 == t4);\n        Self { x: x3, y: y3 }\n    }\n\n    /// Compute a 4-bit lookup table of point multiples for the Straus windowed scalar multiplication algorithm.\n    ///\n    /// Table contains [0, P, 2P, ..., 15P], which is used in the scalar mul algorithm to minimize the total number of required point additions\n    ///\n    /// It is cheaper to use ([Field; 16], [Field; 16]) than it is ([Curve; 16]).\n    /// This is because the compiler will represent [Curve; 16] in 1 ROM array (vs 2 for [Field; 16], [Field; 16]).\n    /// This means that any index into the ROM array for [Curve; 16] requires an additional arithmetic gate to process.\n    ///\n    ///      For example consider `let P: Curve = table[idx]`\n    ///      `table` will be a ROM array with 32 elements in it.\n    ///      The x-coordinates will be located at `2 * idx`\n    ///      The y-coordinates will be located at `2 * idx + 1`\n    ///      If `idx` is not known at compile time (for Straus it isnt), 2 arithmetic gates are required to evaluate `2 * idx`, `2 * idx + 1`\n    ///      before they can be used as arguments in a memory lookup protocol\n    ///\n    ///      Now consider `let P_x = table_x[idx]; let P_y = table_y[idx]`\n    ///      In this example, `idx` can be directly used as the argument into a memory lookup protocol for both tables.\n    ///\n    ///      For the Barretenberg backend, the cost of a Read-Only memory lookup is 2 gates,\n    ///      so splitting the x/y coordinates into separate tables means that the cost to lookup a point is 4 gates\n    ///      2 extra arithmetic gates would increase the cost by 50%, which we avoid by returning `([Field; 16], [Field; 16])` instead of `([Curve; 16])`\n    ///\n    /// Key cost components are as follows:\n    ///      1: Defining two size-16 lookup tables (2 gates per element, 32 elements = 64 gates)\n    ///      2: 15 point additions (7 * 5 = 105)\n    ///\n    /// Total Cost: 169 gates\n    fn compute_straus_point_table(self, a: Field, d: Field) -> ([Field; 16], [Field; 16]) {\n        let mut table_x: [Field; 16] = [0; 16];\n        let mut table_y: [Field; 16] = [0; 16];\n        table_x[8] = self.x;\n        table_y[8] = self.y;\n        let D = self.dbl_internal(a, d);\n        for i in 1..8 {\n            let Q = Self { x: table_x[7 + i], y: table_y[7 + i] };\n            let V = D.add_internal(Q, a, d);\n            table_x[8 + i] = V.x;\n            table_y[8 + i] = V.y;\n        }\n        for i in 0..8 {\n            table_x[i] = -table_x[15 - i];\n            table_y[i] = table_y[15 - i];\n        }\n        (table_x, table_y)\n    }\n}\n\n/// add points together, return output + lambda ter\nunconstrained fn __add_unconstrained(\n    x1: Field,\n    x2: Field,\n    y1: Field,\n    y2: Field,\n    a: Field,\n    d: Field,\n) -> (Field, Field, Field) {\n    let lambda = y1 * y2 * x1 * x2;\n    let y = (x1 * x2 * a - y1 * y2) / (lambda * d - 1);\n    let x = (x1 * y2 + y1 * x2) / (lambda * d + 1);\n    (x, y, lambda)\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/lib.nr"},"57":{"source":"use std::static_assert;\n\n/// ScalarField represents a scalar multiplier as a sequence of 4-bit slices\n///\n/// There is nuance to ScalarField, because twisted edwards curves generally have prime group orders that easily fit into a Field\n/// We can therefore obtain cheap conversions by simply summing up the bit slices and validate they equal the input scalar\n/// However...when converting arbitrary field elements (i.e. scalars that are multiples of a TE curve group order),\n/// we must perform additional checks when converting into 4-bit slices, as we must validate that the sum of the slices is smaller than the Field modulus (when evaluated over the integers)\n/// This is expensive and we would rather not do it! therefore ScalarField<N> is flexible.\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n///\n/// N.B. ScalarField bit values are not constrained to be smaller than the TE curve group order.\n/// ScalarField is used when performing scalar multiplications, where all operations wrap modulo the curve order\npub global TWO_POW_128: Field = 0x100000000000000000000000000000000;\npub global PLO: Field = 0x2833e84879b9709143e1f593f0000001;\npub global PHI: Field = 0x30644e72e131a029b85045b68181585d;\n\npub struct ScalarField<let N: u32> {\n    pub(crate) base4_slices: [u8; N],\n    pub(crate) skew: bool,\n}\n\nunconstrained fn get_wnaf_slices<let N: u32>(x: Field) -> ([u8; N], bool) {\n    let mut result: [u8; N] = [0; N];\n    let mut nibbles: [u8; N] = to_le_radix_16(x);\n\n    let skew: bool = nibbles[0] & 1 == 0;\n    nibbles[0] += skew as u8;\n    result[N - 1] = (nibbles[0] + 15) / 2;\n    for i in 1..N {\n        let mut nibble: u8 = nibbles[i];\n        result[N - 1 - i] = (nibble + 15) / 2;\n        if (nibble & 1 == 0) {\n            result[N - 1 - i] += 1;\n            result[N - i] -= 8;\n        }\n    }\n    (result, skew)\n}\n\nunconstrained fn from_wnaf_slices<let N: u32>(x: [u8; N], skew: bool) -> Field {\n    let mut result: Field = 0;\n\n    for i in 0..N {\n        result *= 16;\n        result += (x[i] as Field) * 2 - 15;\n    }\n    result -= skew as Field;\n    result\n}\n\nunconstrained fn get_borrow_flag(lhs_lo: Field, rhs_lo: Field) -> bool {\n    lhs_lo.lt(rhs_lo + 1)\n}\n\nunconstrained fn to_le_radix_16<let N: u32>(value: Field) -> [u8; N] {\n    // Round up on odd values of `N` to ensure space for last nibble.\n    let bytes = value.to_le_bytes::<(N + 1) / 2>();\n    let mut result: [u8; N] = [0; N];\n    for index in 0..(N / 2) {\n        result[index * 2] = bytes[index] & 0x0F; // Extract low nibble (bits 0-3)\n        result[index * 2 + 1] = (bytes[index] >> 4); // Extract high nibble (bits 4-7)\n    }\n    if (N & 1) == 1 {\n        let last_nibble = bytes[bytes.len() - 1];\n        // The last byte must have the top 4 bits empty.\n        (last_nibble as Field).assert_max_bit_size::<4>();\n        result[N - 1] = last_nibble;\n    }\n    result\n}\n\nimpl<let N: u32> std::convert::From<Field> for ScalarField<N> {\n\n    /// Construct from a field element\n    ///\n    /// if N >= 64 we perform extra checks to ensure the slice decomposition represents the same integral value as the input\n    /// (e.g. sum of slices != x + modulus)\n    fn from(x: Field) -> Self {\n        // the field elements have 254 bits max, so we do not need to support N > 64\n        static_assert(N <= 64, \"N must be at most 64\");\n        let mut result: Self = ScalarField { base4_slices: [0; N], skew: false };\n        let (slices, skew): ([u8; N], bool) = unsafe { get_wnaf_slices(x) };\n        result.base4_slices = slices;\n        result.skew = skew;\n        if (N < 64) {\n            let mut acc: Field = (slices[0] as Field) * 2 - 15;\n            for i in 1..N {\n                acc *= 16;\n                acc += (slices[i] as Field) * 2 - 15;\n            }\n            assert(acc - skew as Field == x);\n        } else {\n            // TODO: if num bits = 64, validate in sum of the bits is smaller than the Field modulus\n            let mut lo: Field = 0;\n            let mut hi: Field = 0;\n\n            for i in 0..32 {\n                lo *= 16;\n                lo += (slices[32 + i] as Field) * 2 - 15;\n                hi *= 16;\n                hi += (slices[i] as Field) * 2 - 15;\n            }\n\n            lo -= skew as Field;\n            // Validate that the integer represented by (lo, hi) is smaller than the integer represented by (plo, phi)\n\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            // Safety: we assert that the absolute value has less than 128 bits\n            let is_positive: bool = unsafe { get_borrow_flag(lo, TWO_POW_128) };\n\n            let abs_lo = (is_positive as Field) * lo + (1 - is_positive as Field) * (-lo);\n\n            abs_lo.assert_max_bit_size::<128>();\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            let borrow = unsafe { get_borrow_flag(PLO, abs_lo) as Field };\n            // we only need to check the rlo has 128 bits or less if lo is positive. if negative, the lo is already less than PLO\n            let rlo = is_positive as Field * (PLO - lo + borrow * TWO_POW_128 - 1)\n                + (1 - is_positive as Field) * (-lo); // -1 because we are checking a strict <, not <=\n            // is lo is positive, we need to check the hi is less than phi with the borrow flag subtracted\n            // if lo is negative, we have to check that hi * 2^128 < phi * 2^128 + abs_lo + plo\n            // to do this we first make a flag to check that abs_lo + plo is larger than 2^128 or not\n            // if they are larger, we check that hi < phi + 1 and otherwise we check that hi < phi\n            // Safety: we assert the when the flag is positive we have less than 128 bits\n            let threshold_flag: bool = unsafe { get_borrow_flag(abs_lo + PLO, TWO_POW_128) };\n            (threshold_flag as Field * (abs_lo + PLO)).assert_max_bit_size::<128>();\n            let rhi = is_positive as Field * (PHI - hi - borrow)\n                + (1 - is_positive as Field) * (PHI - hi + threshold_flag as Field);\n            // the rlo value would have 128 bits or less if positive and more if negative as the modulus is 254 bits\n            rlo.assert_max_bit_size::<128>();\n            rhi.assert_max_bit_size::<128>();\n        }\n        for i in 0..N {\n            (result.base4_slices[i] as Field).assert_max_bit_size::<4>();\n        }\n        result\n    }\n}\n\nimpl<let N: u32> std::convert::Into<Field> for ScalarField<N> {\n\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    fn into(self: Self) -> Field {\n        let mut acc: Field = 0;\n        for i in 0..N {\n            acc = acc * 16;\n            acc = acc + (self.base4_slices[i] as Field) * 2 - 15;\n        }\n        acc -= self.skew as Field;\n        acc\n    }\n}\n\nimpl<let N: u32> ScalarField<N> {\n\n    pub fn new() -> Self {\n        Self { base4_slices: [0; N], skew: false }\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.base4_slices[idx]\n    }\n}\n\n#[test]\nunconstrained fn test_wnaf() {\n    let result: Field = 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0;\n    let (t0, t1) = get_wnaf_slices::<64>(result);\n    let expected = from_wnaf_slices(t0, t1);\n    assert_eq(result, expected);\n}\n\n#[test]\nfn test_regression_wnaf() {\n    let a = 0x7b;\n    let s: ScalarField<64> = ScalarField::<64>::from(a);\n    let b: Field = ScalarField::<64>::into(s);\n    assert_eq(a, b);\n}\n\n#[test]\nunconstrained fn to_le_radix_16_works_with_odd_N() {\n    let input = 0x0f00;\n    let nibbles: [u8; 3] = to_le_radix_16(input);\n    assert_eq(nibbles, [0x0, 0x0, 0xf]);\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/scalar_field.nr"}}};

export async function derive_public_key(private_key: Field, foreignCallHandler?: ForeignCallHandler): Promise<Field[]> {
  const program = new Noir(derive_public_key_circuit);
  const args: InputMap = { private_key };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field[];
}
export type derive_shared_keyInputType = {
  private_key: Field;
  public_key_packed: Field[];
}

export type derive_shared_keyReturnType = Field;
export const derive_shared_key_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"private_key","type":{"kind":"field"},"visibility":"private"},{"name":"public_key_packed","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"private"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+2dBbxVVdfu52lSkLDAIiwE1j60gKJiK1hgo0jYHaivCnZ3YWOLjd3dna/d3Z0Y94zl2K+L7eYorOdZ3xh3MX+/fed79j4unjHHM8f4Tyb7uxXhz3FTkxDqmv75v6v1vYrw91F8b4jOUbpRAD4rqkxoLD5TYqlpeNU2vOoaXg1hBgmzWcOrecOrRcOrZcNrroZXq4ZX64bX3A2vNg2vtg2vdg2v9g2veRpe8za85mt4zd/wWqDh1aHh1bHhtWDDa6GG18INr0UaXos2vDo1vDo3vLo0vLo2vBZreC3e8Fqi4bVkw2uphle3htfSDa/uDa8eDa+esgYNL1mU+oZXr4ZX74ZXn4ZX34ZXv4ZX/4bXgIbXMg2vgQ2vQQ2vwQ2vZRtey2ncyze8Vmh4rahrMLS4KFU6D9W5WufiwiXHomHWEl3/D593mYVn/dPDus7Ks/7hYYvN0rMaf9jis/asRh+2xCw+q7GHLTmrz2rkYUvN8rNm/rBus/6smT5s6dl41swe1n12njWTh/WYrWeVf1jP2XtW+YfN5rPKPawwu88q87D62X7W3x/Wa/af9beH9U7xrNKH9UnzrJKH9U31rBkf1i/ds2Z4WP+Uz0o+bEDaZyUetkzqZ/31sIHpn/W/hw0CPKv4sMGIZ+nDloU868+HLYd5VvywIaBnycOWRz2r4WErwJ4V1a+YeFavqG/v3uP61Y8r9CqMjuoHbNm/T9S7z5Z9+xf6F/r07zO2vn+vXuP69+7fb8CWA/pFAwq9e40rjO8zoNd4fdjQf/+sMf/wrPpQZvzLmAv/FHTy0LGS/D9JcF0p/HUCmVVA7f0Pn3fR5//b5/3TA7vO6vP+4YGLzfLzGn/g4rP+vEYfuMRsPK+xBy45O89r5IFLzdbzZv7AbrP3vJk+cOnZfN7MHth9dp83kwf2mO3nlX9gz9l/XvkHpnheuQcW0jyvzAPrUz3v7w/sle55f3tg75TPK31gn7TPK3lg39TPm/GB/dI/b4YH9gc8L/nAAYjnJR64DOR5fz1wIOZ5/3vgINDzig8cjHqePnBZ2PP+fOByuOfFDxwCfJ48cHnk8xoeuAL0eVHvFUueN7uAPG78n2OoPq+zPu/fPjdqHJYLXWZFY9/Gn9V1luItNPqsxWZt7QqNPWvxWczDmEaetcSs5rTvzJ+15Cz7o36mz1pq1r3Wd2bP6jYbvu0zk2ctPTt7oF/5Z3Wfrf00oOyzesze3uxX7lk9Z3Of9ynzrGg2n9V33N+fVZjNZ/WL+v3tWfWz/az+40uf1Wu2nzWgUF/yrN4pntW7MOOz+qR5Vq8xMzyrb6pnjR2ffFa/VM8aVxibeFb/lM8a3+uvZw1I+6w+/f73rGVSP2tAofisgemf1WusPmsQ4Fnjxv35rMGIZ42PH1ZYFvKs+GGF5TDPkocVhoCe1fCwwvKoZ40fV1gh4Fgs+RefUbpRmIW/+NzyH/7isxeCN4t/IbvyLMQ4/h9G8u9I5bmTQuOX+8Xxb//8f4ilkHwm+l+IrIx71gx/ubxKUWxx4VYJ//yvIv4vg5uVJMxigmfpb+VXLV24VRMLw1igVRPJQC3WqgG3k1cLWIcW11WeO2n21vUfEyqVTAw/57Q757Q757Q757Q757T757PmnHbnnHbnnHbnnHb/fzjt/tMv/xPXIk+7q8+Crlk57cpzJ+lzS88IaTUXGRn5PDl3dJpFnf/E3NWzovEfmLtmluJtnLlrZ23tGmXuulnMQ2PM3WRWc9oIczedZX/MnLmbzbrXZsrczWfDtzNj7hazswdmwtwtZ2s/lWfuuWZvb5Zl7lazuc/LMXfr2XxWOeaeezafVY6528z2s/7O3G1n+1l/Z+52KZ5Vytzt0zyrhLnnSfWsGZl73lTPmpG550v5rCRzz5/2WQnmXiD1s/5i7g7pn/U/5u4IeFaRuRdEPEuZeyHIs/5k7oUxz4qZexHQs4S5F0U9q4G5O8GeNX5854BjbuTfJa/x73UV/umf8Sc5WZ47Kcz49/bV4a/LjuJ7NWXeqy3zXl2Z95qUea9pmfealXmveZn3WpR5r2WZ9+Yq816rMu+1LvPe3GXea1PmvbZl3mtX5r32Zd6bp8x785Z5b74y781f5r0FyrzXocx7Hcu8t2CZ9xYq897CZd5bpMx7i5Z5r1OZ9zqXea9Lmfe6lnlvsTLvLV7mvSXKvLdkmfeWKvNetzLvLV3mve5l3utR5r2eZd6LyrxXKPNefZn3epV5r3eZ9/qUea9vmff6lXmvf5n3BpR5b5ky7w0s896gMu8NLvPesmXeW67Me0PKvLd8mfdWKPPeiuHv/3cNhugcpaz/FfrM0uem7QVr4jRGjLjl71sqCXGvRY47BTuM7Ts2GiB5WSvM+p10I6N+QP34McB8F9YC5qNaY60Nfx+MvQR6VjRH5597NM86A05nvEeJz+5flXjmMJ2H67x26R/KLD5pC8Y6gZPMKlzMMgrARlNYB7h+6wabDbCoT0y5Lj4f9cOBz/KUjyjdiJsRA8TWMx73MPUhEPDigYw7S3gaFnw0ey/wNNyJzjnwNCM8ra/zCJ1HshZenjcs4AvvBsF24a0kxb2h8bjlecMJcW/kIN+MuDe2G3dcVKSQSPFAHzzWJ+0Z6z5M+zdvI0j5GIHzzJgN8rE/ZBQk1o0Dvi6MBMY9B8D/rnN9Jzq9APiIwNEZcDozBfBNdN5U581YCy8bbv2AL0Cjgu3CK3GPIMS9ufG4h5PyvYWDuBn5Hm037rioSCGR4oEGvk1Ie8a6D9MC+KakfGyK88yYUfnYHzIKEuvogK8LmwHjngPgf9e5iROdXgB808DRGXA6MwXwLXUu/oFjWQsvG26TgC9A44Ltwitxb0qIe7zxuIeT8r2Vg7gZ+d7abtxxUZFCIsUDDXxbkvaMdR+mBfAxpHyMwXlmzLh87A8ZBYl164CvC2OBcc8B8L/r3NKJTi8APiZwdAaczkwBfBudt9V5O9bCy4bbMuAL0PbBduGVuMcQ4t7BeNzDSfne0UHcjHzvZDfuuKhIIZHigQa+bUh7xroP0wL4tqR8bIvzzJjt87E/ZBQk1p0Cvi5sB4x7DoD/Xec2TnR6AfBtA0dnwOnMFMB31nkXnXdlLbxsuG0CvgDtFmwXXol7W0LcuxuPezgp33s4iJuR7z3txh0XFSkkUjzQwLczac9Y92FaAN+FlI9dcJ4Zs1s+9oeMgsS6Z8DXhV2Bcc8B8L/r3NmJTi8Avkvg6Aw4nZkC+ASd99J5b9bCy4bbOeAL0D7BduGVuHchxP0f43EPJ+V7XwdxM/K9n92446IihUSKBxr4JpD2jHUfpgXwvUj52AvnmTH75GN/yChIrPsFfF3YGxj3HAD/u84JTnR6AfC9AkdnwOnMFMD313mizpNYCy8bbkLAF6ADgu3CK3HvRYj7QONxDyfl+yAHcTPyfbDduOOiIoVkUsAD3/6kPWPdh2kBfCIpHxNxnhlzQD72h4yCxHpwwNeFSYEDNJVgnch9fIiTmJF/eXCok5iRN5aHOYkZ+c8kD3cS85bAZx3hJGbk/0GII53EjPy/QneUk5grgM86GhhzlcbaWp8nfVD6gtRJqRuyj8RXss7y50ockj/xrexXqVNSn6Uv7Z9Yu8rw9zEEnCc0T1U70HgMUqMkvyqRfAFxOWjKbY/8kyv5KyP58vGIRFJH6Htj9Hd20f9mYiL5yb8NmpN8nMZjkRqz/KtxqGvn6MQawaHOgNOZ6V+NH6fz8TqfQFj4OCAx8jEB/1cDJwZsQhmGk1cl+LknAtfwJPIaptUn5hSN6P9fVo4HPstTPqJ0I25KxxLyfLLxuI9THwL/GjseyLizhKjjgo+m70Xn8TnXGXA6M4WoU3Q+VefTCAsfByRGPi7gC+/kYLvwiuHkhYaoycA1PD3Yhigxp2hEQ9SpwGd5ykeUbsRN6XhCns8wHvcp6kM0RCHjzhKiTgk+mr4XnafmXGfA6cwUos7U+SydzyYsfByQGPmUgC+85wTbhVcMJy80RJ0DXMNzg22IEnOKRjREnQV8lqd8ROlG3JROJeR5ivG4z1QfoiEKGXeWEHVm8NH0veg8K+c6A05nphB1ns7n63wBYeHjgMTIZwZ84b0w2C68Yjh5oSHqQuAaXhRsQ5SYUzSiIep84LM85SNKN+KmdBYhzxcbj/s89SEaopBxS50p1prkQK4rY21rHGi8BKlRkuTxXxl6SNSlSI1ZHkvOIywuQyd0JxB1nu9EJ9SwZQbg2ZkeS6bqfJnOl7MWXjbcJQGPMlcE+yhzKSHuK43HfT4p31c5iJuR76vtxh0XFSkkUjzQX/ieStoz1n2Y9gv4l5HycRnOM2OuyMf+kFGQWK8O+LpwOTDuLAF8asDmK+86Lwv51hlwOjMF8Gt0nqbztYSFjwMSI08N+AJ0XbBdeMVw8qoEP/c64BpeH2zCRFGfmFM0ou8FpgGf5SkfUboRN6XLCHm+wXjc16gP0fcCyLizhKhrgo+m70XntJzrDDidmULUjTrfpPPNhIWPAxIjXxPwhfeWYLvwiuHkhYaoW4BreGuwDVFiTtGIhqibgM/ylI8o3Yib0jRCnm8zHveN6kM0RCHjzhKibgw+mr4XnTflXGfA6cwUom7X+Q6d7yQsfByQGPnGgC+8dwXbhVcMJy80RN0FXMO7g22IEnOKRjRE3QF8lqd8ROlG3JRuIuT5HuNx364+REMUMu4sIer24KPpe9F5R851BpzOTCHqXp3v0/l+wsLHAYmRbw/4wvtAsF14xXDyQkPUA8A1fDDYhigxp2hEQ9R9wGd5ykeUbsRN6Q5Cnh8yHve96kM0RCHjljpTrDXJgVxXxtrWOtD4MFKjJMnj13w8JOoRpMYsjyX3EhaXoRO6E4g673OiE2rYMgPw7EyPJY/q/JjOj7MWXjbcwwGPMk8E+yjzCCHuJ43HfR8p3085iJuR76ftxh0XFSkkUjzQXyt5lLRnrPsw7dd8HiPl4zGcZ8Y8kY/9IaMgsT4d8HXhcWDcWQL4owGbr7zrfCzkW2fA6cwUwJ/R+VmdnyMsfByQGPnRgC9AzwfbhVcMJ69K8HOfB67hC8EmTBT1iTlFI/pe4FngszzlI0o34qb0GCHP/zUe9zPqQ/S9ADLuLCHqmeCj6XvR+WzOdQaczkwh6kWdX9L5ZcLCxwGJkZ8J+ML7SrBdeMVw8kJD1CvANXw12IYoMadoREPUS8BnecpHlG7ETelZQp5fMx73i+pDNEQh484Sol4MPpq+F50v5VxnwOnMFKJe1/kNnd8kLHwckBj5xYAvvG8F24VXDCcvNES9BVzDt4NtiBJzikY0RL0BfNZbjvIRpRtxU3qJkOd3jMf9uvoQDVHIuLOEqNeDj6bvRecbOdcZcDozhah3dX5P5/cJCx8HJEZ+PeAL7wfBduEVw8kLDVEfANfww2AbosScohENUe8Bn+UpH1G6ETelNwh5/sh43O+qD9EQhYxb6kyx1iQHcl0Za1vnQOPHSI2SJI9f8/GQqE+QGrM8lrxLWFyGTuhOIOp8z4lOqGHLDMCzMz2WfKrzZzp/zlp42XAfBzzKfBHso8wnhLi/NB73e6R8f+Ugbka+v7Ybd1xUpJBI8UB/reRT0p6x7sO0X/P5jJSPz3CeGfNFPvaHjILE+nXA14XPgXFnCeCfBmy+8q7zs5BvnQGnM1MA/0bnb3X+jrDwcUBi5E8DvgB9H2wXXjGcvCrBz/0euIY/BJswUdQn5hSN6HuBb4HP8pSPKN2Im9JnhDz/aDzub9SH6HsBZNxZQtQ3wUfT96Lz25zrDDidmULUTzr/rPMvhIWPAxIjfxPwhXd6sF14xXDyQkPUdOAa/hpsQ5SYUzSiIepn4LM85SNKN+Km9C0hz78Zj/sn9SEaopBxZwlRPwUfTd+Lzp9zrjPgdGYKUb/r/EfpgqMhSoz8U8AX3ooK24VXDCcvNEQl4067hpUVtiFKzCka0RD1B/BZnvIRpRtxU/qZkOcq43H/rj5EQxQy7iwh6vfgo+l70flHznUGnM5MIapaF7hG51oWRImRfw/4wltnvPCK4WIIAD+3Dti0mxiHKDFnEwJE1eDirveUjyjdiJvSH4Q8NzUed7X6EA1RyLgrg8+v+TRxoLEZ0p+SJI9f8/GQqObIRGV5LKmuwC8uQ2czJzprnOhsTtIZcDozPZa00AVuqfNchGOJjHjDNavAo0wrByjTnBB3a+Nx15DyPbeDuBn5bmM37rioSCGZC390LLSo4OwZ6z5M+zWflqR8tKzANblWFbnYHzIKEmsbQl2Yy+m9QAsnwOhFZ8uc6ww4nZkCeFtd4HY6t2fdC4iRWxAK0DzGC68YTl6V4OfOA2xe8xq/FxBzzku4F2gHvBfwlI8o3YibUkvCXp7PeNxt1YfoewFk3FlCVFsnTd+LznY51xlwOjOFqPl1gRfQuQMLosTIbQmFt6PxwiuGa0eAqI7Apr2gcYgScy5IgKgFgBDlKR9RuhE3pXaEvbyQ8bjnVx+iIQoZd5YQNb+Tpu9F5wI51xlwOjOFqIV1gRfReVEWRImR5ycU3k7GC68YbgECRHUCNu3OxiFKzNmZAFGLACHKUz6idCNuSgsQ9nIX43EvrD5EQxQy7iwhamEnTd+LzkVyrjPgdGYKUV11gRfTeXEWRImRFyYU3iWMF14x3CIEiFoC2LSXNA5RYs4lCRC1GBCiPOUjSjfiprQIYS8vZTzurupDNEQh45Y6U6w1yYFcV8baNnWgsRvSn5Ikj1/z8ZCopZGJyvJY0tUJRndzonMxJzqXJukMOJ2ZHku66wL30Lkn4VgiI95w3QgoEzlAmaUJcReMx70YKd/1DuJm5LuX3bjjoiKFpCf+6FjoXsHZM9Z9mPZrPj1I+ehRgWtyUUUu9oeMgsTai1AXejq9F+juBBi96OyRc50BpzNTAO+tC9xH576sewExcndCAepnvPCK4XoQ7gX6AZtXf+P3AmLO/oR7gT7AewFP+YjSjbgp9SDs5QHG4+6tPkTfCyDjzhKiejtp+l509sm5zoDTmSlELaMLPFDnQSyIEiP3JhTewcYLrxiuDwGiBgOb9rLGIUrMuSwBogYCIcpTPqJ0I25KfQh7eTnjcS+jPkRDFDLuLCFqGSdN34vOgTnXGXA6M4WoIbrAy+u8AguixMjLEArvisYLrxhuIAGiVgQ27aHGIUrMOZQAUcsDIcpTPqJ0I25KAwl7eSXjcQ9RH6IhChl3lhA1xEnT96Jz+ZzrDDidmULUyrrAq+i8KguiYiMTCu9qxguvGG55AkStBmzaqxuHKDHn6gSIWgUIUZ7yEaUbcVNanrCX1zAe98rqQzREIeOWOlOsNcmBXFfG2jZzoHFNpD8lSR6/5uMhUWshE5XlsWRlJxi9phOdqzjRuRZJZ8DpzPRYMkwXeLjOaxOOJTLiDbcmAWXWcYAyaxHiXtd43KuQ8r2eg7gZ+V7fbtxxUZFCsjb+6FgYVsHZM9Z9mPZrPsNJ+RhegWty61TkYn/IKEis6xPqwtpO7wWGOQFGLzqH51xnwOnMFMBH6AKP1HkD1r2AGHkYoQBtaLzwiuGGE+4FNgQ2r42M3wuIOTci3AuMBN4LeMpHlG7ETWk4YS9vbDzuEepD9L0AMu4sIWqEk6bvRefInOsMOJ2ZQtQmusCb6rwZC6LEyCMIhXeU8cIrhhtJgKhRwKa9uXGIEnNuToCoTYEQ5SkfUboRN6WRhL28hfG4N1EfoiEKGXeWELWJk6bvReemOdcZcDozhajRusBb6jyGBVFi5E0IhXes8cIrhtuUAFFjgU17nHGIEnOOI0DUlkCI8pSPKN2Im9KmhL083njco9WHaIhCxp0lRI120vS96Nwy5zoDTmemELWVLvDWOm/Dgigx8mhC4d3WeOEVw21JgKhtgU17O+MQJebcjgBRWwMhylM+onQjbkpbEvby9sbj3kp9iIYoZNxSZ4q1JjmQ68pY2+YONO6A9KckyePXfDwkakdkorI8lmzlBKN3cKJzayc6dyTpDDidmR5LdtIF3lnnXQjHEhnxhtuBgDK7OkCZHQlx72Y87q1J+d7dQdyMfO9hN+64qEgh2QV/dCzsVMHZM9Z9mPZrPjuT8rFzBa7J7VqRi/0hoyCx7kGoC7s4vRfYyQkwetG5c851BpzOTAF8T13gCTrvxboXECPvRChAexsvvGK4nQn3AnsDm9c+xu8FxJz7EO4FJgDvBTzlI0o34qa0M2Ev/8d43HuqD9H3Asi4s4SoPZ00fS86J+RcZ8DpzBSi9tUF3k/n/VkQJUbek1B4JxovvGK4CQSImghs2pOMQ5SYcxIBovYDQpSnfETpRtyUJhD28gHG495XfYiGKGTcWULUvk6avhed++VcZ8DpzBSiDtQFPkjng1kQJUbel1B4DzFeeMVw+xEg6hBg0z7UOESJOQ8lQNRBQIjylI8o3Yib0n6EvXyY8bgPVB+iIQoZd5YQdaCTpu9F50E51xlwOjOFqMN1gY/Q+UgWRImRDyQU3qOMF14x3EEEiDoK2LSPNg5RYs6jCRB1BBCiPOUjSjfipnQQYS8fYzzuw9WHaIhCxi11plhrkgO5roy1beFA47FIf0qSPH7Nx0OijkMmKstjyeFOMPpYJzqPcKLzOJLOgNOZ6bHkeF3gE3Q+kXAskRFvuGMJKHOSA5Q5jhD3ycbjPoKU71McxM3I96l2446LihSSE/FHx8LxFZw9Y92Hab/mcwIpHydU4JrcSRW52B8yChLrqYS6cKLTe4HjnQCjF50n5FxnwOnMFMBP0wWerPPprHsBMfLxhAJ0hvHCK4Y7gXAvcAaweZ1p/F5AzHkm4V5gMvBewFM+onQjbkonEPbyWcbjPk19iL4XQMadJUSd5qTpe9E5Oec6A05nphB1ti7wOTqfy4IoMfJphMI7xXjhFcNNJkDUFGDTPs84RIk5zyNA1DlAiPKUjyjdiJvSZMJePt943GerD9EQhYw7S4g620nT96LznJzrDDidmULUBbrAF+p8EQuixMhnEwrvxcYLrxjuHAJEXQxs2pcYhygx5yUEiLoQCFGe8hGlG3FTOoewly81HvcF6kM0RCHjzhKiLnDS9L3ovDDnOgNOZ6YQNVUX+DKdL2dBlBj5AkLhvcJ44RXDXUiAqCuATftK4xAl5rySAFGXASHKUz6idCNuShcS9vJVxuOeqj5EQxQybqkzxVqTHMh1ZaxtSwcar0b6U5Lk8Ws+HhJ1DTJRWR5LpjrB6Kud6LzMic5rSDoDTmemx5JpusDX6nwd4VgiI95wVxNQ5noHKHMNIe4bjMd9GSnfNzqIm5Hvm+zGHRcVKSTX4Y+OhWkVnD1j3Ydpv+ZzLSkf11bgmtz1FbnYHzIKEutNhLpwndN7gWlOgNGLzmtzrjPgdGYK4DfrAt+i862sewEx8jRCAbrNeOEVw11LuBe4Ddi8bjd+LyDmvJ1wL3AL8F7AUz6idCNuStcS9vIdxuO+WX2IvhdAxp0lRN3spOl70XlLznUGnM5MIepOXeC7dL6bBVFi5JsJhfce44VXDHcLAaLuATbte41DlJjzXgJE3QWEKE/5iNKNuCndQtjL9xmP+071IRqikHFnCVF3Omn6XnTelXOdAaczU4i6Xxf4AZ0fZEGUGPlOQuF9yHjhFcPdRYCoh4BN+2HjECXmfJgAUQ8AIcpTPqJ0I25KdxH28iPG475ffYiGKGTcWULU/U6avhedD+RcZ8DpzBSiHtUFfkznx1kQJUa+n1B4nzBeeMVwDxAg6glg037SOESJOZ8kQNRjQIjylI8o3Yib0gOEvfyU8bgfVR+iIQoZt9SZYq1JDuS6MtZ2Lgcan0b6U5Lk8Ws+HhL1DDJRWR5LHnWC0U870fmYE53PkHQGnM5MjyXP6gI/p/PzhGOJjHjDPU1AmRccoMwzhLj/azzux0j5ftFB3Ix8v2Q37rioSCF5Hn90LDxbwdkz1n2Y9ms+z5Hy8VwFrsm9UJGL/SGjILG+RKgLzzu9F3jWCTB60flcznUGnM5MAfxlXeBXdH6VdS8gRn6WUIBeM154xXDPEe4FXgM2r9eN3wuIOV8n3Au8ArwX8JSPKN2Im9JzhL38hvG4X1Yfou8FkHFnCVEvO2n6XnS+knOdAaczU4h6Uxf4LZ3fZkGUGPllQuF9x3jhFcO9QoCod4BN+13jECXmfJcAUW8BIcpTPqJ0I25KrxD28nvG435TfYiGKGTcWULUm06avhedb+VcZ8DpzBSi3tcF/kDnD1kQJUZ+k1B4PzJeeMVwbxEg6iNg0/7YOESJOT8mQNQHQIjylI8o3Yib0luEvfyJ8bjfVx+iIQoZd5YQ9b6Tpu9F5wc51xlwOjOFqE91gT/T+XMWRImR3ycU3i+MF14x3AcEiPoC2LS/NA5RYs4vCRD1GRCiPOUjSjfipvQBYS9/ZTzuT9WHaIhCxi11plhrkgO5roy1beVA49dIf0qSPH7Nx0OivkEmKstjyadOMPprJzo/c6LzG5LOgNOZ6bHkW13g73T+nnAskRFvuK8JKPODA5T5hhD3j8bj/oyU758cxM3I9892446LihSS7/FHx8K3FZw9Y92Hab/m8x0pH99V4JrcDxW52B8yChLrz4S68L3Te4FvnQCjF53f5VxnwOnMFMB/0QWervOvrHsBMfK3hAL0m/HCK4b7jnAv8Buwef1u/F5AzPk74V5gOvBewFM+onQjbkrfEfbyH8bj/kV9iL4XQMadJUT94qTpe9E5Pec6A05nphBVbO4VOldW4hc+DkiM/Auh8FZV2i68YrjpBIhKxp12DasrbUOUmFM0oiGqAhd3vad8ROlG3JSmE/ZyjfG4g/oQDVHIuLOEqFDJaaZ51VmRc50BpzNTiKrV5l6ncxMWRMU7uxJfeJsaL7xiOHmhIaopsGk3Mw5RYs5mBIiqA0KUp3xE6UbclCoIe7m58bhr1YdoiELGnSVE1Tpp+l501uVcZ8DpzBSiWmhzb6nzXJX4hY8DEiPXEgpvK+OFVwxXR4CoVsCm3do4RIk5WxMgqiUQojzlI0o34qZUR9jLcxuPu4X6EA1RyLj1rPq3gVxXxtq2dqCxDdKfkiSPX/PxkKi2yERleSxp4QSj2zjR2dKJzrYknQGnM9NjSTttYe11nodwLJERb7g2BJSZ1wHKtCXEPZ/xuFuS8j2/g7gZ+V7AbtxxUZFCMg/+6FhoV8nZM9Z9mPZrPu1J+WhfiWty81bmYn/IKEisCxDqwjzAuLME8HZOgNGLzvY51xlwOjMF8A4K3B11XrASv/BxQGLkdoQCtJDxwiuGk1cl+LkLAZvXwkZhoqhPzLkwHibqO+LirveUjyjdiJtSe8JeXsR43B3Uh+h7AWTcWUJUBydN34vOjjnXGXA6M4WoRbW5d9K5cyV+4eOAxMgdCIW3i/HCK4brSICoLsCm3dU4RIk5uxIgqhMQojzlI0o34qbUkbCXFzMe96LqQzREIePOEqIWddL0vejslHOdAaczU4haXJv7EjovWYlf+DggMfKihMK7lPHCK4brRICopYBNu5txiBJzdiNA1BJAiPKUjyjdiJtSJ8JeXtp43IurD9EQhYw7S4ha3EnT96JziZzrDDidmUJUd23uPXTuWYlf+DggMfLihMIbGS+8YrglCBAVAZt2wThEiTkLBIjqAYQoT/mI0o24KS1B2Mv1xuPurj5EQxQybqkzxVqTHMh1Zazt3A409kL6U5Lk8Ws+HhLVG5moLI8l3Z1gdC8nOns40dmbpDPgdGZ6LOmjLayvzv0IxxIZ8YbrRUCZ/g5Qpjch7gHG4+5ByvcyDuJm5Hug3bjjoiKFpB/+6FjoU8nZM9Z9mPZrPn1J+ehbiWty/StzsT9kFCTWgYS60A8Yd5YA3scJMHrR2TfnOgNOZ6YAPkiBe7DOy1biFz4OSIzch1CAljNeeMVw8qoEP3c5YPMaYhQmivrEnEPwMFE/GBd3vad8ROlG3JT6Evby8sbjHqQ+RN8LIOPOEqIGOWn6XnQOzrnOgNOZKUStoM19RZ2HVuIXPg5IjDyIUHhXMl54xXCDCRC1ErBpr2wcosScKxMgakUgRHnKR5RuxE1pMGEvr2I87hXUh2iIQsadJUSt4KTpe9G5Ys51BpzOTCFqVW3uq+m8eiV+4eOAxMgrEArvGsYLrxhuRQJErQFs2msahygx55oEiFoNCFGe8hGlG3FTWpGwl9cyHveq6kM0RCHjzhKiVnXS9L3oXC3nOgNOZ6YQNUyb+3Cd167EL3wckBh5VULhXcd44RXDrUaAqHWATXtd4xAl5lyXAFHDgRDlKR9RuhE3pdUIe3k943EPUx+iIQoZt9SZYq1JDuS6Mta2jQON6yP9KUny+DUfD4kagUxUlseSYU4wen0nOoc70TmCpDPgdGZ6LBmpLWwDnTckHEtkxBtufQLKbOQAZUYQ4t7YeNzDSfnexEHcjHxvajfuuKhIIdkQf3QsjKzk7BnrPkz7NZ8NSPnYoBLX5DaqzMX+kFGQWDcl1IUNgXFnCeAjnQCjF50b5FxnwOnMFMA3U+AepfPmlfiFjwMSI48kFKAtjBdeMZy8KsHP3QLYvEYbhYmiPjHnaDxM1I/CxV3vKR9RuhE3pQ0Ie3lL43Fvpj5E3wsg484SojZz0vS96ByVc50BpzNTiBqjzX2szuMq8QsfByRG3oxQeMcbL7xiuFEEiBoPbNpbGYcoMedWBIgaC4QoT/mI0o24KY0i7OWtjcc9Rn2Ihihk3FlC1BgnTd+LzrE51xlwOjOFqG20uW+r83aV+IWPAxIjjyEU3u2NF14x3FgCRG0PbNo7GIcoMecOBIjaFghRnvIRpRtxUxpL2Ms7Go97G/UhGqKQcWcJUds4afpedG6bc50BpzNTiNpJm/vOOu9SiV/4OCAx8jaEwrur8cIrhtuWAFG7Apv2bsYhSsy5GwGidgZClKd8ROlG3JS2Jezl3Y3HvZP6EA1RyLilzhRrTXIg15Wxtm0daNwD6U9Jksev+XhI1J7IRGV5LNnJCUbv4UTnzk507knSGXA6Mz2WTNAWtpfOexOOJTLiDbcHAWX2cYAyexLi/o/xuHcm5XtfB3Ez8r2f3bjjoiKFZG/80bEwoZKzZ6z7MO3XfPYi5WOvSlyT26cyF/tDRkFi3Y9QF/YGxp0lgE9wAoxedO6Vc50BpzNTAN9fgXuizpMq8QsfByRGnkAoQAcYL7xiOHlVgp97ALB5HWgUJor6xJwH4mGifiIu7npP+YjSjbgp7UXYywcZj3t/9SH6XgAZd5YQtb+Tpu9F58Sc6ww4nZlC1MHa3A/R+dBK/MLHAYmR9ycU3sOMF14x3EQCRB0GbNqHG4coMefhBIg6BAhRnvIRpRtxU5pI2MtHGI/7YPUhGqKQcWcJUQc7afpedB6Sc50BpzNTiDpSm/tROh9diV/4OCAx8sGEwnuM8cIrhjuEAFHHAJv2scYhSsx5LAGijgJClKd8ROlG3JQOIezl44zHfaT6EA1RyLizhKgjnTR9LzqPyrnOgNOZKUQdr839BJ1PrMQvfByQGPlIQuE9yXjhFcMdRYCok4BN+2TjECXmPJkAUScAIcpTPqJ0I25KRxH28inG4z5efYiGKGTcUmeKtSY5kOvKWNt2DjSeivSnJMnj13w8JOo0ZKKyPJYc7wSjT3Wi8wQnOk8j6Qw4nZkeSyZrCztd5zMIxxIZ8YY7lYAyZzpAmdMIcZ9lPO4TSPk+20HcjHyfYzfuuKhIITkDf3QsTK7k7BnrPkz7NZ/TSfk4vRLX5M6szMX+kFGQWM8h1IUzgHFnCeCTnQCjF52n51xnwOnMFMDPVeCeovN5lfiFjwMSI08mFKDzjRdeMZy8KsHPPR/YvC4wChNFfWLOC/AwUT8FF3e9p3xE6UbclE4n7OULjcd9rvoQfS+AjDtLiDrXSdP3onNKznUGnM5MIeoibe4X63xJJX7h44DEyOcSCu+lxguvGG4KAaIuBTbtqcYhSsw5lQBRFwMhylM+onQjbkpTCHv5MuNxX6Q+REMUMu4sIeoiJ03fi86Lc64z4HRmClGXa3O/QucrK/ELHwckRr6IUHivMl54xXAXEyDqKmDTvto4RIk5ryZA1BVAiPKUjyjdiJvSxYS9fI3xuC9XH6IhChl3lhB1uZOm70XnFTnXGXA6M4Woadrcr9X5ukr8wscBiZEvJxTe640XXjHcFQSIuh7YtG8wDlFizhsIEHUtEKI85SNKN+KmdAVhL99oPO5p6kM0RCHjljpTrDXJgVxXxtq2d6DxJqQ/JUkev+bjIVE3IxOV5bFkmhOMvsmJzmud6LyZpDPgdGZ6LLlFW9itOt9GOJbIiDfcTQSUud0BytxMiPsO43FfS8r3nQ7iZuT7Lrtxx0VFCslt+KNj4ZZKzp6x7sO0X/O5lZSPWytxTe72ylzsDxkFifUuQl24DRh3lgB+ixNg9KLz1pzrDDidmQL43Qrc9+h8byV+4eOAxMi3EArQfcYLrxhOXpXg594HbF73G4WJoj4x5/14mKi/Bxd3vad8ROlG3JRuJezlB4zHfbf6EH0vgIw7S4i620nT96LznpzrDDidmULUg9rcH9L54Ur8wscBiZHvJhTeR4wXXjHcPQSIegTYtB81DlFizkcJEPUQEKI85SNKN+KmdA9hLz9mPO4H1YdoiELGnSVEPeik6XvR+VDOdQaczkwh6nFt7k/o/GQlfuHjgMTIDxIK71PGC68Y7iECRD0FbNpPG4coMefTBIh6AghRnvIRpRtxU3qIsJefMR734+pDNEQh484Soh530vS96Hwi5zoDTmemEPWsNvfndH6+Er/wcUBi5McJhfcF44VXDPcEAaJeADbt/xqHKDHnfwkQ9RwQojzlI0o34qb0BGEvv2g87mfVh2iIQsYtdaZYa5IDua6MtZ3HgcaXkP6UJHn8mo+HRL2MTFSWx5JnnWD0S050PudE58sknQGnM9NjySvawl7V+TXCsURGvOFeIqDM6w5Q5mVC3G8Yj/s5Ur7fdBA3I99v2Y07LipSSF7DHx0Lr1Ry9ox1H6b9ms+rpHy8Wolrcq9X5mJ/yChIrG8R6sJrwLizBPBXnACjF52v5lxnwOnMFMDfVuB+R+d3K/ELHwckRn6FUIDeM154xXDyqgQ/9z1g83rfKEwU9Yk538fDRP07uLjrPeUjSjfipvQqYS9/YDzut9WH6HsBZNxZQtTbTpq+F53v5FxnwOnMFKI+1Ob+kc4fV+IXPg5IjPw2ofB+YrzwiuHeIUDUJ8Cm/alxiBJzfkqAqI+AEOUpH1G6ETeldwh7+TPjcX+oPkRDFDLuLCHqQydN34vOj3KuM+B0ZgpRn2tz/0LnLyvxCx8HJEb+kFB4vzJeeMVwHxEg6itg0/7aOESJOb8mQNQXQIjylI8o3Yib0keEvfyN8bg/Vx+iIQoZd5YQ9bmTpu9F5xc51xlwOjOFqG+1uX+n8/eV+IWPAxIjf04ovD8YL7xiuC8IEPUDsGn/aByixJw/EiDqOyBEecpHlG7ETekLwl7+yXjc36oP0RCFjFvqTLHWJAdyXRlrO68DjT8j/SlJ8vg1Hw+J+gWZqCyPJd86weifnej8zonOX0g6A05npseS6drCftX5N8KxREa84X4moMzvDlDmF0LcfxiP+ztSvqWVW4+bke8Ku3HHRUUKyW/4o2NheiVnz1j3Ydqv+fxKysevlbgm93tlLvaHjILEKhrRdeE3YB/IEsCnOwFGLzp/zbnOgNOZKYBX6g9VOldX4Rc+DkiMPJ0AJjXGC68Y7lfCvUAy7rRrWGsUJor6xJyiEX0vUIWLu95TPqJ0I25KvxL2cp3xuCvVh+h7AWTcWUJUZZWPpu9FZ1XOdQaczkwhqon+0FTnZiyIEiNXEk5xzY0XXjGcvNAQ1RzYtFsYhygxZwsCRDUFQpSnfETpRtyUqgh7uaXxuJuoD9EQ1dIpRDVx0vS96Gyac50BpzNTiJpLf2ilc2sWRImRmxAK79zGC68YrikBouYGNu02xiFKzNmGAFGtgBDlKR9RuhE3paaEvdzWeNxzqQ/RENXWKUTN5aTpe9HZKuc6A05nphDVTn9or/M8LIgSI89FKLzzGi+8YrhWBIiaF9i05zMOUWLO+QgQ1R4IUZ7yEaUbcVNqRdjL8xuPu536EA1RyLilzhRrTXIg15WxtvM50LgA0p+SpKo5iaJo7IBMVJbHknZOMHoBJzrbO9HZgaQz4HRmeizpqD8sqPNChGOJjHjDLUBAmYUdoEwHQtyLGI+7PSnfizqIm5HvTnbjjouKFJKF8EfHQscqzp6x7sO0X/NZkJSPBatwTW7hqlzsDxkFibUToS4s5PReoKMTYPSic8Gc6ww4nZkCeGf9oYvOXVn3AmLkjoQCtJjxwiuGW5BwL7AYsHktbvxeQMy5OOFeoAvwXsBTPqJ0I25KCxL28hLG4+6sPkTfCyzhFKI6O2n6XnR2ybnOgNOZKUQtqT8spXM3FkSJkTsTCu/SxguvGK4LAaKWBjbt7sYhSszZnQBRSwEhylM+onQjbkpdCHu5h/G4l1QfoiGqh1OIWtJJ0/eic6mc6ww4nZlCVE/9IdK5wIIoMfKShMJbb7zwiuGWIkBUPbBp9zIOUWLOXgSIioAQ5SkfUboRN6WlCHu5t/G4e6oP0RDV2ylE9XTS9L3ojHKuM+B0ZgpRffSHvjr3Y0GUGLknofD2N154xXARAaL6A5v2AOMQJeYcQICovkCI8pSPKN2Im1JE2MvLGI+7j/oQDVHIuKXOFGtNciDXlbG28zvQOBDpT0lS1ZxEUTQOQiYqy2NJHycYPdCJzr5OdA4i6Qw4nZkeSwbrD8vqvBzhWCIj3nADCSgzxAHKDCLEvbzxuPuS8r2Cg7gZ+V7RbtxxUZFCshz+6FgYXMXZM9Z9mPZrPsuS8rFsFa7JDanKxf6QUZBYVyTUheWc3gsMdgKMXnQum3OdAaczUwAfqj+spPPKrHsBMfJgQgFaxXjhFcMtS7gXWAXYvFY1fi8g5lyVcC+wEvBewFM+onQjbkrLEvbyasbjHqo+RN8LrOYUooY6afpedK6Uc50BpzNTiFpdf1hD5zVZECVGHkoovGsZL7xiuJUIELUWsGkPMw5RYs5hBIhaAwhRnvIRpRtxU1qJsJeHG497dfUhGqKGO4Wo1Z00fS8618i5zoDTmSlEra0/rKPzuiyIEiOvTii86xkvvGK4NQgQtR6waa9vHKLEnOsTIGodIER5ykeUbsRNaQ3CXh5hPO611YdoiBrhFKLWdtL0vehcJ+c6A05nphA1Un/YQOcNWRAlRl6bUHg3Ml54xXDrECBqI2DT3tg4RIk5NyZA1AZAiPKUjyjdiJvSOoS9vInxuEeqD9EQhYxb6kyx1iQHcl0Za7uAA42bIv0pSaqakyiKxs2QicryWDLSCUZv6kTnBk50bkbSGXA6Mz2WjNIfNtd5C8KxREa84TYloMxoByizGSHuLY3HvQEp32McxM3I91i7ccdFRQrJFvijY2FUFWfPWPdh2q/5bE7Kx+ZVuCY3uioX+0NGQWIdS6gLWzi9FxjlBBi96Nw85zoDTmemAD5Ofxiv81asewEx8ihCAdraeOEVw21OuBfYGti8tjF+LyDm3IZwLzAeeC/gKR9RuhE3pc0Je3lb43GPUx+i7wW2dQpR45w0fS86x+dcZ8DpzBSittMfttd5BxZEiZHHEQrvjsYLrxhuPAGidgQ27Z2MQ5SYcycCRG0PhChP+YjSjbgpjSfs5Z2Nx72d+hANUTs7hajtnDR9Lzq3z7nOgNOZKUTtoj/sqvNuLIgSI29HKLy7Gy+8YrjtCRC1O7Bp72EcosScexAgalcgRHnKR5RuxE1pe8Je3tN43LuoD9EQtadTiNrFSdP3onPXnOsMOJ2ZQtQE/WEvnfdmQZQYeRdC4d3HeOEVw+1KgKh9gE37P8YhSsz5HwJE7QWEKE/5iNKNuCntStjL+xqPe4L6EA1RyLilzhRrTXIg15Wxth0caNwP6U9JUtWcRFE07o9MVJbHkglOMHo/Jzr3cqJzf5LOgNOZ6bFkov4wSecDCMcSGfGG24+AMgc6QJn9CXEfZDzuvUj5PthB3Ix8H2I37rioSCE5AH90LEys4uwZ6z5M+zWfSaR8TKrCNbkDq3KxP2QUJNZDCHXhAKf3AhOdAKMXnZNyrjPgdGYK4IfqD4fpfDjrXkCMPJFQgI4wXnjFcJMI9wJHAJvXkcbvBcScRxLuBQ4D3gt4ykeUbsRNaRJhLx9lPO5D1Yfoe4GjnELUoU6avhedh+VcZ8DpzBSijtYfjtH5WBZEiZEPJRTe44wXXjHcYQSIOg7YtI83DlFizuMJEHUMEKI85SNKN+KmdBhhL59gPO6j1YdoiDrBKUQd7aTpe9F5TM51BpzOTCHqRP3hJJ1PZkGUGPloQuE9xXjhFcMdQ4CoU4BN+1TjECXmPJUAUScBIcpTPqJ0I25KxxD28mnG4z5RfYiGqNOcQtSJTpq+F50n5VxnwOnMFKIm6w+n63wGC6LEyCcSCu+ZxguvGO4kAkSdCWzaZxmHKDHnWQSIOh0IUZ7yEaUbcVM6ibCXzzYe92T1IRqikHFLnSnWmuRAritjbTs60HgO0p+SpKo5iaJoPBeZqCyPJZOdYPQ5TnSe7kTnuSSdAacz02PJFP3hPJ3PJxxLZMQb7hwCylzgAGXOJcR9ofG4Tyfl+yIHcTPyfbHduOOiIoXkfPzRsTClirNnrPsw7dd8ziPl47wqXJO7oCoX+0NGQWK9mFAXznd6LzDFCTB60XleznUGnM5MAfwS/eFSnaey7gXEyFMIBegy44VXDHce4V7gMmDzutz4vYCY83LCvcClwHsBT/mI0o24KZ1H2MtXGI/7EvUh+l7gCqcQdYmTpu9F56U51xlwOjOFqCv1h6t0vpoFUWLkSwiF9xrjhVcMdykBoq4BNu1pxiFKzDmNAFFXASHKUz6idCNuSpcS9vK1xuO+Un2IhqhrnULUlU6avhedV+VcZ8DpzBSirtMfrtf5BhZEiZGvJBTeG40XXjHcVQSIuhHYtG8yDlFizpsIEHU9EKI85SNKN+KmdBVhL99sPO7r1IdoiLrZKURd56Tpe9F5fc51BpzOTCHqFv3hVp1vY0GUGPk6QuG93XjhFcNdT4Co24FN+w7jECXmvIMAUbcCIcpTPqJ0I25K1xP28p3G475FfYiGKGTcUmeKtSY5kOvKWNsFHWi8C+lPSVLVnERRNN6NTFSWx5JbnGD0XU503upE590knQGnM9NjyT36w70630c4lsiIN9xdBJS53wHK3E2I+wHjcd9KyveDDuJm5Pshu3HHRUUKyX34o2PhnirOnrHuw7Rf87mXlI97q3BN7v6qXOwPGQWJ9SFCXbjP6b3APU6A0YvOe3OuM+B0ZgrgD+sPj+j8KOteQIx8D6EAPWa88Irh7iXcCzwGbF6PG78XEHM+TrgXeAR4L+ApH1G6ETelewl7+QnjcT+sPkTfCzzhFKIedtL0veh8JOc6A05nphD1pP7wlM5PsyBKjPwwofA+Y7zwiuEeIUDUM8Cm/axxiBJzPkuAqKeAEOUpH1G6ETelRwh7+TnjcT+pPkRD1HNOIepJJ03fi86ncq4z4HRmClHP6w8v6PxfFkSJkZ8kFN4XjRdeMdxTBIh6Edi0XzIOUWLOlwgQ9QIQojzlI0o34qb0FGEvv2w87ufVh2iIetkpRD3vpOl70flCznUGnM5MIeoV/eFVnV9jQZQY+XlC4X3deOEVw71AgKjXgU37DeMQJeZ8gwBRrwIhylM+onQjbkovEPbym8bjfkV9iIYoZNxSZ4q1JjmQ68pY24UcaHwL6U9JUtWcRFE0vo1MVJbHklecYPRbTnS+6kTn2ySdAacz02PJO/rDuzq/RziWyIg33FsElHnfAcq8TYj7A+Nxv0rK94cO4mbk+yO7ccdFRQrJe/ijY+GdKs6ese7DtF/zeZeUj3ercE3u/apc7A8ZBYn1I0JdeM/pvcA7ToDRi853c64z4HRmCuAf6w+f6Pwp615AjPwOoQB9ZrzwiuHeJdwLfAZsXp8bvxcQc35OuBf4BHgv4CkfUboRN6V3CXv5C+Nxf6w+RN8LfOEUoj520vS96Pwk5zoDTmemEPWl/vCVzl+zIEqM/DGh8H5jvPCK4T4hQNQ3wKb9rXGIEnN+S4Cor4AQ5SkfUboRN6VPCHv5O+Nxf6k+REPUd04h6ksnTd+Lzq9yrjPgdGYKUd/rDz/o/CMLosTIXxIK70/GC68Y7isCRP0EbNo/G4coMefPBIj6AQhRnvIRpRtxU/qKsJd/MR739+pDNET94hSivnfS9L3o/CHnOgNOZ6YQNV1/+FXn31gQJUb+nlB4fzdeeMVwPxAg6ndg0/7DOESJOf8gQNSvQIjylI8o3Yib0g+EvSz/ot5y3NPVh2iIQsYtdaZYa5IDua6MtV3YgcYKpD8lSVVzEkXRWIlMVJbHkulOMLqi2ofOX52sZyVpPQNOZ6bHkqrqP+dqnWuqSQsvG07MjEaZWgcoU0mIu8543L+S8t3EQdyMfDe1G/efRaX6z+IBPjoWqqo5e8a6D9N+zaealI/qalyTq63Oxf6QUZBYmxLqQg0w7iwBvMoJ2HrRWZ1znQGnM1MAb6bA3VznFgQAjwMSI1cRClBL44VXDCevSvBzWwKb11xGYaKoT8w5Fx4m6pvj4q73lI8o3YibUjVhL7cyHncz9SH6XqCVU4hq5qTpe9HZPOc6A05nphDVWqFpbp3bsCBKjNyMUHjbGi+8YrjmBIhqC2za7YxDlJizHQGi5gZClKd8ROlG3JSaE/Zye+Nxt1YfoiGqvVOIau2k6XvROXfOdQaczkwhah6Fpnl1no8FUWLk1oTCO7/xwiuGm5sAUfMDm/YCxiFKzLkAAaLmBUKUp3xE6UbclOYm7OUOxuOeR32IhqgOTiFqHidN34vOeXOuM+B0ZgpRHRWaFtR5IRZEiZHnIRTehY0XXjHcvASIWhjYtBcxDlFizkUIELUgEKI85SNKN+KmNC9hLy9qPO6O6kM0RCHjljpTrDXJgVxXxtou4kBjJ6Q/JUkev+aziAONnZGJyvJY0tEJRndyonNBJzo7k3QGnM5MjyVd9BjSVefFCMcSGfGG60RAmcUdoExnQtxLGI97QVK+l3QQNyPfS9mNOy4qUkgWwx8dC12qOXvGug/Tfs2nKykfXatxTW7x6lzsDxkFiXUpQl1YzOm9QBcnwOhFZ9ec6ww4nZkCeDcF7qV17s66FxAjdyEUoB7GC68YrivhXqAHsHn1NH4vIObsSbgXWBp4L+ApH1G6ETelroS9HBmPu5v6EH0vEDmFqG5Omr4XnUvnXGfA6cwUogoKTfU692JBlBi5G6Hw9jZeeMVwSxMgqjewafcxDlFizj4EiKoHQpSnfETpRtyUlibs5b7G4y6oD9EQ1dcpRBWcNH0vOutzrjPgdGYKUf0UmvrrPIAFUWLkAqHwLmO88Irh6gkQtQywaQ80DlFizoEEiOoPhChP+YjSjbgp1RP28iDjcfdTH6IhapBTiOrnpOl70dk/5zoDTmemEDVYoWlZnZdjQZQYuR+h8A4xXnjFcP0JEDUE2LSXNw5RYs7lCRC1LBCiPOUjSjfiptSfsJdXMB73YPUhGqKQcUudKdaa5ECuK2NtF3WgcUWkPyVJHr/m4yFRQ5GJyvJYMtgJRq/oROeyTnQOJekMOJ2ZHktW0mPIyjqvQjiWyIg33IoElFnVAcoMJcS9mvG4lyXle3UHcTPyvYbduOOiIoVkFfzRsbBSNWfPWPdh2q/5rEzKx8rVuCa3anUu9oeMgsS6BqEurOL0XmAlJ8DoRefKOdcZcDozBfA1FbjX0nkY615AjLwSoQANN154xXArE+4FhgOb19rG7wXEnGsT7gXWAt4LeMpHlG7ETWllwl5ex3jca6oP0fcC6ziFqDWdNH0vOtfKuc6A05kpRK2r0LSezuuzIEqMvCah8I4wXnjFcGsRIGoEsGmPNA5RYs6RBIhaDwhRnvIRpRtxU1qLsJc3MB73uupDNERt4BSi1nXS9L3oXC/nOgNOZ6YQtaFC00Y6b8yCKDHyuoTCu4nxwiuGW48AUZsAm/amxiFKzLkpAaI2AkKUp3xE6UbclNYj7OXNjMe9ofoQDVGbOYWoDZ00fS86N8q5zoDTmSlEjVJo2lznLVgQJUbekFB4RxsvvGK4jQgQNRrYtLc0DlFizi0JELU5EKI85SNKN+KmtBFhL48xHvco9SEaopBxS50p1prkQK4rY207OdA4FulPSZLHr/l4SNQ4ZKKyPJaMcoLRY53o3NyJznEknQGnM9NjyXg9hmyl89aEY4mMeMONJaDMNg5QZhwh7m2Nx705Kd/bOYibke/t7cYdFxUpJFvjj46F8dWcPWPdh2m/5rMVKR9bVeOa3DbVudgfMgoS6/aEurC103uB8U6A0YvOrXKuM+B0ZgrgOyhw76jzTqx7ATHyeEIB2tl44RXDbUW4F9gZ2Lx2MX4vIObchXAvsCPwXsBTPqJ0I25KWxH28q7G495BfYi+F9jVKUTt4KTpe9G5Y851BpzOTCFqN4Wm3XXegwVRYuQdCIV3T+OFVwy3IwGi9gQ27QnGIUrMOYEAUbsDIcpTPqJ0I25KOxL28l7G495NfYiGqL2cQtRuTpq+F52751xnwOnMFKL2VmjaR+f/sCBKjLwbofDua7zwiuF2J0DUvsCmvZ9xiBJz7keAqH2AEOUpH1G6ETel3Ql7eX/jce+tPkRD1P5OIWpvJ03fi859cq4z4HRmClETFZom6XwAC6LEyHsTCu+BxguvGG4fAkQdCGzaBxmHKDHnQQSImgSEKE/5iNKNuCntQ9jLBxuPe6L6EA1RyLilzhRrTXIg15Wxtp0daDwE6U9Jksev+XhI1KHIRGV5LJnoBKMPcaJzkhOdh5J0BpzOTI8lh+kx5HCdjyAcS2TEG+4QAsoc6QBlDiXEfZTxuCeR8n20g7gZ+T7GbtxxUZFCcgT+6Fg4rJqzZ6z7MO3XfA4n5ePwalyTO7I6F/tDRkFiPYZQF45wei9wmBNg9KLz8JzrDDidmQL4sQrcx+l8POteQIx8GKEAnWC88IrhDifcC5wAbF4nGr8XEHOeSLgXOA54L+ApH1G6ETelwwl7+STjcR+rPkTfC5zkFKKOddL0veg8Luc6A05nphB1skLTKTqfyoIoMfKxhMJ7mvHCK4Y7jgBRpwGb9mTjECXmnEyAqFOAEOUpH1G6ETel4wh7+XTjcZ+sPkRD1OlOIepkJ03fi85Tcq4z4HRmClFnKDSdqfNZLIgSI59MKLxnGy+8YrhTCBB1NrBpn2McosSc5xAg6kwgRHnKR5RuxE3pFMJePtd43GeoD9EQda5TiDrDSdP3ovPMnOsMOJ2ZQtQUhabzdD6fBVFi5DMIhfcC44VXDHcmAaIuADbtC41DlJjzQgJEnQeEKE/5iNKNuCmdSdjLFxmPe4r6EA1RyLilzhRrTXIg15Wxtl0caLwY6U9Jksev+XhI1CXIRGV5LJniBKMvdqLzPCc6LyHpDDidmR5LLtVjyFSdLyMcS2TEG+5iAspc7gBlLiHEfYXxuM8j5ftKB3Ez8n2V3bjjoiKF5DL80bFwaTVnz1j3Ydqv+Uwl5WNqNa7JXV6di/0hoyCxXkWoC5c5vRe41AkwetE5Nec6A05npgB+tQL3NTpPY90LiJEvJRSga40XXjHcVMK9wLXA5nWd8XsBMed1hHuBa4D3Ap7yEaUbcVOaStjL1xuP+2r1Ifpe4HqnEHW1k6bvRec1OdcZcDozhagbFJpu1PkmFkSJka8mFN6bjRdeMdw1BIi6Gdi0bzEOUWLOWwgQdSMQojzlI0o34qZ0DWEv32o87hvUh2iIutUpRN3gpOl70XljznUGnM5MIeo2habbdb6DBVFi5BsIhfdO44VXDHcjAaLuBDbtu4xDlJjzLgJE3Q6EKE/5iNKNuCndSNjLdxuP+zb1IRqi7nYKUbc5afpedN6ec50BpzNTiLpHoelene9jQZQY+TZC4b3feOEVw91OgKj7gU37AeMQJeZ8gABR9wIhylM+onQjbkq3E/byg8bjvkd9iIYoZNxSZ4q1JjmQ68pY264OND6E9KckyePXfDwk6mFkorI8ltzjBKMfcqLzXic6HybpDDidmR5LHtFjyKM6P0Y4lsiIN9xDBJR53AHKPEyI+wnjcd9LyveTDuJm5Pspu3HHRUUKyWP4o2PhkWrOnrHuw7Rf83mUlI9Hq3FN7vHqXOwPGQWJ9SlCXXjM6b3AI06A0YvOR3OuM+B0ZgrgTytwP6Pzs6x7ATHyI4QC9JzxwiuGe5RwL/AcsHk9b/xeQMz5POFe4BngvYCnfETpRtyUHiXs5ReMx/20+hB9L/CCU4h62knT96LzmZzrDDidmULUfxWaXtT5JRZEiZGfJhTel40XXjHcMwSIehnYtF8xDlFizlcIEPUiEKI85SNKN+Km9AxhL79qPO7/qg/REPWqU4j6r5Om70XniznXGXA6M4Wo1xSaXtf5DRZEiZH/Syi8bxovvGK4FwkQ9Sawab9lHKLEnG8RIOp1IER5ykeUbsRN6UXCXn7beNyvqQ/REPW2U4h6zUnT96Lz9ZzrDDidmULUOwpN7+r8HguixMivEQrv+8YLrxjudQJEvQ9s2h8Yhygx5wcEiHoXCFGe8hGlG3FTep2wlz80Hvc76kM0RCHjljpTrDXJgVxXxtou5kDjR0h/SpI8fs3HQ6I+RiYqy2PJO04w+iMnOt91ovNjks6A05npseQTPYZ8qvNnhGOJjHjDfURAmc8doMzHhLi/MB73u6R8f+kgbka+v7Ibd1xUpJB8hj86Fj6p5uwZ6z5M+zWfT0n5+LQa1+Q+r87F/pBRkFi/ItSFz5zeC3ziBBi96Pw05zoDTmemAP61Avc3On/LuhcQI39CKEDfGS+8YrhPCfcC3wGb1/fG7wXEnN8T7gW+Ad4LeMpHlG7ETelTwl7+wXjcX6sP0fcCPziFqK+dNH0vOr/Juc6A05kpRP2o0PSTzj+zIEqM/DWh8P5ivPCK4b4hQNQvwKY93ThEiTmnEyDqJyBEecpHlG7ETekbwl7+1XjcP6oP0RD1q1OI+tFJ0/ei86ec6ww4nZlC1G8KTb/r/AcLosTIPxIKb6ixXXjFcD8RICoZd9o1rKixDVFiTtGIhqjfgRDlKR9RuhE3pZ8Ie7nSeNy/qQ/REIWMO0uI+s1J0/ei8/ec6ww4nZlCVFXNn3O1zjU1+IWPAxIj/0YovLXGC68Y7ncCRNUCm3adcYgSc9YRIKoaF3e9p3xE6UbclH4n7OUmxuOuUh+iIQoZt9SZYq1JDuS6MtZ2cQcamyL9KUny+DUfD4lqhkxUlseSqhr84jJ0NnWis9qJzmYknQGnM9NjSXM9hrTQuSXhWCIj3nBNa/AoM5cDlGlGiLuV8birSflu7SBuRr7ntht3XFSkkLTEHx0LzWs4e8a6D9N+zacFKR8tanBNbq6aXOwPGQWJdW5CXWjp9F6guRNg9KKzRc51BpzOTAG8jQJ3W53bse4FxMjNCQWovfHCK4aTVyX4ue2BzWse4/cCYs55CPcCbYH3Ap7yEaUbcVNqQdjL8xqPu436EH0vMK9TiGrjpOl70dk25zoDTmemEDWfQtP8Oi/AgigxchtC4e1gvPCK4doSIKoDsGl3NA5RYs6OBIiaHwhRnvIRpRtxU2pL2MsLGo97PvUhGqIWdApR8zlp+l50zp9znQGnM1OIWkihaWGdF2FBlBh5PkLhXdR44RXDzU+AqEWBTbuTcYgSc3YiQNTCQIjylI8o3Yib0vyEvdzZeNwLqQ/RENXZKUQt5KTpe9G5cM51BpzOTCGqi0JTV50XY0GUGHkhQuFd3HjhFcMtTICoxYFNewnjECXmXIIAUV2BEOUpH1G6ETelhQl7eUnjcXdRH6IhChm31JlirUkO5Loy1nYJBxqXQvpTkuTxaz4eEtUNmagsjyVdnGD0Uk50dnWis9ucY8kMx5Kl9RjSXecehGOJjHjDLUVAmZ4OUKYbIe7IeNxdSfkuOIibke96u3HHRUUKSQ/80bGwdA1nz1j3Ydqv+XQn5aN7Da7J9azJxf6QUZBY6wl1oYfTe4GlnQCjF53dc64z4HRmCuC9FLh769yHdS8gRl6aUID6Gi+8YrjuhHuBvsDm1c/4vYCYsx/hXqA38F7AUz6idCNuSt0Je7m/8bh7qQ/R9wL9nUJULydN34vO3jnXGXA6M4WoAQpNy+g8kAVRYuRehMI7yHjhFcP1JkDUIGDTHmwcosScgwkQtQwQojzlI0o34qbUm7CXlzUe9wD1IRqilnUKUQOcNH0vOpfJuc6A05kpRC2n0DRE5+VZECVGHkAovCsYL7xiuGUIELUCsGmvaByixJwrEiBqCBCiPOUjSjfiprQMYS8PNR73cupDNEQNdQpRyzlp+l50Dsm5zoDTmSlEraTQtLLOq7AgSoy8HKHwrmq88MaGI0DUqsCmvZpxiBJzrkaAqJWBEOUpH1G68WdTIuzl1Y3HvZL6EA1RyLilzhRrTXIg15Wxtks60LgG0p+SJI9f8/GQqDWRicryWLKSE4xew4nOlZ3oXHPOsWSGY8laegwZpvNwwrFERrzh1iCgzNoOUGZNQtzrGI97ZVK+13UQNyPf69mNOy4qUkiG44+OhbVqOHvGug/Tfs1nGCkfw2pwTW7tmlzsDxkFiXU9Ql0Y7vReYC0nwOhF57Cc6ww4nZkC+PoK3CN0Hsm6FxAjr0UoQBsYL7xiuGGEe4ENgM1rQ+P3AmLODQn3AiOA9wKe8hGlG3FTGkbYyxsZj3t99SH6XmAjpxC1vpOm70XniJzrDDidmULUxgpNm+i8KQuixMjrEwrvZsYLrxhuBAGiNgM27VHGIUrMOYoAUZsAIcpTPqJ0I25KIwh7eXPjcW+sPkRD1OZOIWpjJ03fi85Ncq4z4HRmClFbKDSN1nlLFkSJkTcmFN4xxguvGG4TAkSNATbtscYhSsw5lgBRo4EQ5SkfUboRN6VNCHt5nPG4t1AfoiFqnFOI2sJJ0/eic3TOdQaczkwharxC01Y6b82CKDHyFoTCu43xwiuGG02AqG2ATXtb4xAl5tyWAFFbASHKUz6idCNuSqMJe3k743GPVx+iIQoZt9SZYq1JDuS6MtZ2KQcat0f6U5Lk8Ws+HhK1AzJRWR5LxjvB6O2d6NzKic4dSDoDTmemx5Id9Riyk847E44lMuINtz0BZXZxgDI7EOLe1XjcW5HyvZuDuBn53t1u3HFRkUKyM/7oWNixhrNnrPsw7dd8diLlY6caXJPbpSYX+0NGQWLdnVAXdnZ6L7CjE2D0onOnnOsMOJ2ZAvgeCtx76jyBdS8gRt6RUID2Ml54xXA7Ee4F9gI2r72N3wuIOfcm3AvsCbwX8JSPKN2Im9JOhL28j/G491Afou8F9nEKUXs4afpedO6Zc50BpzNTiPqPQtO+Ou/Hgigx8h6Ewru/8cIrhtuTAFH7A5v2ROMQJeacSICofYEQ5SkfUboRN6U9CXt5kvG4/6M+REPUJKcQ9R8nTd+Lzn1zrjPgdGYKUQcoNB2o80EsiBIj/4dQeA82XnjFcPsSIOpgYNM+xDhEiTkPIUDUgUCI8pSPKN2Im9K+hL18qPG4D1AfoiHqUKcQdYCTpu9F54E51xlwOjOFqMMUmg7X+QgWRImRDyAU3iONF14x3IEEiDoS2LSPMg5RYs6jCBB1OBCiPOUjSjfipnQgYS8fbTzuw9SHaIhCxi11plhrkgO5roy17eZA4zFIf0qSPH7Nx0OijkUmKstjyWFOMPoYJzoPd6Lz2DnHkhmOJcfpMeR4nU8gHEtkxBvuGALKnOgAZY4lxH2S8bgPJ+X7ZAdxM/J9it2446IiheQE/NGxcFwNZ89Y92Har/kcT8rH8TW4JndiTS72h4yCxHoKoS6c4PRe4DgnwOhF5/E51xlwOjMF8FMVuE/TeTLrXkCMfByhAJ1uvPCK4Y4n3AucDmxeZxi/FxBznkG4FzgNeC/gKR9RuhE3peMJe/lM43Gfqj5E3wuc6RSiTnXS9L3oPC3nOgNOZ6YQdZZC09k6n8OCKDHyqYTCe67xwiuGO40AUecCm/YU4xAl5pxCgKizgRDlKR9RuhE3pdMIe/k843GfpT5EQ9R5TiHqLCdN34vOs3OuM+B0ZgpR5ys0XaDzhSyIEiOfRSi8FxkvvGK4swkQdRGwaV9sHKLEnBcTIOoCIER5ykeUbsRN6WzCXr7EeNznqw/REHWJU4g630nT96LzgpzrDDidmULUpQpNU3W+jAVRYuTzCYX3cuOFVwx3AQGiLgc27SuMQ5SY8woCRE0FQpSnfETpRtyULiDs5SuNx32p+hANUci4pc4Ua01yINeVsbZLO9B4FdKfkiSPX/PxkKirkYnK8lhyqROMvsqJzqlOdF4951gyw7HkGj2GTNP5WsKxREa84a4ioMx1DlDmakLc1xuPeyop3zc4iJuR7xvtxh0XFSkk1+KPjoVrajh7xroP037NZxopH9NqcE3uuppc7A8ZBYn1RkJduNbpvcA1ToDRi85pOdcZcDozBfCbFLhv1vkW1r2AGPkaQgG61XjhFcNNI9wL3ApsXrcZvxcQc95GuBe4GXgv4CkfUboRN6VphL18u/G4b1Ifou8FbncKUTc5afpedN6cc50BpzNTiLpDoelOne9iQZQY+SZC4b3beOEVw91MgKi7gU37HuMQJea8hwBRdwIhylM+onQjbko3E/byvcbjvkN9iIaoe51C1B1Omr4XnXfmXGfA6cwUou5TaLpf5wdYECVGvoNQeB80XnjFcHcSIOpBYNN+yDhEiTkfIkDU/UCI8pSPKN2Im9KdhL38sPG471MfoiHqYacQdZ+Tpu9F5/051xlwOjOFqEcUmh7V+TEWRImR7yMU3seNF14x3P0EiHoc2LSfMA5RYs4nCBD1KBCiPOUjSjfipnQ/YS8/aTzuR9SHaIhCxi11plhrkgO5roy17e5A41NIf0qSPH7Nx0OinkYmKstjySNOMPopJzofdaLz6TnHkhmOJc/oMeRZnZ8jHEtkxBvuKQLKPO8AZZ4mxP2C8bgfJeX7vw7iZuT7Rbtxx0VFCslz+KNj4Zkazp6x7sO0X/N5lpSPZ2twTe75mlzsDxkFifVFQl14zum9wDNOgNGLzmdzrjPgdGYK4C8pcL+s8yusewEx8jOEAvSq8cIrhnuWcC/wKrB5vWb8XkDM+RrhXuBl4L2Ap3xE6UbclJ4l7OXXjcf9kvoQfS/wulOIeslJ0/ei8+Wc6ww4nZlC1BsKTW/q/BYLosTILxEK79vGC68Y7mUCRL0NbNrvGIcoMec7BIh6EwhRnvIRpRtxU3qZsJffNR73G+pDNES96xSi3nDS9L3ofDPnOgNOZ6YQ9Z5C0/s6f8CCKDHyG4TC+6HxwiuGe5MAUR8Cm/ZHxiFKzPkRAaLeB0KUp3xE6UbclN4k7OWPjcf9nvoQDVEfO4Wo95w0fS8638+5zoDTmSlEfaLQ9KnOn7EgSoz8HqHwfm688Irh3idA1OfApv2FcYgSc35BgKhPgRDlKR9RuhE3pfcJe/lL43F/oj5EQxQybqkzxVqTHMh1ZaxtDwcav0L6U5Lk8Ws+HhL1NTJRWR5LPnGC0V850fmpE51fzzmWzHAs+UaPId/q/B3hWCIj3nBfEVDmewco8zUh7h+Mx/0pKd8/Ooibke+f7MYdFxUpJN/hj46Fb2o4e8a6D9N+zedbUj6+rcE1ue9rcrE/ZBQk1p8IdeE7p/cC3zgBRi86v825zoDTmSmA/6zA/YvO01n3AmLkbwgF6FfjhVcM9y3hXuBXYPP6zfi9gJjzN8K9wC/AewFP+YjSjbgpfUvYy78bj/tn9SH6XuB3pxD1s5Om70XnLznXGXA6M4WoP4rQpJuuoha/8HFAYuSfCYW3stZ24RXD/UKAqGTcadewqtY2RIk5RSMaogIu7npP+YjSjbgp/ULYy9XG45ZiKblBQxQy7iwh6g8nTd+LzlCbb50BpzNTiKrRzVarcx0LosTIfxAKbxPjhTeuZrV4iGoCbNpNjUOUmLMpAaJqgRDlKR9RuhE3pVCLz3Mz43HXqA/RENXMKUTVOGn6XnTW5lxnwOnMFKKa62ZroXNLFkSJkWsIhXcu44VXDFdLgKi5gE27lXGIEnO2IkBUCyBEecpHlG7ETamWsJdbG4+7ufoQDVHIuKXOFGtNciDXlbG2PR1onBvpT0mSx6/5eEhUG2SisjyWNHeC0XM70dnCic42JJ0BpzPTY0lb3WztdG5POJbIiDfc3ASUmccByrQhxD2v8bhbkPI9n4O4Gfme327ccVGRQtIef3QstK3l7BnrPkz7NZ92pHy0q8U1uXlqc7E/ZBQk1vkJdaG903uBtk6A0YvOdjnXGXA6MwXwBXSzddC5I+teQIzcllCAFjReeMVw7Qj3AgsCm9dCxu8FxJwLEe4FOgDvBTzlI0o34qbUjrCXFzYe9wLqQ/S9wMJOIWoBJ03fi84OOdcZcDozhahFdLMtqnMnFkSJkRcgFN7OxguvGK4DAaI6A5t2F+MQJebsQoCoRYEQ5SkfUboRN6UOhL3c1Xjci6gP0RDV1SlELeKk6XvRuWjOdQaczkwhajHdbIvrvAQLosTIixAK75LGC68YblECRC0JbNpLGYcoMedSBIhaHAhRnvIRpRtxU1qUsJe7GY97MfUhGqK6OYWoxZw0fS86F8+5zoDTmSlELa2brbvOPVgQJUZejFB4exovvGK4xQkQ1RPYtCPjECXmjAgQ1R0IUZ7yEaUbcVNanLCXC8bjXlp9iIYoZNxSZ4q1JjmQ68pY28iBxnqkPyVJHr/m4yFRvZCJyvJYsrQTjK53orO7E529SDoDTmemx5Leutn66NyXcCyREW+4egLK9HOAMr0Icfc3Hnd3Ur4HOIibke9l7MYdFxUpJH3xR8dC71rOnrHuw7Rf8+lDykefWlyT61ebi/0hoyCxLkOoC32d3gv0dgKMXnT2ybnOgNOZKYAP1M02SOfBrHsBMXJvQgFa1njhFcP1IdwLLAtsXssZvxcQcy5HuBcYBLwX8JSPKN2Im1Ifwl4eYjzugepD9L3AEKcQNdBJ0/eic1DOdQaczkwhanndbCvovCILosTIAwmFd6jxwiuGG0SAqKHApr2ScYgSc65EgKgVgBDlKR9RuhE3pUGEvbyy8biXVx+iIWplpxC1vJOm70XnCjnXGXA6M4WoVXSzrarzaiyIEiMvTyi8qxsvvGK4FQgQtTqwaa9hHKLEnGsQIGpVIER5ykeUbsRNaQXCXl7TeNyrqA/RELWmU4haxUnT96Jz1ZzrDDidmULUWrrZhuk8nAVRYuRVCIV3beOFVwy3KgGi1gY27XWMQ5SYcx0CRA0DQpSnfETpRtyUViXs5XWNx72W+hANUci4pc4Ua01yINeVsbYFBxrXQ/pTkuTxaz4eErU+MlFZHkvWcoLR6znROcyJzvVJOgNOZ6bHkhG62UbqvAHhWCIj3nDrEVBmQwcosz4h7o2Mxz2MlO+NHcTNyPcmduOOi4oUkg3wR8fCiFrOnrHuw7Rf8xlJysfIWlyT27A2F/tDRkFi3YRQFzZwei8wwgkwetE5Muc6A05npgC+qW62zXQexboXECOPIBSgzY0XXjHcSMK9wObA5rWF8XsBMecWhHuBzYD3Ap7yEaUbcVMaSdjLo43Hvan6EH0vMNopRG3qpOl70blZznUGnM5MIWpL3WxjdB7Lgigx8qaEwjvOeOEVw21GgKhxwKY93jhEiTnHEyBqDBCiPOUjSjfiprQZYS9vZTzuLdWHaIjayilEbemk6XvROSbnOgNOZ6YQtbVutm103pYFUWLkLQmFdzvjhVcMN4YAUdsBm/b2xiFKzLk9AaK2AUKUp3xE6UbclMYQ9vIOxuPeWn2IhqgdnELU1k6avhed2+RcZ8DpzBSidtTNtpPOO7MgSoy8NaHw7mK88IrhtiFA1C7Apr2rcYgSc+5KgKidgBDlKR9RuhE3pW0Ie3k343HvqD5EQxQybqkzxVqTHMh1ZaxtvQONuyP9KUny+DUfD4naA5moLI8lOzrB6N2d6NzJic49SDoDTmemx5I9dbNN0HkvwrFERrzhdiegzN4OUGYPQtz7GI97J1K+/+Mgbka+97Ubd1xUpJDshT86Fvas5ewZ6z5M+zWfCaR8TKjFNbm9a3OxP2QUJNZ9CXVhL6f3Ans6AUYvOifkXGfA6cwUwPfTzba/zhNZ9wJi5D0JBWiS8cIrhptAuBeYBGxeBxi/FxBzHkC4F9gfeC/gKR9RuhE3pQmEvXyg8bj3Ux+i7wUOdApR+zlp+l507p9znQGnM1OIOkg328E6H8KCKDHyfoTCe6jxwiuG258AUYcCm/ZhxiFKzHkYAaIOBkKUp3xE6UbclPYn7OXDjcd9kPoQDVGHO4Wog5w0fS86D865zoDTmSlEHaGb7Uidj2JBlBj5IELhPdp44RXDHUyAqKOBTfsY4xAl5jyGAFFHAiHKUz6idCNuSgcT9vKxxuM+Qn2IhqhjnULUEU6avhedR+ZcZ8DpzBSijtPNdrzOJ7AgSox8BKHwnmi88IrhjiRA1InApn2ScYgSc55EgKjjgRDlKR9RuhE3pSMJe/lk43Efpz5EQxQybqkzxVqTHMh1ZaxtLwcaT0H6U5Lk8Ws+HhJ1KjJRWR5LjnOC0ac40Xm8E52nknQGnM5MjyWn6WabrPPphGOJjHjDnUJAmTMcoMyphLjPNB738aR8n+Ugbka+z7Ybd1xUpJCcjj86Fk6r5ewZ6z5M+zWfyaR8TK7FNbkzanOxP2QUJNazCXXhdKf3Aqc5AUYvOifnXGfA6cwUwM/RzXauzlNY9wJi5NMIBeg844VXDDeZcC9wHrB5nW/8XkDMeT7hXuBc4L2Ap3xE6UbclCYT9vIFxuM+R32Ivhe4wClEneOk6XvReW7OdQaczkwh6kLdbBfpfDELosTI5xAK7yXGC68Y7lwCRF0CbNqXGocoMeelBIi6CAhRnvIRpRtxUzqXsJenGo/7QvUhGqKmOoWoC500fS86L8q5zoDTmSlEXaab7XKdr2BBlBj5QkLhvdJ44RXDXUSAqCuBTfsq4xAl5ryKAFGXAyHKUz6idCNuShcR9vLVxuO+TH2IhqirnULUZU6avhedl+dcZ8DpzBSirtHNNk3na1kQJUa+jFB4rzNeeMVwlxMg6jpg077eOESJOa8nQNQ0IER5ykeUbsRN6XLCXr7BeNzXqA/REIWMW+pMsdYkB3JdGWvb24HGG5H+lCR5/JqPh0TdhExUlseSa5xg9I1OdE5zovMmks6A05npseRm3Wy36Hwr4VgiI95wNxJQ5jYHKHMTIe7bjcc9jZTvOxzEzcj3nXbjjouKFJJb8UfHws21nD1j3Ydpv+ZzCykft9TimtxttbnYHzIKEuudhLpwq9N7gZudAKMXnbfkXGfA6cwUwO/SzXa3zvew7gXEyDcTCtC9xguvGO4Wwr3AvcDmdZ/xewEx532Ee4G7gfcCnvIRpRtxU7qFsJfvNx73XepD9L3A/U4h6i4nTd+LzrtzrjPgdGYKUQ/oZntQ54dYECVGvotQeB82XnjFcHcTIOphYNN+xDhEiTkfIUDUg0CI8pSPKN2Im9LdhL38qPG4H1AfoiHqUacQ9YCTpu9F54M51xlwOjOFqMd0sz2u8xMsiBIjP0AovE8aL7xiuAcJEPUksGk/ZRyixJxPESDqcSBEecpHlG7ETelBwl5+2njcj6kP0RD1tFOIesxJ0/ei8/Gc6ww4nZlC1DO62Z7V+TkWRImRHyMU3ueNF14x3OMEiHoe2LRfMA5RYs4XCBD1LBCiPOUjSjfipvQ4YS//13jcz6gP0RCFjFvqTLHWJAdyXRlr28eBxheR/pQkefyaj4dEvYRMVJbHkmecYPSLTnQ+60TnSySdAacz02PJy7rZXtH5VcKxREa84V4koMxrDlDmJULcrxuP+1lSvt9wEDcj32/ajTsuKlJIXsUfHQsv13L2jHUfpv2azyukfLxSi2tyr9XmYn/IKEisbxLqwqtO7wVedgKMXnS+knOdAaczUwB/Szfb2zq/w7oXECO/TChA7xovvGK4Vwj3Au8Cm9d7xu8FxJzvEe4F3gbeC3jKR5RuxE3pFcJeft943G+pD9H3Au87hai3nDR9LzrfzrnOgNOZKUR9oJvtQ50/YkGUGPktQuH92HjhFcO9TYCoj4FN+xPjECXm/IQAUR8CIcpTPqJ0I25KbxP28qfG4/5AfYiGqE+dQtQHTpq+F50f5lxnwOnMFKI+0832uc5fsCBKjPwBofB+abzwiuE+JEDUl8Cm/ZVxiBJzfkWAqM+BEOUpH1G6ETelDwl7+WvjcX+mPkRD1NdOIeozJ03fi87Pc64z4HRmClHf6Gb7VufvWBAlRv6MUHi/N154xXCfEyDqe2DT/sE4RIk5fyBA1LdAiPKUjyjdiJvS54S9/KPxuL9RH6IhChm31JlirUkO5Loy1ravA40/If0pSfL4NR8PifoZmagsjyXfOMHon5zo/NaJzp9JOgNOZ6bHkl90s03X+VfCsURGvOF+IqDMbw5Q5mdC3L8bj/tbUr7/cBA3I9+hzmzccVGRQvIr/uhY+KWWs2es+zDt13ymk/IxvRbX5H6rzcX+kFGQWEUjui786vRe4BcnwOhF5/Sc6ww4nZkCeEXdn3OlzlV1+IWPAxIj/0IAk2rjhVcMN51wL5CMO+0a1tTZhImiPjGnaETfC1Ti4q73lI8o3Yib0nTCXq41HneF+hB9L4CMO0uIqqjz0fS96KzMuc6A05kpRNUpNDXRuSkLosTIFYRTXDPjhVcMF7/Az20GbNrNjUOUmLM5AaKaACHKUz6idCNuSpWEvdzCeNx16kM0RLVwClF1Tpq+F51Ncq4z4HRmClEtFZrm0rkVC6LEyHWEwtvaeOEVwzUhQFRrYNOe2zhEiTnnJkDUXECI8pSPKN2Im1ITwl5uYzzulupDNES1cQpRLZ00fS8658q5zoDTmSlEtVVoaqdzexZEiZFbEgrvPMYLrxhuLgJEzQNs2vMahygx57wEiGoHhChP+YjSjbgpzUXYy/MZj7ut+hANUci4pc4Ua01yINeVsbb9HGicH+lPSZLHr/l4SNQCyERleSxp6wSj53eis50TnQvMOZbMcCzpoMeQjjovSDiWyIg33PwElFnIAcosQIh7YeNxtyPlexEHcTPyvajxr/lIIVkQf3QsdKjj7BnrPkz7NZ+OpHx0rMM1uYXqcrE/ZBQk1kUJdWFBp/cCHZwAoxedHXOuM+B0ZgrgnRS4O+vchXUvIEbuQChAXY0XXjFcR8K9QFdg81rM+L2AmHMxwr1AZ+C9gKd8ROlG3JQ6Evby4sbj7qQ+RN8LLO4Uojo5afpedHbOuc6A05kpRC2h0LSkzkuxIEqM3IlQeLsZL7xiuM4EiOoGbNpLG4coMefSBIhaEghRnvIRpRtxU+pM2Mvdjce9hPoQDVHdnULUEk6avhedS+ZcZ8DpzBSieig09dQ5YkGUGHkJQuEtGC+8YrglCRBVADbteuMQJeasJ0BUTyBEecpHlG7ETWlJwl7uZTzuHupDNET1cgpRPZw0fS86e+ZcZ8DpzBSieis09dG5LwuixMg9CIW3n/HCK4brSYCofsCm3d84RIk5+xMgqg8QojzlI0o34qbUk7CXBxiPu7f6EA1RyLilzhRrTXIg15Wxtv0daFwG6U9Jksev+XhI1EBkorI8lvR2gtHLONHZx4nOgXOOJTMcSwbpMWSwzssSjiUy4g23DAFllnOAMgMJcQ8xHncfUr6XdxA3I98r2I07LipSSJbFHx0Lg+o4e8a6D9N+zWcwKR+D63BNbrm6XOwPGQWJdQVCXVjW6b3AICfA6EXn4JzrDDidmQL4igrcQ3VeiXUvIEYeRChAKxsvvGK4wYR7gZWBzWsV4/cCYs5VCPcCQ4H3Ap7yEaUbcVMaTNjLqxqPe0X1IfpeYFWnELWik6bvRefQnOsMOJ2ZQtRqCk2r67wGC6LEyCsSCu+axguvGG4oAaLWBDbttYxDlJhzLQJErQ6EKE/5iNKNuCkNJezlYcbjXk19iIaoYU4hajUnTd+LztVzrjPgdGYKUcMVmtbWeR0WRImRVyMU3nWNF14x3OoEiFoX2LTXMw5RYs71CBC1NhCiPOUjSjfiprQ6YS+vbzzu4epDNESt7xSihjtp+l50rp1znQGnM1OIGqHQNFLnDVgQJUYeTii8GxovvGK4tQkQtSGwaW9kHKLEnBsRIGokEKI85SNKN+KmtDZhL29sPO4R6kM0RCHjljpTrDXJgVxXxtoOcKBxE6Q/JUkev+bjIVGbIhOV5bFkhBOM3sSJzpFOdG4651gyw7FkMz2GjNJ5c8KxREa84TYhoMwWDlBmU0Lco43HPZKU7y0dxM3I9xi7ccdFRQrJ5vijY2GzOs6ese7DtF/zGUXKx6g6XJPboi4X+0NGQWIdQ6gLmzu9F9jMCTB60Tkq5zoDTmemAD5WgXuczuNZ9wJi5M0IBWgr44VXDDeKcC+wFbB5bW38XkDMuTXhXmAc8F7AUz6idCNuSqMIe3kb43GPVR+i7wW2cQpRY500fS86x+VcZ8DpzBSitlVo2k7n7VkQJUYeSyi8OxgvvGK4cQSI2gHYtHc0DlFizh0JELUdEKI85SNKN+KmNI6wl3cyHve26kM0RO3kFKK2ddL0vejcLuc6A05nphC1s0LTLjrvyoIoMfK2hMK7m/HCK4bbjgBRuwGb9u7GIUrMuTsBonYBQpSnfETpRtyUtiPs5T2Mx72z+hANUXs4haidnTR9Lzp3ybnOgNOZKUTtqdA0Qee9WBAlRt6ZUHj3Nl54xXC7ECBqb2DT3sc4RIk59yFA1AQgRHnKR5RuxE1pF8Je/o/xuPdUH6IhChm31JlirUkO5Loy1nYZBxr3RfpTkuTxaz4eErUfMlFZHkv2dILR+zrROcGJzv3mHEtmOJbsr8eQiTpPIhxLZMQbbl8CyhzgAGX2I8R9oPG4J5DyfZCDuBn5Pthu3HFRkUIyCX90LOxfx9kz1n2Y9ms+E0n5mFiHa3IH1OVif8goSKwHE+rCJKf3Avs7AUYvOifmXGfA6cwUwA9R4D5U58NY9wJi5P0JBehw44VXDDeRcC9wOLB5HWH8XkDMeQThXuBQ4L2Ap3xE6UbclCYS9vKRxuM+RH2Ivhc40ilEHeKk6XvReWjOdQaczkwh6iiFpqN1PoYFUWLkQwiF91jjhVcMdygBoo4FNu3jjEOUmPM4AkQdDYQoT/mI0o24KR1K2MvHG4/7KPUhGqKOdwpRRzlp+l50Hp1znQGnM1OIOkGh6USdT2JBlBj5KELhPdl44RXDHU2AqJOBTfsU4xAl5jyFAFEnAiHKUz6idCNuSkcT9vKpxuM+QX2IhqhTnULUCU6avhedJ+ZcZ8DpzBSiTlNomqzz6SyIEiOfQCi8ZxgvvGK4EwkQdQawaZ9pHKLEnGcSIGoyEKI85SNKN+KmdCJhL59lPO7T1IdoiELGLXWmWGuSA7mujLUd6EDj2Uh/SpI8fs3HQ6LOQSYqy2PJaU4w+mwnOic70XnOnGPJDMeSc/UYMkXn8wjHEhnxhjubgDLnO0CZcwhxX2A87smkfF/oIG5Gvi+yG3dcVKSQnIc/OhbOrePsGes+TPs1nymkfEypwzW58+tysT9kFCTWiwh14Tyn9wLnOgFGLzqn5FxnwOnMFMAvVuC+ROdLWfcCYuRzCQVoqvHCK4abQrgXmApsXpcZvxcQc15GuBe4BHgv4CkfUboRN6UphL18ufG4L1Yfou8FLncKURc7afpedF6Sc50BpzNTiLpCoelKna9iQZQY+WJC4b3aeOEVw11CgKirgU37GuMQJea8hgBRVwIhylM+onQjbkqXEPbyNONxX6E+REPUNKcQdYWTpu9F55U51xlwOjOFqGsVmq7T+XoWRImRryAU3huMF14x3JUEiLoB2LRvNA5RYs4bCRB1HRCiPOUjSjfipnQlYS/fZDzua9WHaIi6ySlEXeuk6XvReV3OdQaczkwh6maFplt0vpUFUWLkawmF9zbjhVcMdx0Bom4DNu3bjUOUmPN2AkTdAoQoT/mI0o24KV1H2Mt3GI/7ZvUhGqKQcUudKdaa5ECuK2NtBznQeCfSn5Ikj1/z8ZCou5CJyvJYcrMTjL7Tic5bnOi8a86xZIZjyd16DLlH53sJxxIZ8Ya7k4Ay9zlAmbsIcd9vPO5bSPl+wEHcjHw/aDfuuKhIIbkXf3Qs3F3H2TPWfZj2az73kPJxTx2uyd1Xl4v9IaMgsT5IqAv3Or0XuNsJMHrReU/OdQaczkwB/CEF7od1foR1LyBGvptQgB41XnjFcPcQ7gUeBTavx4zfC4g5HyPcCzwMvBfwlI8o3Yib0j2Evfy48bgfUh+i7wUedwpRDzlp+l50PpxznQGnM1OIekKh6Umdn2JBlBj5IULhfdp44RXDPUyAqKeBTfsZ4xAl5nyGAFFPAiHKUz6idCNuSg8T9vKzxuN+Qn2IhqhnnULUE06avhedT+ZcZ8DpzBSinlNoel7nF1gQJUZ+glB4/2u88IrhniRA1H+BTftF4xAl5nyRAFHPAyHKUz6idCNuSk8S9vJLxuN+Tn2IhqiXnELUc06avhedz+dcZ8DpzBSiXlZoekXnV1kQJUZ+jlB4XzNeeMVwzxMg6jVg037dOESJOV8nQNQrQIjylI8o3Yib0vOEvfyG8bhfVh+iIQoZt9SZYq1JDuS6MtZ2sAONbyL9KUny+DUfD4l6C5moLI8lLzvB6Ded6HzFic635hxLZjiWvK3HkHd0fpdwLJERb7g3CSjzngOUeYsQ9/vG436FlO8PHMTNyPeHduOOi4oUknfxR8fC23WcPWPdh2m/5vMOKR/v1OGa3Ht1udgfMgoS64eEuvCu03uBt50Aoxed7+RcZ8DpzBTAP1Lg/ljnT1j3AmLktwkF6FPjhVcM9w7hXuBTYPP6zPi9gJjzM8K9wMfAewFP+YjSjbgpvUPYy58bj/sj9SH6XuBzpxD1kZOm70XnxznXGXA6M4WoLxSavtT5KxZEiZE/IhTer40XXjHcxwSI+hrYtL8xDlFizm8IEPUlEKI85SNKN+Km9DFhL39rPO4v1IdoiPrWKUR94aTpe9H5Zc51BpzOTCHqO4Wm73X+gQVRYuQvCIX3R+OFVwz3JQGifgQ27Z+MQ5SY8ycCRH0PhChP+YjSjbgpfUnYyz8bj/s79SEaon52ClHfOWn6XnR+n3OdAaczU4j6RaFpus6/siBKjPwdofD+ZrzwiuG+J0DUb8Cm/btxiBJz/k6AqOlAiPKUjyjdiJvS94S9/IfxuH9RH6IhChm31JlirUkO5Loy1nZZBxpDE6BGSZLHr/l4SFQFMlFZHkt+cYLR0J1A1DndyXpWkNYz4HRmeiypbPLnXKVzdRPSwsfnnyZ4lKlpYh9lKghx1xqPezop33UO4mbku4nduOOiIoVEigf6ayWVTTh7xroP037Np4qUj6omuCZX0yQX+0NGQWJtQqgL1cC4swTwSidg60VnVc51BpzOTAG8qQJ3M52bEwA8DkiMXEkoQC2MF14xnLwqwc9tAWxeLY3CRFGfmLMlHibqm+HirveUjyjdiJtSFWEvz2U87qbqQ/S9wFxOIaqpk6bvRWeznOsMOJ2ZQlQrhabWOs/NgigxclNC4W1jvPCK4ZoRIKoNsGm3NQ5RYs62BIhqDYQoT/mI0o24KTUj7OV2xuNupT5EQ1Q7pxDVyknT96Kzdc51BpzOTCGqvULTPDrPy4IoMXIrQuGdz3jhFcO1JkDUfMCmPb9xiBJzzk+AqHmAEOUpH1G6ETel1oS9vIDxuNurD9EQtYBTiGrvpOl70TlPznUGnM5MIaqDQlNHnRdkQZQYuT2h8C5kvPCK4eYhQNRCwKa9sHGIEnMuTICojkCI8pSPKN2Im9I8hL28iPG4O6gP0RCFjFvqTLHWJAdyXRlru5wDjYsi/SlJ8vg1Hw+J6oRMVJbHkg5OMHpRJzo7OtHZac6xZIZjSWc9hnTRuSvhWCIj3nCLElBmMQco04kQ9+LG4+5IyvcSDuJm5HtJu3HHRUUKSVf80bHQuQlnz1j3Ydqv+XQh5aNLE1yTW6xJLvaHjILEuiShLnR1ei/Q2QkwetHZJec6A05npgC+lAJ3N52XZt0LiJE7EwpQd+OFVwzXhXAv0B3YvHoYvxcQc/Yg3At0A94LeMpHlG7ETakLYS/3NB73UupD9L1AT6cQtZSTpu9FZ7ec6ww4nZlCVKTQVNC5ngVRYuSlCIW3l/HCK4brRoCoXsCm3ds4RIk5exMgqgCEKE/5iNKNuCl1I+zlPsbjjtSHaIjq4xSiIidN34vOQs51BpzOTCGqr0JTP537syBKjBwRCu8A44VXDFcgQNQAYNNexjhEiTmXIUBUPyBEecpHlG7ETalA2MsDjcfdV32IhqiBTiGqr5Om70Vnv5zrDDidmULUIIWmwTovy4IoMXJfQuFdznjhFcP1I0DUcsCmPcQ4RIk5hxAgajAQojzlI0o34qbUj7CXlzce9yD1IRqikHFLnSnWmuRAritjbYc40LgC0p+SJI9f8/GQqBWRicryWDLICUav4ETnYCc6V5xzLJnhWDJUjyEr6bwy4VgiI95wKxBQZhUHKLMiIe5Vjcc9mJTv1RzEzcj36nbjjouKFJKV8UfHwtAmnD1j3Ydpv+azEikfKzXBNblVmuRif8goSKyrE+rCyk7vBYY6AUYvOlfKuc6A05kpgK+hwL2mzmux7gXEyEMJBWiY8cIrhluJcC8wDNi8hhu/FxBzDifcC6wJvBfwlI8o3Yib0kqEvby28bjXUB+i7wXWdgpRazhp+l50rplznQGnM1OIWkehaV2d12NBlBh5DULhXd944RXDrUmAqPWBTXuEcYgSc44gQNS6QIjylI8o3Yib0pqEvTzSeNzrqA/REDXSKUSt46Tpe9G5bs51BpzOTCFqA4WmDXXeiAVRYuR1CIV3Y+OFVwy3LgGiNgY27U2MQ5SYcxMCRG0IhChP+YjSjbgprUvYy5saj3sD9SEaojZ1ClEbOGn6XnRumHOdAaczU4jaTKFplM6bsyBKjLwBofBuYbzwiuE2JEDUFsCmPdo4RIk5RxMgahQQojzlI0o34qa0IWEvb2k87s3Uh2iIQsYtdaZYa5IDua6MtV3egcYxSH9Kkjx+zcdDosYiE5XlsWQzJxg9xonOUU50jp1zLJnhWDJOjyHjdd6KcCyREW+4MQSU2doByowlxL2N8bhHkfK9rYO4Gfnezm7ccVGRQrIV/uhYGNeEs2es+zDt13zGk/IxvgmuyW3dJBf7Q0ZBYt2OUBe2cnovMM4JMHrROT7nOgNOZ6YAvr0C9w4678i6FxAjjyMUoJ2MF14x3HjCvcBOwOa1s/F7ATHnzoR7gR2A9wKe8hGlG3FTGk/Yy7sYj3t79SH6XmAXpxC1vZOm70XnDjnXGXA6M4WoXRWadtN5dxZEiZG3JxTePYwXXjHcDgSI2gPYtPc0DlFizj0JELUbEKI85SNKN+KmtANhL08wHveu6kM0RE1wClG7Omn6XnTulnOdAaczU4jaS6Fpb533YUGUGHlXQuH9j/HCK4bbjQBR/wE27X2NQ5SYc18CRO0NhChP+YjSjbgp7UbYy/sZj3sv9SEaovZzClF7OWn6XnTunXOdAaczU4jaX6Fpos6TWBAlRt6LUHgPMF54xXB7EyDqAGDTPtA4RIk5DyRA1EQgRHnKR5RuxE1pb8JePsh43PurD9EQhYxb6kyx1iQHcl0Za7uCA40HI/0pSfL4NR8PiToEmagsjyX7O8Hog53onOhE5yFzjiUzHEsO1WPIYTofTjiWyIg33MEElDnCAcocQoj7SONxTyTl+ygHcTPyfbTduOOiIoXkcPzRsXBoE86ese7DtF/zOYyUj8Oa4JrcEU1ysT9kFCTWowl14XCn9wKHOgFGLzoPy7nOgNOZKYAfo8B9rM7Hse4FxMiHEgrQ8cYLrxjuMMK9wPHA5nWC8XsBMecJhHuBY4H3Ap7yEaUbcVM6jLCXTzQe9zHqQ/S9wIlOIeoYJ03fi85jc64z4HRmClEnKTSdrPMpLIgSIx9DKLynGi+8YrhjCRB1KrBpn2YcosScpxEg6mQgRHnKR5RuxE3pWMJenmw87pPUh2iImuwUok5y0vS96Dw55zoDTmemEHW6QtMZOp/Jgigx8kmEwnuW8cIrhjuZAFFnAZv22cYhSsx5NgGizgBClKd8ROlG3JROJuzlc4zHfbr6EA1R5ziFqNOdNH0vOs/Iuc6A05kpRJ2r0DRF5/NYECVGPp1QeM83XnjFcGcQIOp8YNO+wDhEiTkvIEDUFCBEecpHlG7ETekMwl6+0Hjc56oP0RCFjFvqTLHWJAdyXRlru6IDjRch/SlJ8vg1Hw+JuhiZqCyPJec6weiLnOic4kTnxXOOJTMcSy7RY8ilOk8lHEtkxBvuIgLKXOYAZS4mxH258binkPJ9hYO4Gfm+0m7ccVGRQjIVf3QsXNKEs2es+zDt13wuJeXj0ia4JndZk1zsDxkFifVKQl2Y6vRe4BInwHh08KHzUifrWUlaz4DTmSmAX6XAfbXO1yRqBHzxhwbbRVI22yWEIjnNeHOoJMV9rfG4Jd+XEuK+zkG+GXFfb/yQIMXuGgKUXtWEs2fSPusGcD4qwX6RfgDcK3F/uaH4N0iB68W0B6SrSV68GnhAmgb04o0OvHg92Is3ZuTFKN0oSJ6vJ/SDmxzk/Bpwzm8i5Rz970pEK/Ivt+R5VxH+/UsVMN/oQ3/yIFURZryPL+4l+Z2hifdrdD536kI3dHivcuPER6F5I5+1bOSzVo181rqRz+Zu5LM2jXzWtpHP2jXyWftGPpunkc/mbeSz+Rr5bP5GPlugkc86NPJZx0Y+W7CRzxZq5LOFG/lskUY+W7SRzzo18lnnRj7r0shnXRv5bLFGPlu8kc+WaOSzJRv5bKlGPuvWyGdLN/JZ90Y+69HIZz0b+Sxq5LNCI5/VN/JZr0Y+693IZ30a+axvI5/1a+Sz/o18NqCRz5Zp5LOBjXw2qJHPBjfy2bKNfLZcI58NaeSz5Rv5bIVGPluxkc+GNvLZSo18tnIjn63SyGerNvLZao18tnojn63RyGdrNvLZWo18NqyRz4bP5LNif15Sm3FT/bnYpyv0d4boz1G6UWiaeC76+f2j/n2bhhkHWH+vpmFGjmGsT/GZhOdHdfqcoZP+en5pLDJa6s8Vfy3l//4bwfciw8j/bp/475PPCPq/S59T/POKsVYTYu3fQL3F59cQnh9FvaMib1ZNmvH5xfWTUZ34rLrks5rEZzWJ9fyg5PcOSfxe6doxfJJcO0ZuGtau0LaM/uKf1VzX4etGYq0IuD3RsuTPL/4ZyT+b5KFCRcmfF0riDCV/fjNqXqJCRcmfV9RTuj6lPqzlrE9UUfL8pJ7aMutTzGVdmc+Kzyr+9UNN4lnJ369NxJj8/eT/Lv73yfeK7N+6zDNLvVsX/h5P8r3i+oqWhUtiS+amYiZz8bml71WWaEyuTTG/1L1fiKKmZdYnBPx+ri2zTsU/uwkjtqj+X+/n4p/fLDD3z1/7uUmJntL1Kd3PTTnrE8nfpxS9l1yP6jJrU6qjrkRjM5LGcn29qKlcXy/qkN/5MfF7yRhD+LsHWb3133qw+Oc3C3/PB8OD1SV6/okL6zjrE/2bGlzKa6W+TOYu6dNkT0n+fl0ixlJfJ88sNSXvFc/BrUP5upXUUG6PJ99L9pTBJbGVY5/Z7SmlaxPCXzkleSzieqY+4vaNqJ5bd3tH5WpmwOn/37m1OWd9/vf8FiXeAj2/d3EfVJY8X4bsl+El7xc/S+735H9bl/g8+ft3J565rv7vVmX++9Lag9ifjdW95O80L9FVWyaucjWutuTPLldTm5RoKa1d1WV0JmvdrDyz6JXkZ+ViKX5W7O21M/n94vNqSn5/c51FRzMNvhxDJPtbHOukGeMbou9HqUbvguhomdCRjCPWP2nGuMv5IRl30Q/lzjUtSj5L1v7aRLzl9tYQSLzR+NJcJf+MZL2Y2T6oncnvF59XU/L72+mczHe5/gOMsb5UX5Kfynm63N5NnpHjZ0z6e6z/F94s6onXetKM6zdX4rOqkt9P9svWJb9fzpvJs27LRLyl64SLt9d4ct/6X19syXl+/9JzTLIeyJrtE8rnK9kXK8rkq6bk9yclnrmf/u9WZf770r/nSe7pYh9onvhvk34o5dLivX9IaE36rbRezF3m91uX/E5Sd6vEZ3OX/F5SV7maWzETrbWh/LqW1qri7x+us6xN54ryz0y+l9Q8s/hrZ/L7rUs0FH//6ISGZhXln1lVRle5epb8rPTv9dok/vzSfJbzXvH3T0joWyxRm2Jdk/4e3/9FjSxqjfVPmjHutonPqsr8fmke25X5/baJ3ymuWeuS30/mq1xNbdPIM5M+Sf5OMp9tS3SWeizJhsn/rsiGNSW/f47O4tc7Sp5d/J3ke8k9Wlqvk/uv3O+3KtFQ/P3zdf4nNiyu3f+Ft5J1oNRbjdU8GaXeKufF5DqVemtmHplZjWxa8jvJ/53Mwb/Z/8Xfv1Ln5P6f3fjb/Mv4y/WINqH8n11uL8j/bjmTPzvp0eTvlHq0+PvXh7/i72y0/iX3a6lHy6158vf/jUeTa9+YRxurf8U/s1y9KcexSf8Wmaocb82VeG4pb1UkYix3lm/yL3SUuwcoVyfL7ani7xf9XM5vTUP5/T1Ef45SjUJUWqOT61tOT+n+qgzl+0pj9ajc8+cuWYvkfz8z9vy3nFz8/cd1/idWSa69jOrEZ576yT/V0+KatQ4z38ezugdLvT8z5k6edZK//6LO5Xi3+N83D+U9VModLRN/xr/pacXffzWhwSrTNnbuL1d3kr//b85myf1XWtMb81Byr5b22Ioyf065vzudlb9PllE3acbnxnPiveL6FPU0Sf5+yWdNE59VT5rxz2mmP1cn/pzks4o6akp+/yv9+X97IvHfFP/71mX+/NqSP38G3WXeS65X6bOqyryXvNP6WP+35IDp5379o6ior7j2NQl9yVGd+Dz5+z/oz6X3MUX/DZlNneP7jS6M7zV6/Og+o8eO7T1mdJuS5yfXLLlOtYR1ivTvLeP49flV4a91Kq5N8s8v5+/i7xW1NuVojUr3SDKnSc8VY6ks+f3S/126h5omekEyxmIcyfeSz/9fz0h8Vq5GFDWW26PNJ83as5qUPKsuxbOKulqX+f262dRV7lmltWZWasf04vMCfk/27jO635jR/QqFAb0L43oX+vzTniyXv2TPllFct2Qdry0TW03J789d8VfMbUu4oKbMnye/16mR36uYyRw/o8x71ZNmfK9cjpL5Lv5+8c9uVkZj8bOkF5I8IaOF/pxcr+SzijpqSn5/YX1AMSfJ/Vn878t5Mbm3S/+scn/+v9nrzcv8vuRnPv2Pir5Nxo7+dzzxn1ny/OR7pdqK3mHsq/r+/fsOqN8y6t1v7JjxY3v3+qd9hf7zx/Tpu+WYhs0djSvEcv7pzy9+Z873dyx698vqOxZVnOfXc//9XfnvWJT7d+6Nfcei9PwgYyX9TM5SxfOM/O9WiefJWDnx5/6vzoa/n0eAnuhLztn/vi9Qql9G8fsC7UtiTfI4Skfxzy799zjldJV+lvx72dLnlPt7v3KcXj0Jv76I88wC+vP/9Xmmp/5v5zV2bFY1lvPvJaO+5H8vWbbGlvs3YbNbY1uGv+/llUs+S9aAVUo+S35HY9WSz5J/376afjaz79QVa/rqk/6KraLkszUSn1WWfLZm4rP/nYECr/81eHc09ztTUa+2ZfQX/6xiL1gy/DWS3qgMM+/HxZ+blPxu6b/pSv5u05LfTfq98h+eW9HI7zZr5Lml3/8p/XcQzcrEXfpzuX+HXvrv9ZI+HaJzlG4UQpl4Ste4diZrUVUm3iYzWYtya1ya54qS3016ojQflTP5c8p5ovTnxmIr/Xet5f6+uNzfJTcr+ayizDNLa1gy3x6Yovh/T+L/min+HwY3dI3Qxg0A","debug_symbols":"tZ3RjuTGsbTfRde+qMzKqsz0qxiGIds6hgBBNmT7AD8Mv/tPZjKiRz6Ynh7u+EbM3Z2JZge7+LGb0aF/fffnH/74z7/84cef/+evf//ut7/713d//OXHn3768S9/+Omvf/r+Hz/+9efjb//13Tj/o/rdb2X95jud19au7bq2+9r6tY1rm72d49rKtb305qU3L7156c1Lb15689Kbl56denls5drqtZ3X1q7turb72vq1jWubvV2X3rr01qW3Dj0dx9au7bq2+9r6tY1rm73d49rKtdVre+ntS29fevvS25fevvT2pefnVn7zXZw6emzP57mPrV3bU2ce231tTx07tnFtz98/fMtzv46fz3O//NjqtZ3X1q7tqRfHdl9bv7ZxbbO3MgYGwXBK5jlMDIZhYdgYDt05ziEw5DXIoTzlHASDYpgYDMPCsK/hfMVOPYfzn+Y5BP7mfIjDFDlflT0IhvO31jlMDIZhYTgfYp+DYwgMeQ3n63P6OQgGxTAxGIZT+bTufJX24BgCQ17D+UrtQTAohlP5dPV8tfZwKNtp5vn6tNOW8wVaw/kK7UEwHDp2+nO+SHswDAvDxuAYAsOpfPrsA4NgUAzzOhZuGHB0/FQ+D4E7hsCQ1xDj+uEQDIoBygHlgPK5JnpwDHkN58vfzmN6vv7tPHDnAuhhYTh37DxM5xroITBkD3qugh4Eg2KYGE7lOIeFYWNwDIEhr+FcBT2cynkOimFiMAyH8hrnsDE4hsBwKK/jcKsODIJBMUwMhmFh2BhOZfn34cLJh3rA81Xg1/Z8OD/+VUmPhoc2O2ajw5ocFzh2c8MbG9HUiIZGXswYFzPkYoZezJgXM+zfx4OCX3/4xy8//HDuwBugHZj72/e//PDzP7777c///Omn33z3v9//9M/6ob//7fufa/uP7385/vV4pB9+/vOxPQT/58effjinf//m8dvj/V89Flfa9evH+hpCibXvauxv15B7+yEnMKAx5xdo+Ldr2E2N88UJja1foLFvPpf1RuPmc4k3+xF5TyPfaGR++37c1DjOjtQ4zlU390PeaNzaj3Wealti2RsFf10hHi/SMd9TOC/Z3pNQ83lJqOV4V8Lfl5gx8pKYoYsSh7G/koj3JbZuHJGtb/biPyWePZFlOIceo9zyYu2ghN+z0xe8UHe5c0z3eUV8HdO35657CvbN+2D7lsJ+vDL9nsKbE9+3K7w9+35CIXE0j8tLu6cQD4Vba3y/OeHluqPgk0fTZ9xRyMFnkXrrFeU+uA8xbikkn0WMW6+HEJ6yQ/Wewngo+L1n8VAYtxTCHs9iyTcr3HPS+ZqMtG9ViFvrImU9XpPjm1/V+x4xeEWje9yDzh6LEuLfLKF274nEQ2Lovb1wo0TcfCIPO33kPYntj724c7LTObA8dMqdBaaaD4Xx7ktzzfclfDkkjisKe++CaNmTy7IZvCyb+Tge8h97sZ48keRF7vE89F2JJ8fj+GDNuNKP95XvXh4+8TN4TfUr+Oivd+LJ5WUuvCby7QtTfi2QT7xcgVPF3O/D55mECa8E7PhU5Zsl3sfwBxL+kNjfLDHv7YXymsaOtfKtEs/W2HMJeUisb5aQe3txXKZCQt5/0/HBEZFvPiKWlFh+T8LXt3ox7SGx4p7EzG+V8MGXlk+7J/E4qB7rpoRR4uYa8eRexPtvPp5KhHIvnlzxfrAXbyTiW724KxE2KbHf9eI8qbwnsfhJyZZ3P6J4tg9r8A3IGvPW8fiVhN1yYqmCIkvnvifBRbaOS+Bv3osvkNjzngQ/CTwk7FslptxaIcebCHxYsnLeO6jJd6Yrl96T2Dyomd8qscfImxJBifkuRXL/F9fpHuHch7x19n4rcVwB35PYb57Hvb2QxY9VJeKehL6RyG9+IjclpuLlvae9/8nssP/my2LyM809338ex5uc/+ZOmHEnLJ/sRHzrTjwRkMEzr/yKQvIJicUPwoaPexLiDwl5T0JEn106czeOq+/13l0ckfns6sT9caWm9zQen00eVzj7psbc1Fg3n0s8Llwj7J5GDl5q5ft3xl7X0Lv7YTwuuecXaMRdjfntGvx87lj17z6X58vlcXde3t4s/I/lok/OofvxScpxY+P9p6Lr6W1P32/ue75/YPTZ50rHzTq4evzgsJsq+3EmO64h864K3z0fs8tNFVd+Uqb+fmzhIxW+Yo/5/cDABypv7hEcc9xVWW9UVnzFvtxX2W9U3hLn/r7cVZmDZ+pjNrurwnfFx3z3VTfHI8hwfGxz9xkpTwzHvO1LVPKuyiMVMTXt5llqC1fj2k+QbPPZp9/7cY/puJWed1Ued8uO+a6KD15yHbPfVXlcdf36dvLnVB7ZF/F9+xnxg085bqfKl6isL1H5kmckd191seZD5cmlz2dU4itUXO+q8MPlY44veUa3VVJI+1/fOP6cyoPTksvuqjwYcNwduvvaTX5QLDruvuqOD8IebBxL76rsx7XUiLsq8jjX6XFlfVdlPp6RPDl7PyfJ49PrY45xV+VxLXUoyl2Vx5uAFc+ump+8C3BRLCOXJ8f5qYbyLrvrk+PzXEOCGnPc09h8w+v7/ViruH7Fe5HnKr9+L7K+ROXuM3r1Hc1zlV+9o9H8CpUn74s+UHnxfdFzlVffF32g8uL7ok/sy32VF98XfWJf7qq8/L7oA5UX3xd9oPLi+6LnKq++L/qMSt5VefV90bPzpT/O/f7+1yIqkfDt58vnKq+eLz+jkndVXjxfPld59Xz5CZV59xi9er58rvLq+fIDlRfPl5/Yl/sqL54vP7Evd1VePl9+oPLi+fIDlRfPl89VXj1ffkYl76p8yfmStviTzxZUxhecLz9QefF8+SmVvKvy2vnyA5UXz5efUXn/fPmRymvnyw9UXjxffqTy2vnyM/tyX+W18+Vn9uWuyqvny49UXjtffqTy2vnyA5UXz5efUsm7Kl9xvgxGy/zJJ5eq+RXny+cqr54vP6OSd1VePF8+V3n1fPkJlSfnyw9UXjxfPld59Xz5gcqL58tP7Mt9lRfPl5/Yl7sqL58vP1B58Xz5gcqL58vnKq+eLz+jkndVvuR8mXw/nnrzs9g0o8baNzWcn8Vm3vss9riDB43jo+l3n4su+YI7rh+pvHbH9QOVF++4fqTy2h3Xj1Reu+P6kcprd1w/pbK+ROVLntH7974+UHnxjuunVOIrVPzuOnrxjutn9uW2yot3XD9See2O60cqr91x/UjltTuuz1VeveP6kcprd1w/UHnxjutHKq/ecX3GkUeo91jQ768if/btWeH9ySn7/aPs6ytY9IHKiyx6rvIqiz5QeZFFH6i8yKIPVF5k0WdU1peofMkzenJWeK7yKos+oxJfofKERR+ovMiiT+zLbZVXWfSByoss+kDlRRZ9oPIii56qvMyiD1ReZNFzlVdZ9IHKExb9/vjT93/68Zf/0167R5UUnhs9yxt+893sjR00Ol5/qzf72BzHznsT3/32fBuXvTlbGM/v2J8ljLWtKsIqA8Vg53D+08Jw1hGePVxnJ2IPgSGv4exg7EEwKIaJwTAsDFBWKCuUFcoTyhPKE8oTyhPKE8oTyhPKE8oTygZlg7JB2aBsUDYoG5QNygZlg/KC8oLygvKC8oLygvKC8oLygvKC8obyhvKG8obyhvKG8obyhvKG8oayQ9mh7FB2KDuUHcoOZYeyQ9mhfJadSnX7SoGoy38r6FXtv2chWNX/nh9pRHVgShcAy9kudZadyvnJ7VkBLGfjx9l6KufnCmcJsJxnu7MFWE7wnz2oci6QrF5h6SJgOT+zPXtQ5TypnT2o1Yxw9qC2TkAnL52qAy6h6gMupSoELqlqBC6tqgQuseoELrUqBS65agW+9IJ6CT0Z0BOBXi3I0qsVWXq1JEuv1mTp1aIsvVqVrRfUS+jVwiy9WpmlV0uz9Gptll4tztKr1Vl6tTxLr9Zn6wX1cBSqfbj1Jo5D9Q+33sSRqAbi1ps4FtVB3HrTqRfU4/EwHg/j8TAeD+PxMB6PWrE+rjbia3JOwSkx1bLtSTgpp8nJONVjnPtSi7eneox5dRXL+YWkKis+rsCutmI5v3BVdcUSfvUVy1neVYXF1WRZjcWS66osrnYW6W5tu0qL9fwyqHS/dl61xXp+1a96iw+qXMXFeq64ai5WRXWxnknO6i6uL7pXebFWWbVX7/a86ou1OqC9urf1KjBWNhhrHaNzVVfFR3UY6/n+qEqMtetzz8c4i4CqxljPPp/qMdbzu9hVZKy7fvd8jPKvGr7PtyVSHd/lZK1vR9Fxe1orvDytJV6e1hovT2uRl6e1ysvTWublaa3zjKvwuDytxuPytCqPtak2L0+r9Lg8rdbj8rRqj8vT6j0uT6v4uDyt5uPytKqPy9PqPi5Pq/y4PK324/K06o/L0+o/1m5C3pen1YBcnlYFcnlaHcjlaZUgl6fVglyeVg1yeVo9yOVpFSGXp9WELD3ty9PqQi5Ptdb56anWOj891Vrnp6da6/z0VGudZxXqT3h6rvP2dC54Ojc8Pdd5e3qu8/Z0Jjw913l7eq7z9tQUnp7rvD0913l7aguenuu8PTWHpxbw1BKenuu8PT3XeXu6FJ5WU355Wl355Wm15Zen1ZdfnlZjfnlanfnlZK/zc6p1Xp7WOi9Pa52Xp7XOy9Ne5+e+9Do/9QrX5WnxujztdV410wlPa5335ZPA01rn5Wmt8/K01/m5V7XOy9Na5+Vpr/NzD2qdl6e1zsvTXufnXvU6P5VrnZentc7L017np0qv8/qNDU9rnZentc7L01rn5Wmv83Pvu83//N3u8z/3pdd5TQZPa52Xp7XOy9Na5+Vpr/NzX3qdn9XaxfOs/4GDXJ7OXud2TvPydNY67+vOdXk6a51L/Zxfns5e52dZd61zrf8lxLg8nb3Oz4rvWuenp7PW+enp7HV+7lWv81O51vnp6ax1bnXBG5ens9f5+Ru1zlf9jyfk8nTWOj89nbXOd10j2+XpPNd5eTp1X55OBaOmglFTwag5wag5wag5wag5wag5wag5wag5wag5wag5wag5wahpYNQ0MGoaGDUNjJoGRk0Do6aBUdPAqGlg1DQwai4wai4wai4wai4wai4wai4wai4wai4wai4wai4wam4wam4wam4wam4wam4wam4wam4wam4wam4wam4wajoYNR2Mmg5GTQejpoNR08Go6WDUdDBqOhg1HYyaAUbNAKNmgFEzwKgZYNQMMGoGGDUDjJoBRs0Ao2aCUTPBqJlg1EwwaiYYNROMmglGzQSjZoJRM8EoG2CUDTDKBhhlA4yyAUbZAKNsgFE2wCgbYJQNMMoEjDIBo0zAKBMwygSMMgGjTMAoEzDKBIwyAaNMwShTMMoUjDIFo0zBKFMwyhSMMgWjTMEoUzDKJhhlE4yyCUbZBKNsglE2wSibYJRNMMomGGUTjDIDo8zAKDMwygyMMgOjzMAoMzDKDIwyA6PMwChbYJQtMMoWGGULjLIFRtkCo2yBUbbAKFtglC0wyjYYZRuMsg1G2QajbINRtsEo22CUbTDKNhhlG4wyB6PMwShzMMocjDIHo8zBKHMwyhyMMgejzMEoCzDKAoyyAKMswCgLMMoCjLIAoyzAKAswygKMsgSjLMEoSzDKEoyyBKMswShLMMoSjLIEoyzBqDXAqDXAqDXAqDXAqDXAqDXAqDXAqDXAqDXAqDXAqCVg1BIwagkYtQSMWgJGLQGjloBRS8CoJWDUEjBqKRi1FIxaCkYtBaOWglFLwailYNRSMGopGLUUjFoTjFoTjFoTjFoTjFoTjFoTjFoTjFoTjFoTjFoTjFoGRi0Do5aBUcvAqGVg1DIwahkYtQyMWgZGLQOj1gKj1gKj1gKj1gKj1gKj1gKj1gKj1gKj1gKj1gKj1gaj1gaj1gaj1gaj1gaj1gaj1gaj1gaj1gaj1gajloNRy8Go5WDUcjBqORi1HIxaDkYtB6OWg1HLwagVYNQKMGoFGLUCjFoBRq0Ao1aAUSvAqBVg1AowaiUYtRKMWglGrQSjVoJRK8GolWDUSjBqJRi1EozaA4zaA4zaA4zaA4zaA4zaA4zaA4zaA4zaA4zaA4zaAkZtAaO2gFFbwKgtYNQWMGoLGLUFjNoCRm0Bo7aCUVvBqK1g1FYwaisYtRWM2gpGbQWjtoJRW8GoPcGoPcGoPcGoPcGoPcGoPcGoPcGoPcGoPcGoPcGobWDUNjBqGxi1DYzaBkZtA6O2gVHbwKhtYNQ2MGovMGovMGovMGovMGovMGovMGovMGovMGovMGovMGpvMGpvMGpvMGpvMGpvMGpvMGpvMGpvMGpvMGpvMGo7GLUdjNoORm0Ho7aDUdvBqO1g1HYwajsYtR2M2gFG7QCjdoBRO8CoHWDUDjBqBxi1A4zaAUbtAKN2glE7waidYNROMGonGLUTjNoJRu0Eo3aCUTvBKB9glA8wygcY5QOM8gFG+QCjfIBRPsAoH2CUDzDKBYxyAaNcwCgXMMoFjHIBo1zAKBcwygWMcgGjXMEoVzDKFYxyBaNcwShXMMoVjHIFo1zBKFcwyicY5ROM8glG+QSjfIJRPsEon2CUTzDKJxjlE4xyA6PcwCg3MMoNjHIDo9zAKDcwyg2McgOj3MAoX2CULzDKFxjlC4zyBUb5AqN8gVG+wChfYJQvMMo3GOUbjPINRvkGo3yDUb7BKN9glG8wyjcY5RuMcgej3MEodzDKHYxyB6PcwSh3MModjHIHo9zBKA8wygOM8gCjPMAoDzDKA4zyAKM8wCgPMMoDjPIEozzBKE8wyhOM8gSjPMEoTzDKE4zyBKM8wagYYFQMMCoGGBUDjIoBRsUAo2KAUTHAqBhgVAwwKgSMCgGjQsCoEDAqBIwKAaNCwKgQMCoEjAoBo0LBqFAwKhSMCgWjQsGoUDAqFIwKBaNCwahQMComGBUTjIoJRsUEo2KCUTHBqJhgVEwwKiYYFROMCgOjwsCoMDAqDIwKA6PCwKgwMCoMjAoDo8LAqFhgVCwwKhYYFQuMigVGxQKjYoFRscCoWGBULDAqNhgVG4yKDUbFBqNig1GxwajYYFRsMCo2GBUbjAoHo8LBqHAwKhyMCgejwsGocDAqHIwKB6PCwagIMCoCjIoAoyLAqAgwKgKMigCjIsCoCDAqAoyKBKMiwahIMCoSjIoEoyLBqEgwKhKMigSjIsGoHGBUDjAqBxiVA4zKAUblAKNygFE5wKgcYFQOMCoFjEoBo1LAqBQwKgWMSgGjUsCoFDAqBYxKAaNSwahUMCoVjEoFo1LBqFQwKhWMSgWjUsGoVDAqJxiVE4zKCUblBKNyglE5waicYFROMConGJUTjEoDo9LAqDQwKg2MSgOj0sCoNDAqDYxKA6PSwKhcYFQuMCoXGJULjMoFRuUCo3KBUbnAqFxgVC4wKjcYlRuMyg1G5QajcoNRucGo3GBUbjAqNxiVG4xKB6PSwah0MCodjEoHo9LBqHQwKh2MSgej0sGoDDAqA4zKAKMywKgMMCoDjMoAozLAqAwwKgOMygSjMsGoTDAqE4zKBKMywahMMCoTjMoEozLBKBkDkDpGUOoYgaljBKeOEaA6RpDqGIGqY2R2YgyGJ8ZgemII4xNDmJ8YwgDFECYohjBCMYQZiiEMUQxhimIIYxRDmKMYyiDFUCYphjJKMZRZiqEMUwxlmmIo4xRDmacYykDFUCYqxmSkYkxmKsZkqGJMpirGZKxiTOYqxmSwYkwmK8ZktGJMZiuGMVwxjOmKYYxXDGO+YhgDFsOYsBjGiMUwZiyGMWQxLOn6GnR9CV1fStfXpOvL6PpadH1tur6crq+g6yvp+h50fQtd30rX96Tr2+j6XnR9b7q+na7voOs76boPuu5C113puk+67kbXfdF133Tdna570HVPuh6DrofQ9VC6HpOuh9H1WHQ9Nl0Pp+sRdD2Srueg6yl0PZWu56TraXQ9F13PTdfT6XoGXU9wUGQAhCIDJJSK3bXrlbtr1yt4165X8q5dlwEcSmXv2vUK37Xrnb7rUYBE6fxdud4BvHK9E3jlekfwyvXO4JXrHcLL/lmQUUSARqkcXrteQbx2XRR0lIriteuVxWvXRQFIqTReu15xvHZdFIyUCuS165XIa9dlApMiE5yUCuW165XKu1yfRtfnoutz0/XpdH0GXZ9J123QdRO6bkrXbdJ1M7pui67bpuvmdN2CrlvS9TXo+hK6vpSur0nXl9H1tej62nR9OV1fQddX0vU96PoWur6Vru9J17fR9b3o+t50fTtd30HXN2na0b123UnTDu+1606adnyvXXfStAN8bbWTphXhu1x30rRCfJfrQZpKkKYSpGkF+S7XgzTtKF+7HqRph/na9SBNO87XridpKkmaVqLvcj1JU0nStEJ9l+tJmkqSppKkaQf7OuQ6SNOO9pXrne0r1zvcV653uq9c73hfud75vt0KpGkn/Mr1jviV1SqkaYX82vVK+bXrFfNr1yvn166rkKYqpGlF/dr1yvq16x32Gx3lJU077leud96vXO/An/TPkqaqpGll/tr1Cv2166qkacX+2vXK/bXrOklTnaRpR/+uaDFp2uG/dn2Sph3/a9cnadoBwHbdSNOOALbrRpp2CLCtNtJUjTRVI00rCHi5bqSpLtJUF2laYcDL9UWadhywXV+kaQcC2/VFmnYksF1fpKlu0rRSgZfrmzTVTZpWMPByfZOmuklT3aRphwPb9U2adjywXXfStAOC7bqTph0RbNedNO2QYLvupGnHBNtqJ00rKHi5HqRpRQUv14M01SBNNUjTigtergdp2oHBdj1I044MtutJmnZosF1P0lSTNK3c4OV6kqaapGlFBy/XkzSdgzSdgzTt+GDH1Adp2gHCcr0ThKt/jTTtDOFqXdK0U4TlescIy/XOEZbrHSQsq6eQphUlbNcrS9iuV5iwXa80Ybs+hTSdQppWoLBdr0Rhu96RwnK9M4XleocKy/VOFZbrHSuU/lnSdCppWsnCdr2ihe36nKRphQvb9UoXXq5P0nRO0rQDhu36JE07YtiuT9K0Q4btupGmHTNs14007aBhu26kaUcN22ojTaeRptNI04obXq4v0nQu0nQu0rQih5frizTt0GG7vkjTjh2264s07eBhu75J07lJ08oeXq5v0nRu0rTih5frmzSdmzSdmzTtCGK77qRphxDbdSdNO4bYrjtp2kHEdt1J044itutOmnYYsa0O0rTiiJfrQZpWIPFyPUjTGaTpDNK0QomX60GadiyxXU/StIOJ7XqSph1NbNeTNJ1JmlY68XI9SdOZpGkFFNv1Sii26zZIUxukaYcUy/VOKZbrHVNcLUaadlCxXO+kYrneUcVyvbOK5XqHFcv1TiuW6x1XLKtNSNMKLLbrlVhs1yuy2K5XZrFdNyVNTUnTii2265VbbNc7uFiud3KxXO/oYrne2UXp7/mQppVebNdtkqaVX2zXK8DYrtskTSvCeLk+SVObpKlN0rRjjO36JE07yNiuG2naUcZ23UjTDjO260aadpyxXTfStAONbbWRprZIU1ukaYUaL9cXaWqLNLVFmlaw8XJ9kaYdbWzXF2na4cZ2fZOmHW9s1zdpaps0rYTj5fomTW2TphVyvFzfpKk5aWpOmnbQsV130rSjju26k6YddmzXnTTtuGO77qRpBx7b9SBNO/LYVgdpWqHHy/UgTSv2eLkepKkFaWpBmlb08XI9SdMOP7brSZp2/LFdT9K0A5DtepKmlqRpZSDb9QpBtutrkKYVg2zXKwfZrq9Bmq5BmnYUslzvLGS53mHI1WKkacchy/XOQ5brHYgs1zsRWa53JLK/DiekaYci+6txQppWLPL6mpyQphWMbNcrGdmuLyVNl5KmFY5s1ysd2a53PLJc73xkud4BydEPQZp2RLJcr4xku74maVopycv1SZquSZpWUPJyfZKma5Kma5KmHZZs14007bhku26kaQcm23UjTTsy2a4badqhyXbdSNOOTbbVizRdizRdizSt6OTl+iJN1yJN1yJNKz55ub5I0w5QtuubNO0IZbu+SdMOUbbrmzRdmzStHOXl+iZN1yZNK0p5ue6k6XLSdDlp2nHKdt1J0w5UtutOmnaksl130rRDle16kKYdq2zXgzTtYOX1NVDStKKVl+tBmla48nI9SNOVpOlK0rQClpfrSZp2xLJdT9K0Q5btepKmHbNs15M03YM0raRlu15Ry3Z9D9K0wpbteqUt2/U9SNM9SNMOXFo/BGnakctyvTOX5XqHLsv1Tl2W6x27LNc7d7lbgTTt5KW3Amm6hTSt8GW7XunL65u4SppW/hLfxSVNt5KmFcG8vo6rpGmHMPsLuUqadgyzv5I7SdMOYpbrlcS8XJ+kaWUxL9cnabonaVpxzMv1SZpuI023kaYdyWzXjTTtUGa7bqRpxzLbdSNNO5jZrhtp2tHMdn2Rph3ObKsXaboXaboXaVoBzcv1RZruRZruRZpWSPNyfZOmHdNs1zdp2kHNdn2Tph3VbNc3abo3aVppzct1J023k6YV2Lxcd9J0O2m6nTTt0Ga77qRpxzbbdSdNO7jZrgdp2tHNdj1I0w5vtutBmnZ8s60O0rQCnJfrQZpWhPNyPUnTnaTpTtK0YpyX60madpCzXU/StKOc19fPSdMOc/YX0Adp6oM0rTzn9R30QZr6IE0r0nl9DX2Qpj5IUx+kacc6y/XOdZbrHews1zvZWa53tLNc72xnud7hznK90527FUjTzneW6x3wLKtdSdOKeLbrlfFs1yvk2a5XyrNddyVNXUnTCnq265X0bNc76lmud9azXO+wZzeyTNK0457t+iRNfZKmlfi8XJ+kqU/StEKfl+tGmrqRpm6kaQc/23UjTTv62a4badrhz3bdSNOOf7brizTtAGi7vkjTjoC21Ys09UWa+iJNKwZ6ub5IU9+kqW/S1Ddp6ps07TBou75J046DtuubNO1AaLu+SVN30rQyoZfrTpq6k6YVC0XlAmnqTpq6k6YdDW3XnTTtcGi7HqRpx0Pb9SBNOyDargdp2hHRdj1I0w6JttVBmlZM9HI9SdMKil6uJ2nqSZp6kqaepKknadpx0XY9SdMOjHbp0CBNOzJarscgTWOQppUabddjkKYxSNMKjrbrMUjTENI0hDTt8OhVdkGadny06y6ENO0AaRdeCGnaEdKuvBDStEOkXXqhpGnHSMvqUNK0gqTteihpWlHSdr2ypO16KGkaSprGJE1jkqYdKC3XO1Hark/StDOl7fokTWOSpjFJ08qVXq4baRpGmla09HLdSNMw0jSMNO14abtupGkHTNt1I007YnrVjJCmHTJt1xdp2jHTdn2Rph00basfDS7xqHCJR4dLPEpc4tHiEo8al3j0uMSjyCUeTS7xqHKJR5dLPMpc4tHmEo86l3j0ucSj0CUejS7xqHSJR6dLPEpd4tHqEo9al3jT6/Km2OVNs8ubapc33S5vyl3etLu8qXd52+9Cmsaj4SUeFS/x6HiJR8lLPFpe4lHzEo+el3gUvcSj6SUeVS/BrhdJlr1Isu1FknUvkux7kWThiyQbXyRZ+SLJzhdJlr5IsvVFkrUvkux9kWTxiySbXyRZ/SLJ7hdJlr9Isv1FkvUvkux/kWQBjCQbYCRZASPJDhhJlsBIsgVGkjUwkuyBkWQRjCSbYCRZBSPJLhhJlsFIsg1GknUwkuyDkWQhjCQbYSRZCSPJThhJlsJIshVGkrUwkuyFkWQxjCSbYSRZDSPJbhhJlsNIsh1GkvUwkuyHkWRBjCQbYiRZESPJjhhJlsRIsiVGkjUxkuyJkWRRjCSbYiRZFSPJrhhJlsVIsi1GknUxkuyLkWRhjCQbYyRZGSPJzhhJlsZIsjVGkrUxkuyNkWRxjCSbYyRZHSPJ7hhJlsdIsj1GkvUxkuyPkWSBjCQbZCRZISPJDhlJlshIskVGkjUykuyRkWSRjCSbZCRZJSPJLhlJlslIsk1GknUykuyT0cFCGR1slNHBShkd7JTRwVIZHWyV0cFaGR3sldHBYhkdbJbRwWoZHeyW0cFyGR1sl9HBehkd7JfRwYIZHWyY0cGKGR3smNHBkhkdbJnRwZoZHeyZ0cGiGR1smtHBqhkd7JrRwbIZHWyb0cG6GR3sm9HBwhkdbJzRwcoZHeyc0cHSGR1sndHB2hkd7J3RweIZHWye0cHqGR3sntHB8hkdbJ/RwfoZHeyf0cECGh1soNHBChod7KDRwRIaHWyh0cEaGh3sodHBIhodbKLRwSoaHeyi0cEyGh1so9HBOhod7KPRwUIaHWyk0cFKGh3spNHBUhodbKXRwVoaHeyl0cFiGh1sptHBahod7KbRwXIaHWyn0cF6Gh3sp9HBghodbKjRwYoaHeyo0cGSGh1sqdHBmhod7KnRwaIaHWyq0cGqGh3sqtHBshodbKvRwboaHeyr0cHCGh1srNHByhod7KxRYWmNCltrVFhbo8LeGhUW16iwuUaF1TUq7K5RYXmNCttrVFhfo8L+GhUW2KiwwUaFFTYq7LBRYYmNCltsVFhjo8IeGxUW2aiwyUaFVTYq7LJRYZmNCttsVFhno8I+GxUW2qiw0UaFlTYq7LRRYamNClttVFhro8JeGxUW26iw2UaF1TYq7LZRYbmNCtttVFhvo8J+GxUW3Kiw4UaFFTcq7LhRYcmNCltuVFhzo8KeGxUW3aiw6UaFVTcq7LpRYdmNCttuVFh3o8K+GxUW3qiw8UaFlTcq7LxRYemNCltvVFh7o8LeGxUW36iw+UaF1Tcq7L5RYfmNCttvVFh/o8L+GxUW4KiwAUeFFTgq7MBRYQmOCltwVFiDo8IeHBUW4aiwCUeFVTgq7MJRYRmOCttwVFiHo8I+HBUW4qiwEUeFlTgq7MRRYSmOCltxVFiLo8JeHFUW46iyGUeV1Tiq7MZRZTmOKttxVFmPo8p+HFUW5KiyIUeVFTmq7MhRZUmOKltyVFmTo8qeHFUW5aiyKUeVVTmq7MpRZVmOKttyVFmXo8q+HFUW5qiyMUeVlTmq7MxRZWmOKltzVFmbo8reHFUW56iyOUeV1Tmq7M5RZXmOKttzVFmfo8r+HFUW6KiyQUeVFTqq7NBRZYmOKlt0VFmjo8oeHVUW6aiySUeVVTqq7NJRZZmOKtt0VFmno8o+HVUW6qiyUUeVlTqq7NRRZamOKlt1VFmro8peHVUW66iyWUeV1Tqq7NZRZbmOKtt1VFmvo8p+HVUW7KiyYUeVFTuq7NhRZcmOKlt2VFmzo8qeHVUW7aiyaUeVVTuq7NpRZdmOKtt2VFm3o8q+HVUW7qiycUeVlTuq7NxRZemOKlt3VFm7o8reHVUW76iyeUeV1TvaudeyunOvZXXnXmPUeD5al7/We5yzV14799pFsHVdco3no2WL+WM8H+2sn9fOveb5vwz53+9/+fH7P/70w9+/++2/zj78f/78J5TfH3/8x//7G/7lj7/8+NNPP/7lD3/75a9/+uHP//zlh7Mo/+9XR37953fncz28+v1vzr783502Hi+m31df/u/OY3GstvPf6kdNjj/u84/1s3n8MefZwS+nWv/M8Xf7/CvlXx2/dfzSv8+2/v8P","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"51":{"source":"use noir_edwards::{ScalarField, bjj::BabyJubJub, Curve, CurveTrait};\nuse super::utils::poseidon2_hash;\n\n// [8]G precalculated\nglobal BASE8_POINT: [Field; 2] = [\n    5299619240641551281634865583518297030282874472190772894086521144482721001553,\n    16950150798460657717958625567821834550301663161624707787222815936182638968203,\n];\n\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n\n#[field(bn254)]\npub fn derive_public_key(private_key: Field) -> [Field; 2] {\n    let private_scalar: ScalarField<64> = ScalarField::from(private_key);\n    let base8_point: BabyJubJub = Curve::new(BASE8_POINT[0], BASE8_POINT[1]);\n    let point = base8_point.mul(private_scalar);\n    [point.x, point.y]\n}\n\n#[field(bn254)]\npub fn derive_shared_key(private_key: Field, public_key_packed: [Field; 2]) -> Field {\n    let private_scalar: ScalarField<64> = ScalarField::from(private_key);\n    let point: BabyJubJub = Curve::new(public_key_packed[0], public_key_packed[1]);\n    let shared_key = point.mul(private_scalar);\n    shared_key.x\n}\n\n#[test]\nfn test_e2e() {\n    let a_key = poseidon2_hash([0]);\n    let a_pubkey = derive_public_key(a_key);\n\n    let b_key = poseidon2_hash([1]);\n    let b_pubkey = derive_public_key(b_key);\n\n    let key_1 = derive_shared_key(a_key, b_pubkey);\n    let key_2 = derive_shared_key(b_key, a_pubkey);\n\n    assert(key_1 == key_2);\n\n    println(f\"Alice public key: {a_pubkey}\");\n    println(f\"Alice private key: {a_key}\");\n    println(\"\");\n    println(f\"Bob public key: {b_pubkey}\");\n    println(\"\");\n    println(f\"Shared Key 1: {key_1}\");\n    println(f\"Shared Key 2: {key_2}\");\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/ecdh.nr"},"52":{"source":"use super::cipher::poseidon_decrypt;\n\n#[export]\npub fn get_key_commitment(key: [Field; 2], salt: Field) -> Field {\n    super::utils::commit(key, salt)\n}\n\n// #[export]\n// fn encrypt_key(master_key: Field, key: Field, nonce: Field) -> Field {\n//     super::cipher::encrypt_single(master_key, key, nonce, 0)\n// }\n\n// #[export]\n// fn decrypt_key(enc_master_key: Field, key: Field, nonce: Field) -> Field {\n//     super::cipher::decrypt_single(enc_master_key, key, nonce, 0)\n// }\n\n#[export]\npub fn decrypt_packet(\n    ciphers: [Field; 510 + 1],\n    key: [Field; 2],\n    nonce: Field,\n) -> [Field; 510] {\n    poseidon_decrypt(ciphers, key, nonce)\n}\n\n#[export]\nfn derive_public_key(private_key: Field) -> [Field; 2] {\n    super::ecdh::derive_public_key(private_key)\n}\n\n#[export]\nfn derive_shared_key(private_key: Field, public_key_packed: [Field; 2]) -> Field {\n    super::ecdh::derive_shared_key(private_key, public_key_packed)\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/exports.nr"},"56":{"source":"mod scalar_field;\nmod test;\npub mod bjj;\n\npub use crate::scalar_field::ScalarField;\nuse std::ops::{Add, Neg, Sub};\n\npub struct Curve<Params> {\n    pub x: Field,\n    pub y: Field,\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### T R A I T S\n// ####################################################################################################################\n// ####################################################################################################################\n\n/// Parametrises a Twisted Edwards curve\ntrait TECurveParameterTrait {\n    fn a() -> Field; // twisted edward curve parameter a\n    fn d() -> Field; // twisted edward curve parameter d\n    fn gen() -> (Field, Field); // generator point x/y coordinates\n}\n\n/// Defines methods that a valid Curve implementation must satisfy\npub trait CurveTrait<Params>: Add + Sub + Eq + Neg + Default {\n    fn new(x: Field, y: Field) -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn dbl(self) -> Self;\n    fn mul<let NScalarSlices: u32>(self, x: ScalarField<NScalarSlices>) -> Self;\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self;\n\n    fn eq(self, x: Self) -> bool {\n        self == x\n    }\n    fn is_zero(self) -> bool {\n        self == Self::zero()\n    }\n\n    fn is_on_curve(self) -> bool;\n    fn assert_is_on_curve(self);\n    fn assert_equal(self, other: Self);\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### C O N S T R A I N E D    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> std::default::Default for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Returns point at infinity\n    ///\n    /// Cost: 0 gates\n    fn default() -> Self {\n        Curve::zero()\n    }\n}\n\nimpl<Params> std::ops::Add for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self + other`\n    ///\n    /// Cost: 7 gates\n    fn add(self, other: Self) -> Self {\n        Curve::add_internal(self, other, Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::ops::Neg for Curve<Params> {\n    /// Negate a point\n    ///\n    /// Cost: usually 0, will cost 1 gate if the `x` coordinate needs to be converted into a witness\n    fn neg(self) -> Self {\n        Curve { x: -self.x, y: self.y }\n    }\n}\n\nimpl<Params> std::ops::Sub for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self - other`\n    ///\n    /// Cost: 7 gates\n    fn sub(self, other: Self) -> Self {\n        Curve::add_internal(self, other.neg(), Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::cmp::Eq for Curve<Params> {\n    /// Compute `self == other`\n    ///\n    /// Cost: 6 gates\n    fn eq(self, other: Self) -> bool {\n        (self.x == other.x) & (self.y == other.y)\n    }\n}\n\nimpl<Params> std::convert::From<(Field, Field)> for Curve<Params> {\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    ///\n    /// Cost: 0 gates\n    fn from((x, y): (Field, Field)) -> Self {\n        Curve { x, y }\n    }\n}\n\nimpl<Params> CurveTrait<Params> for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n\n    /// Construct a new point\n    ///\n    /// If you know the x/y coords form a valid point DO NOT USE THIS METHOD\n    /// This method calls `assert_is_on_curve` which costs 3 gates.\n    /// Instead, directly construct via Curve{x, y} or use from((x, y))\n    ///\n    /// Cost: 3 gates\n    fn new(x: Field, y: Field) -> Self {\n        let result = Curve { x, y };\n        result.assert_is_on_curve();\n        result\n    }\n\n    /// Return the Identity element (point at infinity)\n    ///\n    /// Cost: 0 gates\n    fn zero() -> Self {\n        Curve { x: 0, y: 1 }\n    }\n\n    /// Return the Generator of the group\n    ///\n    /// Cost: 0 gates (assuming Params trait returns values known at compile time!)\n    fn one() -> Self {\n        let (x, y) = Params::gen();\n        Curve { x, y }\n    }\n\n    /// Validate a point is on the curve\n    ///\n    /// cheaper than `is_on_curve` (assert is cheaper than returning a bool)\n    ///\n    /// Cost: 3 gates\n    fn assert_is_on_curve(self) {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        assert(t2 == t3);\n    }\n\n    /// Constrain two points to equal each other\n    ///\n    /// Cheaper than `assert(self == other)` because no need to return a bool\n    ///\n    /// Cost: 0-2 gates (can do these asserts with just copy constraints)\n    fn assert_equal(self, other: Self) {\n        assert(self.x == other.x);\n        assert(self.y == other.y);\n    }\n\n    /// Return a bool that describes whether the point is on the curve\n    ///\n    /// If you don't need to handle the failure case, it is cheaper to call `assert_is_on_curve`\n    ///\n    /// Cost: 5 gates\n    fn is_on_curve(self) -> bool {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        (t2 == t3)\n    }\n\n    /// Compute `self + self`\n    ///\n    /// Cost: 5 gates\n    fn dbl(self) -> Self {\n        Curve::dbl_internal(self, Params::a(), Params::d())\n    }\n\n    /// Compute `self * scalar`\n    ///\n    /// Uses the Straus method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows:\n    ///      1: computing the Straus point lookup table (169 gates)\n    ///      2: 252 point doublings (1260 gates)\n    ///      3: 63 point additions (441 gates)\n    ///      4: 126 table reads with runtime index (252 gates)\n    ///\n    /// Cost: 2122 gates + cost of creating ScalarField (110 gates)\n    fn mul<let NScalarSlices: u32>(self: Self, scalar: ScalarField<NScalarSlices>) -> Self {\n        // define a, d params locally to make code more readable (shouldn't affect performance)\n        let a = Params::a();\n        let d = Params::d();\n\n        // Construct tables of precomputed point coordinates.\n        let (table_x, table_y): ([Field; 16], [Field; 16]) = self.compute_straus_point_table(a, d);\n\n        // Initialize the accumulator with the point that maps to the first (most significant) scalar slice\n        let idx = scalar.base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: table_x[idx], y: table_y[idx] };\n\n        // Execute a double-and-add subroutine\n        // 1. Compute `accumulator = accumulator * 16`\n        // 2. Extract 4-bits from the scalar multiplier and\n        //    use them to retrieve the corresponding point from our point table\n        // Note: this is similar to the \"double and add\" scalar multiplication method, except we use base16 instead of base2!\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            let idx = scalar.base4_slices[i] as u32;\n            let x = table_x[idx];\n            let y = table_y[idx];\n            accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n        }\n\n        // todo fix\n        if (scalar.skew) {\n            accumulator = accumulator - self;\n        }\n        accumulator\n    }\n\n    /// compute `points[0] * scalar[0] + ... + points[N-1] * scalar[N-1]`\n    ///\n    /// Is cheaper than `mul` when processing >1 point due to reduced number of point doublings\n    /// uses the Straus MSM method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows\n    /// PER POINT costs:\n    ///      1: computing the Straus point lookup table (169N gates)\n    ///      2: 63 point additions (441N gates)\n    ///      3: 126 table reads with runtime index (252N gates)\n    ///\n    /// Additional costs:\n    ///      1. 252 point doublings 1260 gates\n    ///\n    /// Cost: 1260 + 862N + cost of creating ScalarField (110N gates)\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self {\n        let a = Params::a();\n        let d = Params::d();\n\n        // Generalized version of `mul` for multiple points.\n        let mut point_tables: [([Field; 16], [Field; 16]); N] = [([0; 16], [0; 16]); N];\n        for j in 0..N {\n            point_tables[j] = points[j].compute_straus_point_table(a, d);\n        }\n\n        let idx = scalars[0].base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: point_tables[0].0[idx], y: point_tables[0].1[idx] };\n        for j in 1..N {\n            let idx = scalars[j].base4_slices[0] as u32;\n            let P = Curve { x: point_tables[j].0[idx], y: point_tables[j].1[idx] };\n            accumulator = accumulator.add_internal(P, a, d);\n        }\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            for j in 0..N {\n                let idx = scalars[j].base4_slices[i] as u32;\n                let x = point_tables[j].0[idx];\n                let y = point_tables[j].1[idx];\n                accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n            }\n        }\n\n        for j in 0..N {\n            if (scalars[j].skew == true) {\n                accumulator = accumulator - points[j];\n            }\n        }\n        accumulator\n    }\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### H E L P E R    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> Curve<Params> {\n\n    /// add two points together\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `add` :(\n    fn add_internal(self, other: Self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let x2 = other.x;\n        let y1 = self.y;\n        let y2 = other.y;\n        let (x, y, lambda) = unsafe { __add_unconstrained(x1, x2, y1, y2, a, d) };\n        let x1x2 = x1 * x2;\n        let x1y2 = x1 * y2;\n        std::as_witness(x1x2);\n        std::as_witness(x1y2);\n        let x_lhs = x * lambda * d + x - x1y2; // equals y1x2\n        let y_lhs = y * lambda * -d + y + x1x2 * a; // equals y1y2\n        let y1x2 = y1 * x2;\n        let y1y2 = y1 * y2;\n        std::as_witness(y1x2);\n        std::as_witness(y1y2);\n        let y1y2x1x2 = y1y2 * x1x2;\n        assert(x_lhs == y1x2);\n        assert(y_lhs == y1y2);\n        assert(y1y2x1x2 == lambda);\n        Self { x, y }\n    }\n\n    /// add a point to itself\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `dbl` :(\n    fn dbl_internal(self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let y1 = self.y;\n        let (x3, y3, _) = unsafe { __add_unconstrained(x1, x1, y1, y1, a, d) };\n        let x1x1a = x1 * x1 * a;\n        std::as_witness(x1x1a);\n        // t1 = a*x_1^2 + y_1^2\n        let t1 = y1 * y1 + x1x1a;\n        std::as_witness(t1);\n        // t3 = y_3 * (2 - a*x_1^2 + y_1^2) + 2*a*x_1^2\n        let t3 = y3 + y3 - t1 * y3 + x1x1a * 2;\n        // t3 == t1 implies y_3 * (2 - a*x_1^2 - y_1^2) + 2*a*x_1^2 == a*x_1^2 + y_1^2\n        // i.e. y_3 = y_1^2 - a*x_1^2 / (2 - a*x_1^2 - y_1^2)\n        assert(t3 == t1);\n        let t4 = x1 * y1;\n        std::as_witness(t4);\n        // x3 * t1 - t4 == t4 implies x_3 * (y_1^2 + a * x_1^2) = 2 * x_1 * y_1\n        // i.e. x_3 = 2 * x_1 * y_1 / (y_1^2 + a * x_1^2)\n        let t2 = x3 * t1 - t4;\n        assert(t2 == t4);\n        Self { x: x3, y: y3 }\n    }\n\n    /// Compute a 4-bit lookup table of point multiples for the Straus windowed scalar multiplication algorithm.\n    ///\n    /// Table contains [0, P, 2P, ..., 15P], which is used in the scalar mul algorithm to minimize the total number of required point additions\n    ///\n    /// It is cheaper to use ([Field; 16], [Field; 16]) than it is ([Curve; 16]).\n    /// This is because the compiler will represent [Curve; 16] in 1 ROM array (vs 2 for [Field; 16], [Field; 16]).\n    /// This means that any index into the ROM array for [Curve; 16] requires an additional arithmetic gate to process.\n    ///\n    ///      For example consider `let P: Curve = table[idx]`\n    ///      `table` will be a ROM array with 32 elements in it.\n    ///      The x-coordinates will be located at `2 * idx`\n    ///      The y-coordinates will be located at `2 * idx + 1`\n    ///      If `idx` is not known at compile time (for Straus it isnt), 2 arithmetic gates are required to evaluate `2 * idx`, `2 * idx + 1`\n    ///      before they can be used as arguments in a memory lookup protocol\n    ///\n    ///      Now consider `let P_x = table_x[idx]; let P_y = table_y[idx]`\n    ///      In this example, `idx` can be directly used as the argument into a memory lookup protocol for both tables.\n    ///\n    ///      For the Barretenberg backend, the cost of a Read-Only memory lookup is 2 gates,\n    ///      so splitting the x/y coordinates into separate tables means that the cost to lookup a point is 4 gates\n    ///      2 extra arithmetic gates would increase the cost by 50%, which we avoid by returning `([Field; 16], [Field; 16])` instead of `([Curve; 16])`\n    ///\n    /// Key cost components are as follows:\n    ///      1: Defining two size-16 lookup tables (2 gates per element, 32 elements = 64 gates)\n    ///      2: 15 point additions (7 * 5 = 105)\n    ///\n    /// Total Cost: 169 gates\n    fn compute_straus_point_table(self, a: Field, d: Field) -> ([Field; 16], [Field; 16]) {\n        let mut table_x: [Field; 16] = [0; 16];\n        let mut table_y: [Field; 16] = [0; 16];\n        table_x[8] = self.x;\n        table_y[8] = self.y;\n        let D = self.dbl_internal(a, d);\n        for i in 1..8 {\n            let Q = Self { x: table_x[7 + i], y: table_y[7 + i] };\n            let V = D.add_internal(Q, a, d);\n            table_x[8 + i] = V.x;\n            table_y[8 + i] = V.y;\n        }\n        for i in 0..8 {\n            table_x[i] = -table_x[15 - i];\n            table_y[i] = table_y[15 - i];\n        }\n        (table_x, table_y)\n    }\n}\n\n/// add points together, return output + lambda ter\nunconstrained fn __add_unconstrained(\n    x1: Field,\n    x2: Field,\n    y1: Field,\n    y2: Field,\n    a: Field,\n    d: Field,\n) -> (Field, Field, Field) {\n    let lambda = y1 * y2 * x1 * x2;\n    let y = (x1 * x2 * a - y1 * y2) / (lambda * d - 1);\n    let x = (x1 * y2 + y1 * x2) / (lambda * d + 1);\n    (x, y, lambda)\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/lib.nr"},"57":{"source":"use std::static_assert;\n\n/// ScalarField represents a scalar multiplier as a sequence of 4-bit slices\n///\n/// There is nuance to ScalarField, because twisted edwards curves generally have prime group orders that easily fit into a Field\n/// We can therefore obtain cheap conversions by simply summing up the bit slices and validate they equal the input scalar\n/// However...when converting arbitrary field elements (i.e. scalars that are multiples of a TE curve group order),\n/// we must perform additional checks when converting into 4-bit slices, as we must validate that the sum of the slices is smaller than the Field modulus (when evaluated over the integers)\n/// This is expensive and we would rather not do it! therefore ScalarField<N> is flexible.\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n///\n/// N.B. ScalarField bit values are not constrained to be smaller than the TE curve group order.\n/// ScalarField is used when performing scalar multiplications, where all operations wrap modulo the curve order\npub global TWO_POW_128: Field = 0x100000000000000000000000000000000;\npub global PLO: Field = 0x2833e84879b9709143e1f593f0000001;\npub global PHI: Field = 0x30644e72e131a029b85045b68181585d;\n\npub struct ScalarField<let N: u32> {\n    pub(crate) base4_slices: [u8; N],\n    pub(crate) skew: bool,\n}\n\nunconstrained fn get_wnaf_slices<let N: u32>(x: Field) -> ([u8; N], bool) {\n    let mut result: [u8; N] = [0; N];\n    let mut nibbles: [u8; N] = to_le_radix_16(x);\n\n    let skew: bool = nibbles[0] & 1 == 0;\n    nibbles[0] += skew as u8;\n    result[N - 1] = (nibbles[0] + 15) / 2;\n    for i in 1..N {\n        let mut nibble: u8 = nibbles[i];\n        result[N - 1 - i] = (nibble + 15) / 2;\n        if (nibble & 1 == 0) {\n            result[N - 1 - i] += 1;\n            result[N - i] -= 8;\n        }\n    }\n    (result, skew)\n}\n\nunconstrained fn from_wnaf_slices<let N: u32>(x: [u8; N], skew: bool) -> Field {\n    let mut result: Field = 0;\n\n    for i in 0..N {\n        result *= 16;\n        result += (x[i] as Field) * 2 - 15;\n    }\n    result -= skew as Field;\n    result\n}\n\nunconstrained fn get_borrow_flag(lhs_lo: Field, rhs_lo: Field) -> bool {\n    lhs_lo.lt(rhs_lo + 1)\n}\n\nunconstrained fn to_le_radix_16<let N: u32>(value: Field) -> [u8; N] {\n    // Round up on odd values of `N` to ensure space for last nibble.\n    let bytes = value.to_le_bytes::<(N + 1) / 2>();\n    let mut result: [u8; N] = [0; N];\n    for index in 0..(N / 2) {\n        result[index * 2] = bytes[index] & 0x0F; // Extract low nibble (bits 0-3)\n        result[index * 2 + 1] = (bytes[index] >> 4); // Extract high nibble (bits 4-7)\n    }\n    if (N & 1) == 1 {\n        let last_nibble = bytes[bytes.len() - 1];\n        // The last byte must have the top 4 bits empty.\n        (last_nibble as Field).assert_max_bit_size::<4>();\n        result[N - 1] = last_nibble;\n    }\n    result\n}\n\nimpl<let N: u32> std::convert::From<Field> for ScalarField<N> {\n\n    /// Construct from a field element\n    ///\n    /// if N >= 64 we perform extra checks to ensure the slice decomposition represents the same integral value as the input\n    /// (e.g. sum of slices != x + modulus)\n    fn from(x: Field) -> Self {\n        // the field elements have 254 bits max, so we do not need to support N > 64\n        static_assert(N <= 64, \"N must be at most 64\");\n        let mut result: Self = ScalarField { base4_slices: [0; N], skew: false };\n        let (slices, skew): ([u8; N], bool) = unsafe { get_wnaf_slices(x) };\n        result.base4_slices = slices;\n        result.skew = skew;\n        if (N < 64) {\n            let mut acc: Field = (slices[0] as Field) * 2 - 15;\n            for i in 1..N {\n                acc *= 16;\n                acc += (slices[i] as Field) * 2 - 15;\n            }\n            assert(acc - skew as Field == x);\n        } else {\n            // TODO: if num bits = 64, validate in sum of the bits is smaller than the Field modulus\n            let mut lo: Field = 0;\n            let mut hi: Field = 0;\n\n            for i in 0..32 {\n                lo *= 16;\n                lo += (slices[32 + i] as Field) * 2 - 15;\n                hi *= 16;\n                hi += (slices[i] as Field) * 2 - 15;\n            }\n\n            lo -= skew as Field;\n            // Validate that the integer represented by (lo, hi) is smaller than the integer represented by (plo, phi)\n\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            // Safety: we assert that the absolute value has less than 128 bits\n            let is_positive: bool = unsafe { get_borrow_flag(lo, TWO_POW_128) };\n\n            let abs_lo = (is_positive as Field) * lo + (1 - is_positive as Field) * (-lo);\n\n            abs_lo.assert_max_bit_size::<128>();\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            let borrow = unsafe { get_borrow_flag(PLO, abs_lo) as Field };\n            // we only need to check the rlo has 128 bits or less if lo is positive. if negative, the lo is already less than PLO\n            let rlo = is_positive as Field * (PLO - lo + borrow * TWO_POW_128 - 1)\n                + (1 - is_positive as Field) * (-lo); // -1 because we are checking a strict <, not <=\n            // is lo is positive, we need to check the hi is less than phi with the borrow flag subtracted\n            // if lo is negative, we have to check that hi * 2^128 < phi * 2^128 + abs_lo + plo\n            // to do this we first make a flag to check that abs_lo + plo is larger than 2^128 or not\n            // if they are larger, we check that hi < phi + 1 and otherwise we check that hi < phi\n            // Safety: we assert the when the flag is positive we have less than 128 bits\n            let threshold_flag: bool = unsafe { get_borrow_flag(abs_lo + PLO, TWO_POW_128) };\n            (threshold_flag as Field * (abs_lo + PLO)).assert_max_bit_size::<128>();\n            let rhi = is_positive as Field * (PHI - hi - borrow)\n                + (1 - is_positive as Field) * (PHI - hi + threshold_flag as Field);\n            // the rlo value would have 128 bits or less if positive and more if negative as the modulus is 254 bits\n            rlo.assert_max_bit_size::<128>();\n            rhi.assert_max_bit_size::<128>();\n        }\n        for i in 0..N {\n            (result.base4_slices[i] as Field).assert_max_bit_size::<4>();\n        }\n        result\n    }\n}\n\nimpl<let N: u32> std::convert::Into<Field> for ScalarField<N> {\n\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    fn into(self: Self) -> Field {\n        let mut acc: Field = 0;\n        for i in 0..N {\n            acc = acc * 16;\n            acc = acc + (self.base4_slices[i] as Field) * 2 - 15;\n        }\n        acc -= self.skew as Field;\n        acc\n    }\n}\n\nimpl<let N: u32> ScalarField<N> {\n\n    pub fn new() -> Self {\n        Self { base4_slices: [0; N], skew: false }\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.base4_slices[idx]\n    }\n}\n\n#[test]\nunconstrained fn test_wnaf() {\n    let result: Field = 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0;\n    let (t0, t1) = get_wnaf_slices::<64>(result);\n    let expected = from_wnaf_slices(t0, t1);\n    assert_eq(result, expected);\n}\n\n#[test]\nfn test_regression_wnaf() {\n    let a = 0x7b;\n    let s: ScalarField<64> = ScalarField::<64>::from(a);\n    let b: Field = ScalarField::<64>::into(s);\n    assert_eq(a, b);\n}\n\n#[test]\nunconstrained fn to_le_radix_16_works_with_odd_N() {\n    let input = 0x0f00;\n    let nibbles: [u8; 3] = to_le_radix_16(input);\n    assert_eq(nibbles, [0x0, 0x0, 0xf]);\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/scalar_field.nr"}}};

export async function derive_shared_key(private_key: Field, public_key_packed: Field[], foreignCallHandler?: ForeignCallHandler): Promise<Field> {
  const program = new Noir(derive_shared_key_circuit);
  const args: InputMap = { private_key, public_key_packed };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field;
}
export type encrypt_packetInputType = {
  key_commit: Field;
  nonce: Field;
  plains: Field[];
  key: Field[];
  salt: Field;
}

export type encrypt_packetReturnType = Field[];
export const encrypt_packet_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"key_commit","type":{"kind":"field"},"visibility":"public"},{"name":"nonce","type":{"kind":"field"},"visibility":"public"},{"name":"plains","type":{"kind":"array","length":510,"type":{"kind":"field"}},"visibility":"private"},{"name":"key","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":511,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use super::utils::poseidon2_hash;\nuse poseidon::poseidon2_permutation;\n\n#[field(bn254)]\nfn compute_pad(key: Field, nonce: Field, counter: u32) -> Field {\n    poseidon2_hash([key, nonce, counter as Field])\n}\n\n#[field(bn254)]\npub fn encrypt_single(plains: Field, key: Field, nonce: Field, counter: u32) -> Field {\n    plains + compute_pad(key, nonce, counter)\n}\n\n#[field(bn254)]\npub fn decrypt_single(ciphers: Field, key: Field, nonce: Field, counter: u32) -> Field {\n    ciphers - compute_pad(key, nonce, counter)\n}\n\n#[field(bn254)]\npub fn encrypt<let N: u32>(plains: [Field; N], key: Field, nonce: Field) -> [Field; N] {\n    plains.mapi(|i, p| encrypt_single(p, key, nonce, i))\n}\n\n#[field(bn254)]\npub fn decrypt<let N: u32>(ciphers: [Field; N], key: Field, nonce: Field) -> [Field; N] {\n    ciphers.mapi(|i, c| decrypt_single(c, key, nonce, i))\n}\n\n#[field(bn254)]\npub fn poseidon_encrypt<let N: u32>(\n    plains: [Field; N],\n    key: [Field; 2],\n    nonce: Field,\n) -> [Field; N + 1] {\n    assert(nonce.lt(0x100000000000000000000000000000000));\n\n    let padded_nonce = nonce + (N as Field) * 0x100000000000000000000000000000000;\n    let mut state: [Field; 4] = [0, key[0], key[1], padded_nonce];\n\n    let state_len = state.len();\n    assert(N >= state_len - 1);\n\n    let mut ciphers: [Field; N + 1] = [0; N + 1];\n\n    for i in 0..(N / (state_len - 1)) {\n        state = poseidon2_permutation(state, state_len);\n\n        for j in 1..state_len {\n            let index = i * (state_len - 1) + j - 1;\n            state[j] += plains[index];\n            ciphers[index] = state[j];\n        }\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    for i in (N - (N % (state_len - 1)))..N {\n        let index = (i % (state_len - 1)) + 1;\n        state[index] += plains[i];\n        ciphers[i] = state[index];\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    ciphers[N] = state[1];\n    ciphers\n}\n\n#[field(bn254)]\npub fn poseidon_decrypt<let N: u32>(\n    ciphers: [Field; N + 1],\n    key: [Field; 2],\n    nonce: Field,\n) -> [Field; N] {\n    assert(nonce.lt(0x100000000000000000000000000000000));\n\n    let padded_nonce = nonce + (N as Field) * 0x100000000000000000000000000000000;\n    let mut state: [Field; 4] = [0, key[0], key[1], padded_nonce];\n\n    let state_len = state.len();\n    assert(N >= state_len - 1);\n\n    let mut plains: [Field; N] = [0; N];\n\n    for i in 0..(N / (state_len - 1)) {\n        state = poseidon2_permutation(state, state_len);\n\n        for j in 1..state_len {\n            let index = i * (state_len - 1) + j - 1;\n            plains[index] = ciphers[index] - state[j];\n            state[j] = ciphers[index];\n        }\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    for i in (N - (N % (state_len - 1)))..N {\n        let index = (i % (state_len - 1)) + 1;\n        plains[i] = ciphers[i] - state[index];\n        state[index] = ciphers[i];\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    assert(ciphers[N] == state[1]);\n    plains\n}\n\n#[test]\nfn test_e2e() {\n    let key = 0x1ff18c97cd54b27391280a1f24cc94ef8c05e421525eb05bd4ded690735bf961;\n    let nonce = 1337;\n\n    let msg = [22405534230753963835153736737; 256]; // \"Hello world!\"\n    let encrypted = encrypt(msg, key, nonce);\n    let new_msg = decrypt(encrypted, key, nonce);\n\n    assert(msg == new_msg);\n\n    println(f\"Key: {key}\");\n    println(f\"nonce: {nonce}\");\n\n    println(f\"Original: {msg}\");\n    println(f\"Encrypted: {encrypted}\");\n    println(f\"Decrypted: {new_msg}\");\n}\n\n#[test]\nfn test_e2e_poseidon() {\n    let key: [Field; 2] = [\n        0x1ff18c97cd54b27391280a1f24cc94ef8c05e421525eb05bd4ded690735bf961,\n        0x1ff18c97cd54b27391280a1f24cc94ef8c05e421525eb05bd4ded690735bf961,\n    ];\n    let nonce = 1337;\n\n    let msg = [22405534230753963835153736737; 1024]; // \"Hello world!\"\n    let encrypted = poseidon_encrypt(msg, key, nonce);\n    let new_msg = poseidon_decrypt(encrypted, key, nonce);\n\n    assert(msg == new_msg);\n\n    println(f\"Key: {key}\");\n    println(f\"nonce: {nonce}\");\n\n    println(f\"Original: {msg}\");\n    println(f\"Encrypted: {encrypted}\");\n    println(f\"Decrypted: {new_msg}\");\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/cipher.nr"},"54":{"source":"use poseidon::{poseidon2::Poseidon2};\n\n#[field(bn254)]\npub fn poseidon2_hash<let N: u32>(value: [Field; N]) -> Field {\n    Poseidon2::hash(value, N)\n}\n\n#[field(bn254)]\npub fn commit<let N: u32>(value: [Field; N], salt: Field) -> Field {\n    poseidon2_hash([poseidon2_hash(value), salt])\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/utils.nr"},"65":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"68":{"source":"use common::{cipher::poseidon_encrypt, utils::commit};\n\n/**\n\nBundle:\n  key_commit: field\n  packets: {encryptedData: bytes, nonce: field, proof: Proof}[]\n\n*/\n\nfn main(\n    key_commit: pub Field,\n    nonce: pub Field,\n    plains: [Field; 510],\n    key: [Field; 2],\n    salt: Field,\n) -> pub [Field; 510 + 1] {\n    assert(key_commit == commit(key, salt));\n    poseidon_encrypt(plains, key, nonce)\n}\n\n#[test]\nfn test_main() {}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/encrypt_packet/src/main.nr"}}};

export async function encrypt_packet(key_commit: Field, nonce: Field, plains: Field[], key: Field[], salt: Field, foreignCallHandler?: ForeignCallHandler): Promise<Field[]> {
  const program = new Noir(encrypt_packet_circuit);
  const args: InputMap = { key_commit, nonce, plains, key, salt };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field[];
}
export type get_key_commitmentInputType = {
  key: Field[];
  salt: Field;
}

export type get_key_commitmentReturnType = Field;
export const get_key_commitment_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"key","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"private"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7VSWw7CIBCkLa1a9ceT7PIoy59XkUjvfwLjmtKEoh/G1kkmO2xgMmG3EhPOzFa8o0r1mqqGwZjoVESNN1A+kAVjw0BIaMneFWkdyZDzwTvwaHTE0Xo9wgSZecFK/DNn+3tOVTZe2S5MWWR9JF1lWma6TXp+1zF3zD3zkPqfvLvMo/7Su2cemae0C1IsURf/C+uAzYaz6sW2O9WI5V7Vxbm8M+MJHoy590wDAAA=","debug_symbols":"pZXLroMgEIbfhbULhpvSVzk5aailDQlBQ7XJiem7H7SidYFpZDXK+M2NP86ArvrS38/G3ZoHOv0M6OKNteZ+tk2tOtO4cDq8ChRfz53XOhyhD3+gWuW169DJ9dYW6KlsP330aJWbbKd88OICaXcNNgS8GavHp1ex0jiNAsgZBr7inGx4SPOElzNPymrl2YYnO/kJjflZkqdpnnIy8wzEwgu+4dlO/RTHAggFOBKBVHKJgEkqgti7AxGbAKj4kRpKEMs1UJyKUO3UUJbLRZQy2YVMR5CMzwEkrw7wgMkyBSz4kR4kXsQsSbKHPTUziGOsREqNQDPlDCxTz8Cz5Qj5etyt4jtBQr4iIVeSkK9JOCjK3/CmauM3SwHhcewFgrchb0PDIMe/01N5oy5Wz+vj1rv6Y5t0f230xH3T+qbW197rMcnkC2n/AQ==","file_map":{"52":{"source":"use super::cipher::poseidon_decrypt;\n\n#[export]\npub fn get_key_commitment(key: [Field; 2], salt: Field) -> Field {\n    super::utils::commit(key, salt)\n}\n\n// #[export]\n// fn encrypt_key(master_key: Field, key: Field, nonce: Field) -> Field {\n//     super::cipher::encrypt_single(master_key, key, nonce, 0)\n// }\n\n// #[export]\n// fn decrypt_key(enc_master_key: Field, key: Field, nonce: Field) -> Field {\n//     super::cipher::decrypt_single(enc_master_key, key, nonce, 0)\n// }\n\n#[export]\npub fn decrypt_packet(\n    ciphers: [Field; 510 + 1],\n    key: [Field; 2],\n    nonce: Field,\n) -> [Field; 510] {\n    poseidon_decrypt(ciphers, key, nonce)\n}\n\n#[export]\nfn derive_public_key(private_key: Field) -> [Field; 2] {\n    super::ecdh::derive_public_key(private_key)\n}\n\n#[export]\nfn derive_shared_key(private_key: Field, public_key_packed: [Field; 2]) -> Field {\n    super::ecdh::derive_shared_key(private_key, public_key_packed)\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/exports.nr"},"54":{"source":"use poseidon::{poseidon2::Poseidon2};\n\n#[field(bn254)]\npub fn poseidon2_hash<let N: u32>(value: [Field; N]) -> Field {\n    Poseidon2::hash(value, N)\n}\n\n#[field(bn254)]\npub fn commit<let N: u32>(value: [Field; N], salt: Field) -> Field {\n    poseidon2_hash([poseidon2_hash(value), salt])\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/utils.nr"},"65":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}}};

export async function get_key_commitment(key: Field[], salt: Field, foreignCallHandler?: ForeignCallHandler): Promise<Field> {
  const program = new Noir(get_key_commitment_circuit);
  const args: InputMap = { key, salt };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field;
}
export type saleInputType = {
  key_commitment: Field;
  from_pub: Field[];
  to_pub: Field[];
  nonce: Field;
  master_key: Field;
  private_key: Field;
  salt: Field;
}

export type saleReturnType = Field;
export const sale_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"key_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"from_pub","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"to_pub","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"nonce","type":{"kind":"field"},"visibility":"public"},{"name":"master_key","type":{"kind":"field"},"visibility":"private"},{"name":"private_key","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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udfjWWMP8LnX41lnD/C51+NZZw/wudfjWWcP8LnX41lnD/C51+NZZw/wudfjmbIH+Nzr8UzZA3zu9Xim7AE+93o8U/YAn3s9nil7gM+9Hs+MPcDnXo9nxh7gc6/HM2MP8LnX45mxB/jc6/HM2AN87vV4NtgDfO71eDbYA3zu9Xg22AN87vV4NtgDfO71eDbYA3zu9Xg22QN87vV4NtkDfO71eDbZA3zu9Xg22QN87vV4NtkDfO51e+Zzr9szn3vdnvnc6/bM5163Zz73uj3zudftmc+9bs987nV75nOv2zOfe92e+dzr9sznXrdnPve6PfO51+2Zz71uz3zudXvmc6/bM5973Z753Ov2zOdet2c+97o987nX7ZnPvW7PfO4V5ztu2QN87nV75nOv2zOfez2eVfYAn3s9noE9wOdej2dgD/C51+MZ2AN87vV4BvYAn3s9noE9wOdej2eNPcDnXo9njT3A516PZ409wOdej2eNPcDnXo9njT3A516PZ509wOdej2edPcDnXo9nnT3A516PZ509wOdej2edPcDnXo9nyh7gc6/HM2UP8LnX45myB/jc6/FM2QN87vV4puwBPvd6PDP2AJ97PZ4Ze4DPvR7PjD3A516PZ8YeAGMP8LnX45mxB/jc6/FssAf43OvxbLAH+Nzr8WywB/jc6/FssAf43OvxbLAH+Nzr8WyyB/jc6/Fssgf43OvxbLIH+Nzr8WyyB/jc6/Fssgf43Ov2zOdet2c+97o987nX7ZnPvW7PfO51e+Zzr9szn3vdnvnc6/bM5163Zz73uj3zudftmc+9bs987nV75nOv2zOfe92e+dzr9sznXrdnPve6PfO51+2Zz71uz3zudXvmc6/bM5973Z753Ov2zOdet2c+97o987nX41llD/C51+MZ2AN87vV4BvYAn3s9noE9wOdej2dgD/C51+MZ2AN87vV41tgDfO71eNbYA3zu9XjW2AN87vV41tgDfO71eNbYA3zu9XjW2QN87vV41tkDfO71eNbZA3zu9XjW2QN87vV41tkDfO71eKbsAT73ejxT9gCfez2eKXuAz70ez5Q9wOdej2fKHuBzr8czYw/wudfjmbEH+Nzr8czYA3zu9Xhm7AE+93o8M/YAn3s9ng32AJ97PZ4N9gCfez2eDfYAn3s9ng32AJ97PZ4N9gCfez2eTfYAn3s9nk32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mTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTAKmTCETBhCJgwhE4aQCUPIhCFkwhAyYQiZMIRMGEImDCEThpAJQ8iEIWTCEDJhCJkwhEwYQiYMIROGkAlDyIQhZMIQMmEImTCETBhCJgwhE4aQCUPIhCFkwhAyYQiZMIRMGEImDCEThpAJQ8iEIWTCEDJhCJkwhEwYQiYMIROGkAlDyIQhZMIQMmEImTCETBhCJgwhE4aQCUPIhCFkwhAyYQiZMIRMGEImDCEThpAJQ8iEIWTCEDJhCJkwhEwYQiYMIROGkAlDyIQhZMIQMmEImTCETBhCJgwhE4aQCUPIhCFkwhAyYQiZMIRMGEImDCEThpAJQ8iEIWTCEDJhCJkwhEwYQiYMIROGkAlDyIQhZMIQMmEImTCETBhCJgwhE4aQCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCaOSCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJA2TCAJkwQCYMkAkDZMIAmTBAJgyQCQNkwgCZMEAmDJAJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5EJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJo5MJQ8mEoWTCUDJhKJkwlEwYSiYMJROGkglDyYShZMJQMmEomTCUTBhKJgwlE4aSCUPJhKFkwlAyYSiZMJRMGEomDCUThpIJQ8mEoWTCUDJhKJkwlEwYSiYMJROGkglDyYShZMJQMmEomTCUTBhKJgwlE4aSCUPJhKFkwlAyYSiZMJRMGEomDCUThpIJQ8mEoWTCUDJhKJkwlEwYSiYMJROGkglDyYShZMJQMmEomTCUTBhKJgwlE4aSCUPJhKFkwlAyYSiZMJRMGEomDCUThpIJQ8mEoWTCUDJhKJkwlEwYSiYMJROGkglDyYShZMJQMmEomTCUTBhKJgwlE4aSCUPJhKFkwlAyYSiZMJRMGEomDCUThpIJQ8mEoWTCUDJhaDJhSyZsyYQtmbAlE7ZkwpZM2JIJWzJhSyZsyYQtmbAlE7ZkwpZM2JIJWzJhSyZsyYQtmbAlE7ZkwpZM2JIJWzJhSyZsyYQtmbAlE7ZkwpZM2JIJWzJhSyZsyYQtmbAlE7ZkwpZM2JIJWzJhSyZsyYQtmbAlE7ZkwpZM2JIJWzJh2+9L9l2sezP/Xc+S4WfmWTJc17Nk+El6lpxy3dtwBc+SU6572/Z5lpzyurde9l1MlitLrvK377/7nx9+/emH//j5x79/92//uv75X//85S//+Omvv5x//uP//S1+8h+//vTzzz/995//9utf//Ljf/7z1x///PNf/7J+9l05//n39dxc7v7p+++uR/Dv19WK76/P+te/sP51PfjrAa+frV+9zub768rG+uf63euj7nXL8aff/Kb/2r+zvonxIk7rf9b8n9cNL1Tzp99+++1Pv/1/","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use super::utils::poseidon2_hash;\nuse poseidon::poseidon2_permutation;\n\n#[field(bn254)]\nfn compute_pad(key: Field, nonce: Field, counter: u32) -> Field {\n    poseidon2_hash([key, nonce, counter as Field])\n}\n\n#[field(bn254)]\npub fn encrypt_single(plains: Field, key: Field, nonce: Field, counter: u32) -> Field {\n    plains + compute_pad(key, nonce, counter)\n}\n\n#[field(bn254)]\npub fn decrypt_single(ciphers: Field, key: Field, nonce: Field, counter: u32) -> Field {\n    ciphers - compute_pad(key, nonce, counter)\n}\n\n#[field(bn254)]\npub fn encrypt<let N: u32>(plains: [Field; N], key: Field, nonce: Field) -> [Field; N] {\n    plains.mapi(|i, p| encrypt_single(p, key, nonce, i))\n}\n\n#[field(bn254)]\npub fn decrypt<let N: u32>(ciphers: [Field; N], key: Field, nonce: Field) -> [Field; N] {\n    ciphers.mapi(|i, c| decrypt_single(c, key, nonce, i))\n}\n\n#[field(bn254)]\npub fn poseidon_encrypt<let N: u32>(\n    plains: [Field; N],\n    key: [Field; 2],\n    nonce: Field,\n) -> [Field; N + 1] {\n    assert(nonce.lt(0x100000000000000000000000000000000));\n\n    let padded_nonce = nonce + (N as Field) * 0x100000000000000000000000000000000;\n    let mut state: [Field; 4] = [0, key[0], key[1], padded_nonce];\n\n    let state_len = state.len();\n    assert(N >= state_len - 1);\n\n    let mut ciphers: [Field; N + 1] = [0; N + 1];\n\n    for i in 0..(N / (state_len - 1)) {\n        state = poseidon2_permutation(state, state_len);\n\n        for j in 1..state_len {\n            let index = i * (state_len - 1) + j - 1;\n            state[j] += plains[index];\n            ciphers[index] = state[j];\n        }\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    for i in (N - (N % (state_len - 1)))..N {\n        let index = (i % (state_len - 1)) + 1;\n        state[index] += plains[i];\n        ciphers[i] = state[index];\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    ciphers[N] = state[1];\n    ciphers\n}\n\n#[field(bn254)]\npub fn poseidon_decrypt<let N: u32>(\n    ciphers: [Field; N + 1],\n    key: [Field; 2],\n    nonce: Field,\n) -> [Field; N] {\n    assert(nonce.lt(0x100000000000000000000000000000000));\n\n    let padded_nonce = nonce + (N as Field) * 0x100000000000000000000000000000000;\n    let mut state: [Field; 4] = [0, key[0], key[1], padded_nonce];\n\n    let state_len = state.len();\n    assert(N >= state_len - 1);\n\n    let mut plains: [Field; N] = [0; N];\n\n    for i in 0..(N / (state_len - 1)) {\n        state = poseidon2_permutation(state, state_len);\n\n        for j in 1..state_len {\n            let index = i * (state_len - 1) + j - 1;\n            plains[index] = ciphers[index] - state[j];\n            state[j] = ciphers[index];\n        }\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    for i in (N - (N % (state_len - 1)))..N {\n        let index = (i % (state_len - 1)) + 1;\n        plains[i] = ciphers[i] - state[index];\n        state[index] = ciphers[i];\n    }\n\n    state = poseidon2_permutation(state, state_len);\n    assert(ciphers[N] == state[1]);\n    plains\n}\n\n#[test]\nfn test_e2e() {\n    let key = 0x1ff18c97cd54b27391280a1f24cc94ef8c05e421525eb05bd4ded690735bf961;\n    let nonce = 1337;\n\n    let msg = [22405534230753963835153736737; 256]; // \"Hello world!\"\n    let encrypted = encrypt(msg, key, nonce);\n    let new_msg = decrypt(encrypted, key, nonce);\n\n    assert(msg == new_msg);\n\n    println(f\"Key: {key}\");\n    println(f\"nonce: {nonce}\");\n\n    println(f\"Original: {msg}\");\n    println(f\"Encrypted: {encrypted}\");\n    println(f\"Decrypted: {new_msg}\");\n}\n\n#[test]\nfn test_e2e_poseidon() {\n    let key: [Field; 2] = [\n        0x1ff18c97cd54b27391280a1f24cc94ef8c05e421525eb05bd4ded690735bf961,\n        0x1ff18c97cd54b27391280a1f24cc94ef8c05e421525eb05bd4ded690735bf961,\n    ];\n    let nonce = 1337;\n\n    let msg = [22405534230753963835153736737; 1024]; // \"Hello world!\"\n    let encrypted = poseidon_encrypt(msg, key, nonce);\n    let new_msg = poseidon_decrypt(encrypted, key, nonce);\n\n    assert(msg == new_msg);\n\n    println(f\"Key: {key}\");\n    println(f\"nonce: {nonce}\");\n\n    println(f\"Original: {msg}\");\n    println(f\"Encrypted: {encrypted}\");\n    println(f\"Decrypted: {new_msg}\");\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/cipher.nr"},"51":{"source":"use noir_edwards::{ScalarField, bjj::BabyJubJub, Curve, CurveTrait};\nuse super::utils::poseidon2_hash;\n\n// [8]G precalculated\nglobal BASE8_POINT: [Field; 2] = [\n    5299619240641551281634865583518297030282874472190772894086521144482721001553,\n    16950150798460657717958625567821834550301663161624707787222815936182638968203,\n];\n\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n\n#[field(bn254)]\npub fn derive_public_key(private_key: Field) -> [Field; 2] {\n    let private_scalar: ScalarField<64> = ScalarField::from(private_key);\n    let base8_point: BabyJubJub = Curve::new(BASE8_POINT[0], BASE8_POINT[1]);\n    let point = base8_point.mul(private_scalar);\n    [point.x, point.y]\n}\n\n#[field(bn254)]\npub fn derive_shared_key(private_key: Field, public_key_packed: [Field; 2]) -> Field {\n    let private_scalar: ScalarField<64> = ScalarField::from(private_key);\n    let point: BabyJubJub = Curve::new(public_key_packed[0], public_key_packed[1]);\n    let shared_key = point.mul(private_scalar);\n    shared_key.x\n}\n\n#[test]\nfn test_e2e() {\n    let a_key = poseidon2_hash([0]);\n    let a_pubkey = derive_public_key(a_key);\n\n    let b_key = poseidon2_hash([1]);\n    let b_pubkey = derive_public_key(b_key);\n\n    let key_1 = derive_shared_key(a_key, b_pubkey);\n    let key_2 = derive_shared_key(b_key, a_pubkey);\n\n    assert(key_1 == key_2);\n\n    println(f\"Alice public key: {a_pubkey}\");\n    println(f\"Alice private key: {a_key}\");\n    println(\"\");\n    println(f\"Bob public key: {b_pubkey}\");\n    println(\"\");\n    println(f\"Shared Key 1: {key_1}\");\n    println(f\"Shared Key 2: {key_2}\");\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/ecdh.nr"},"54":{"source":"use poseidon::{poseidon2::Poseidon2};\n\n#[field(bn254)]\npub fn poseidon2_hash<let N: u32>(value: [Field; N]) -> Field {\n    Poseidon2::hash(value, N)\n}\n\n#[field(bn254)]\npub fn commit<let N: u32>(value: [Field; N], salt: Field) -> Field {\n    poseidon2_hash([poseidon2_hash(value), salt])\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/common/src/utils.nr"},"56":{"source":"mod scalar_field;\nmod test;\npub mod bjj;\n\npub use crate::scalar_field::ScalarField;\nuse std::ops::{Add, Neg, Sub};\n\npub struct Curve<Params> {\n    pub x: Field,\n    pub y: Field,\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### T R A I T S\n// ####################################################################################################################\n// ####################################################################################################################\n\n/// Parametrises a Twisted Edwards curve\ntrait TECurveParameterTrait {\n    fn a() -> Field; // twisted edward curve parameter a\n    fn d() -> Field; // twisted edward curve parameter d\n    fn gen() -> (Field, Field); // generator point x/y coordinates\n}\n\n/// Defines methods that a valid Curve implementation must satisfy\npub trait CurveTrait<Params>: Add + Sub + Eq + Neg + Default {\n    fn new(x: Field, y: Field) -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn dbl(self) -> Self;\n    fn mul<let NScalarSlices: u32>(self, x: ScalarField<NScalarSlices>) -> Self;\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self;\n\n    fn eq(self, x: Self) -> bool {\n        self == x\n    }\n    fn is_zero(self) -> bool {\n        self == Self::zero()\n    }\n\n    fn is_on_curve(self) -> bool;\n    fn assert_is_on_curve(self);\n    fn assert_equal(self, other: Self);\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### C O N S T R A I N E D    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> std::default::Default for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Returns point at infinity\n    ///\n    /// Cost: 0 gates\n    fn default() -> Self {\n        Curve::zero()\n    }\n}\n\nimpl<Params> std::ops::Add for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self + other`\n    ///\n    /// Cost: 7 gates\n    fn add(self, other: Self) -> Self {\n        Curve::add_internal(self, other, Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::ops::Neg for Curve<Params> {\n    /// Negate a point\n    ///\n    /// Cost: usually 0, will cost 1 gate if the `x` coordinate needs to be converted into a witness\n    fn neg(self) -> Self {\n        Curve { x: -self.x, y: self.y }\n    }\n}\n\nimpl<Params> std::ops::Sub for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self - other`\n    ///\n    /// Cost: 7 gates\n    fn sub(self, other: Self) -> Self {\n        Curve::add_internal(self, other.neg(), Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::cmp::Eq for Curve<Params> {\n    /// Compute `self == other`\n    ///\n    /// Cost: 6 gates\n    fn eq(self, other: Self) -> bool {\n        (self.x == other.x) & (self.y == other.y)\n    }\n}\n\nimpl<Params> std::convert::From<(Field, Field)> for Curve<Params> {\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    ///\n    /// Cost: 0 gates\n    fn from((x, y): (Field, Field)) -> Self {\n        Curve { x, y }\n    }\n}\n\nimpl<Params> CurveTrait<Params> for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n\n    /// Construct a new point\n    ///\n    /// If you know the x/y coords form a valid point DO NOT USE THIS METHOD\n    /// This method calls `assert_is_on_curve` which costs 3 gates.\n    /// Instead, directly construct via Curve{x, y} or use from((x, y))\n    ///\n    /// Cost: 3 gates\n    fn new(x: Field, y: Field) -> Self {\n        let result = Curve { x, y };\n        result.assert_is_on_curve();\n        result\n    }\n\n    /// Return the Identity element (point at infinity)\n    ///\n    /// Cost: 0 gates\n    fn zero() -> Self {\n        Curve { x: 0, y: 1 }\n    }\n\n    /// Return the Generator of the group\n    ///\n    /// Cost: 0 gates (assuming Params trait returns values known at compile time!)\n    fn one() -> Self {\n        let (x, y) = Params::gen();\n        Curve { x, y }\n    }\n\n    /// Validate a point is on the curve\n    ///\n    /// cheaper than `is_on_curve` (assert is cheaper than returning a bool)\n    ///\n    /// Cost: 3 gates\n    fn assert_is_on_curve(self) {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        assert(t2 == t3);\n    }\n\n    /// Constrain two points to equal each other\n    ///\n    /// Cheaper than `assert(self == other)` because no need to return a bool\n    ///\n    /// Cost: 0-2 gates (can do these asserts with just copy constraints)\n    fn assert_equal(self, other: Self) {\n        assert(self.x == other.x);\n        assert(self.y == other.y);\n    }\n\n    /// Return a bool that describes whether the point is on the curve\n    ///\n    /// If you don't need to handle the failure case, it is cheaper to call `assert_is_on_curve`\n    ///\n    /// Cost: 5 gates\n    fn is_on_curve(self) -> bool {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        (t2 == t3)\n    }\n\n    /// Compute `self + self`\n    ///\n    /// Cost: 5 gates\n    fn dbl(self) -> Self {\n        Curve::dbl_internal(self, Params::a(), Params::d())\n    }\n\n    /// Compute `self * scalar`\n    ///\n    /// Uses the Straus method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows:\n    ///      1: computing the Straus point lookup table (169 gates)\n    ///      2: 252 point doublings (1260 gates)\n    ///      3: 63 point additions (441 gates)\n    ///      4: 126 table reads with runtime index (252 gates)\n    ///\n    /// Cost: 2122 gates + cost of creating ScalarField (110 gates)\n    fn mul<let NScalarSlices: u32>(self: Self, scalar: ScalarField<NScalarSlices>) -> Self {\n        // define a, d params locally to make code more readable (shouldn't affect performance)\n        let a = Params::a();\n        let d = Params::d();\n\n        // Construct tables of precomputed point coordinates.\n        let (table_x, table_y): ([Field; 16], [Field; 16]) = self.compute_straus_point_table(a, d);\n\n        // Initialize the accumulator with the point that maps to the first (most significant) scalar slice\n        let idx = scalar.base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: table_x[idx], y: table_y[idx] };\n\n        // Execute a double-and-add subroutine\n        // 1. Compute `accumulator = accumulator * 16`\n        // 2. Extract 4-bits from the scalar multiplier and\n        //    use them to retrieve the corresponding point from our point table\n        // Note: this is similar to the \"double and add\" scalar multiplication method, except we use base16 instead of base2!\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            let idx = scalar.base4_slices[i] as u32;\n            let x = table_x[idx];\n            let y = table_y[idx];\n            accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n        }\n\n        // todo fix\n        if (scalar.skew) {\n            accumulator = accumulator - self;\n        }\n        accumulator\n    }\n\n    /// compute `points[0] * scalar[0] + ... + points[N-1] * scalar[N-1]`\n    ///\n    /// Is cheaper than `mul` when processing >1 point due to reduced number of point doublings\n    /// uses the Straus MSM method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows\n    /// PER POINT costs:\n    ///      1: computing the Straus point lookup table (169N gates)\n    ///      2: 63 point additions (441N gates)\n    ///      3: 126 table reads with runtime index (252N gates)\n    ///\n    /// Additional costs:\n    ///      1. 252 point doublings 1260 gates\n    ///\n    /// Cost: 1260 + 862N + cost of creating ScalarField (110N gates)\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self {\n        let a = Params::a();\n        let d = Params::d();\n\n        // Generalized version of `mul` for multiple points.\n        let mut point_tables: [([Field; 16], [Field; 16]); N] = [([0; 16], [0; 16]); N];\n        for j in 0..N {\n            point_tables[j] = points[j].compute_straus_point_table(a, d);\n        }\n\n        let idx = scalars[0].base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: point_tables[0].0[idx], y: point_tables[0].1[idx] };\n        for j in 1..N {\n            let idx = scalars[j].base4_slices[0] as u32;\n            let P = Curve { x: point_tables[j].0[idx], y: point_tables[j].1[idx] };\n            accumulator = accumulator.add_internal(P, a, d);\n        }\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            for j in 0..N {\n                let idx = scalars[j].base4_slices[i] as u32;\n                let x = point_tables[j].0[idx];\n                let y = point_tables[j].1[idx];\n                accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n            }\n        }\n\n        for j in 0..N {\n            if (scalars[j].skew == true) {\n                accumulator = accumulator - points[j];\n            }\n        }\n        accumulator\n    }\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### H E L P E R    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> Curve<Params> {\n\n    /// add two points together\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `add` :(\n    fn add_internal(self, other: Self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let x2 = other.x;\n        let y1 = self.y;\n        let y2 = other.y;\n        let (x, y, lambda) = unsafe { __add_unconstrained(x1, x2, y1, y2, a, d) };\n        let x1x2 = x1 * x2;\n        let x1y2 = x1 * y2;\n        std::as_witness(x1x2);\n        std::as_witness(x1y2);\n        let x_lhs = x * lambda * d + x - x1y2; // equals y1x2\n        let y_lhs = y * lambda * -d + y + x1x2 * a; // equals y1y2\n        let y1x2 = y1 * x2;\n        let y1y2 = y1 * y2;\n        std::as_witness(y1x2);\n        std::as_witness(y1y2);\n        let y1y2x1x2 = y1y2 * x1x2;\n        assert(x_lhs == y1x2);\n        assert(y_lhs == y1y2);\n        assert(y1y2x1x2 == lambda);\n        Self { x, y }\n    }\n\n    /// add a point to itself\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `dbl` :(\n    fn dbl_internal(self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let y1 = self.y;\n        let (x3, y3, _) = unsafe { __add_unconstrained(x1, x1, y1, y1, a, d) };\n        let x1x1a = x1 * x1 * a;\n        std::as_witness(x1x1a);\n        // t1 = a*x_1^2 + y_1^2\n        let t1 = y1 * y1 + x1x1a;\n        std::as_witness(t1);\n        // t3 = y_3 * (2 - a*x_1^2 + y_1^2) + 2*a*x_1^2\n        let t3 = y3 + y3 - t1 * y3 + x1x1a * 2;\n        // t3 == t1 implies y_3 * (2 - a*x_1^2 - y_1^2) + 2*a*x_1^2 == a*x_1^2 + y_1^2\n        // i.e. y_3 = y_1^2 - a*x_1^2 / (2 - a*x_1^2 - y_1^2)\n        assert(t3 == t1);\n        let t4 = x1 * y1;\n        std::as_witness(t4);\n        // x3 * t1 - t4 == t4 implies x_3 * (y_1^2 + a * x_1^2) = 2 * x_1 * y_1\n        // i.e. x_3 = 2 * x_1 * y_1 / (y_1^2 + a * x_1^2)\n        let t2 = x3 * t1 - t4;\n        assert(t2 == t4);\n        Self { x: x3, y: y3 }\n    }\n\n    /// Compute a 4-bit lookup table of point multiples for the Straus windowed scalar multiplication algorithm.\n    ///\n    /// Table contains [0, P, 2P, ..., 15P], which is used in the scalar mul algorithm to minimize the total number of required point additions\n    ///\n    /// It is cheaper to use ([Field; 16], [Field; 16]) than it is ([Curve; 16]).\n    /// This is because the compiler will represent [Curve; 16] in 1 ROM array (vs 2 for [Field; 16], [Field; 16]).\n    /// This means that any index into the ROM array for [Curve; 16] requires an additional arithmetic gate to process.\n    ///\n    ///      For example consider `let P: Curve = table[idx]`\n    ///      `table` will be a ROM array with 32 elements in it.\n    ///      The x-coordinates will be located at `2 * idx`\n    ///      The y-coordinates will be located at `2 * idx + 1`\n    ///      If `idx` is not known at compile time (for Straus it isnt), 2 arithmetic gates are required to evaluate `2 * idx`, `2 * idx + 1`\n    ///      before they can be used as arguments in a memory lookup protocol\n    ///\n    ///      Now consider `let P_x = table_x[idx]; let P_y = table_y[idx]`\n    ///      In this example, `idx` can be directly used as the argument into a memory lookup protocol for both tables.\n    ///\n    ///      For the Barretenberg backend, the cost of a Read-Only memory lookup is 2 gates,\n    ///      so splitting the x/y coordinates into separate tables means that the cost to lookup a point is 4 gates\n    ///      2 extra arithmetic gates would increase the cost by 50%, which we avoid by returning `([Field; 16], [Field; 16])` instead of `([Curve; 16])`\n    ///\n    /// Key cost components are as follows:\n    ///      1: Defining two size-16 lookup tables (2 gates per element, 32 elements = 64 gates)\n    ///      2: 15 point additions (7 * 5 = 105)\n    ///\n    /// Total Cost: 169 gates\n    fn compute_straus_point_table(self, a: Field, d: Field) -> ([Field; 16], [Field; 16]) {\n        let mut table_x: [Field; 16] = [0; 16];\n        let mut table_y: [Field; 16] = [0; 16];\n        table_x[8] = self.x;\n        table_y[8] = self.y;\n        let D = self.dbl_internal(a, d);\n        for i in 1..8 {\n            let Q = Self { x: table_x[7 + i], y: table_y[7 + i] };\n            let V = D.add_internal(Q, a, d);\n            table_x[8 + i] = V.x;\n            table_y[8 + i] = V.y;\n        }\n        for i in 0..8 {\n            table_x[i] = -table_x[15 - i];\n            table_y[i] = table_y[15 - i];\n        }\n        (table_x, table_y)\n    }\n}\n\n/// add points together, return output + lambda ter\nunconstrained fn __add_unconstrained(\n    x1: Field,\n    x2: Field,\n    y1: Field,\n    y2: Field,\n    a: Field,\n    d: Field,\n) -> (Field, Field, Field) {\n    let lambda = y1 * y2 * x1 * x2;\n    let y = (x1 * x2 * a - y1 * y2) / (lambda * d - 1);\n    let x = (x1 * y2 + y1 * x2) / (lambda * d + 1);\n    (x, y, lambda)\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/lib.nr"},"57":{"source":"use std::static_assert;\n\n/// ScalarField represents a scalar multiplier as a sequence of 4-bit slices\n///\n/// There is nuance to ScalarField, because twisted edwards curves generally have prime group orders that easily fit into a Field\n/// We can therefore obtain cheap conversions by simply summing up the bit slices and validate they equal the input scalar\n/// However...when converting arbitrary field elements (i.e. scalars that are multiples of a TE curve group order),\n/// we must perform additional checks when converting into 4-bit slices, as we must validate that the sum of the slices is smaller than the Field modulus (when evaluated over the integers)\n/// This is expensive and we would rather not do it! therefore ScalarField<N> is flexible.\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n///\n/// N.B. ScalarField bit values are not constrained to be smaller than the TE curve group order.\n/// ScalarField is used when performing scalar multiplications, where all operations wrap modulo the curve order\npub global TWO_POW_128: Field = 0x100000000000000000000000000000000;\npub global PLO: Field = 0x2833e84879b9709143e1f593f0000001;\npub global PHI: Field = 0x30644e72e131a029b85045b68181585d;\n\npub struct ScalarField<let N: u32> {\n    pub(crate) base4_slices: [u8; N],\n    pub(crate) skew: bool,\n}\n\nunconstrained fn get_wnaf_slices<let N: u32>(x: Field) -> ([u8; N], bool) {\n    let mut result: [u8; N] = [0; N];\n    let mut nibbles: [u8; N] = to_le_radix_16(x);\n\n    let skew: bool = nibbles[0] & 1 == 0;\n    nibbles[0] += skew as u8;\n    result[N - 1] = (nibbles[0] + 15) / 2;\n    for i in 1..N {\n        let mut nibble: u8 = nibbles[i];\n        result[N - 1 - i] = (nibble + 15) / 2;\n        if (nibble & 1 == 0) {\n            result[N - 1 - i] += 1;\n            result[N - i] -= 8;\n        }\n    }\n    (result, skew)\n}\n\nunconstrained fn from_wnaf_slices<let N: u32>(x: [u8; N], skew: bool) -> Field {\n    let mut result: Field = 0;\n\n    for i in 0..N {\n        result *= 16;\n        result += (x[i] as Field) * 2 - 15;\n    }\n    result -= skew as Field;\n    result\n}\n\nunconstrained fn get_borrow_flag(lhs_lo: Field, rhs_lo: Field) -> bool {\n    lhs_lo.lt(rhs_lo + 1)\n}\n\nunconstrained fn to_le_radix_16<let N: u32>(value: Field) -> [u8; N] {\n    // Round up on odd values of `N` to ensure space for last nibble.\n    let bytes = value.to_le_bytes::<(N + 1) / 2>();\n    let mut result: [u8; N] = [0; N];\n    for index in 0..(N / 2) {\n        result[index * 2] = bytes[index] & 0x0F; // Extract low nibble (bits 0-3)\n        result[index * 2 + 1] = (bytes[index] >> 4); // Extract high nibble (bits 4-7)\n    }\n    if (N & 1) == 1 {\n        let last_nibble = bytes[bytes.len() - 1];\n        // The last byte must have the top 4 bits empty.\n        (last_nibble as Field).assert_max_bit_size::<4>();\n        result[N - 1] = last_nibble;\n    }\n    result\n}\n\nimpl<let N: u32> std::convert::From<Field> for ScalarField<N> {\n\n    /// Construct from a field element\n    ///\n    /// if N >= 64 we perform extra checks to ensure the slice decomposition represents the same integral value as the input\n    /// (e.g. sum of slices != x + modulus)\n    fn from(x: Field) -> Self {\n        // the field elements have 254 bits max, so we do not need to support N > 64\n        static_assert(N <= 64, \"N must be at most 64\");\n        let mut result: Self = ScalarField { base4_slices: [0; N], skew: false };\n        let (slices, skew): ([u8; N], bool) = unsafe { get_wnaf_slices(x) };\n        result.base4_slices = slices;\n        result.skew = skew;\n        if (N < 64) {\n            let mut acc: Field = (slices[0] as Field) * 2 - 15;\n            for i in 1..N {\n                acc *= 16;\n                acc += (slices[i] as Field) * 2 - 15;\n            }\n            assert(acc - skew as Field == x);\n        } else {\n            // TODO: if num bits = 64, validate in sum of the bits is smaller than the Field modulus\n            let mut lo: Field = 0;\n            let mut hi: Field = 0;\n\n            for i in 0..32 {\n                lo *= 16;\n                lo += (slices[32 + i] as Field) * 2 - 15;\n                hi *= 16;\n                hi += (slices[i] as Field) * 2 - 15;\n            }\n\n            lo -= skew as Field;\n            // Validate that the integer represented by (lo, hi) is smaller than the integer represented by (plo, phi)\n\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            // Safety: we assert that the absolute value has less than 128 bits\n            let is_positive: bool = unsafe { get_borrow_flag(lo, TWO_POW_128) };\n\n            let abs_lo = (is_positive as Field) * lo + (1 - is_positive as Field) * (-lo);\n\n            abs_lo.assert_max_bit_size::<128>();\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            let borrow = unsafe { get_borrow_flag(PLO, abs_lo) as Field };\n            // we only need to check the rlo has 128 bits or less if lo is positive. if negative, the lo is already less than PLO\n            let rlo = is_positive as Field * (PLO - lo + borrow * TWO_POW_128 - 1)\n                + (1 - is_positive as Field) * (-lo); // -1 because we are checking a strict <, not <=\n            // is lo is positive, we need to check the hi is less than phi with the borrow flag subtracted\n            // if lo is negative, we have to check that hi * 2^128 < phi * 2^128 + abs_lo + plo\n            // to do this we first make a flag to check that abs_lo + plo is larger than 2^128 or not\n            // if they are larger, we check that hi < phi + 1 and otherwise we check that hi < phi\n            // Safety: we assert the when the flag is positive we have less than 128 bits\n            let threshold_flag: bool = unsafe { get_borrow_flag(abs_lo + PLO, TWO_POW_128) };\n            (threshold_flag as Field * (abs_lo + PLO)).assert_max_bit_size::<128>();\n            let rhi = is_positive as Field * (PHI - hi - borrow)\n                + (1 - is_positive as Field) * (PHI - hi + threshold_flag as Field);\n            // the rlo value would have 128 bits or less if positive and more if negative as the modulus is 254 bits\n            rlo.assert_max_bit_size::<128>();\n            rhi.assert_max_bit_size::<128>();\n        }\n        for i in 0..N {\n            (result.base4_slices[i] as Field).assert_max_bit_size::<4>();\n        }\n        result\n    }\n}\n\nimpl<let N: u32> std::convert::Into<Field> for ScalarField<N> {\n\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    fn into(self: Self) -> Field {\n        let mut acc: Field = 0;\n        for i in 0..N {\n            acc = acc * 16;\n            acc = acc + (self.base4_slices[i] as Field) * 2 - 15;\n        }\n        acc -= self.skew as Field;\n        acc\n    }\n}\n\nimpl<let N: u32> ScalarField<N> {\n\n    pub fn new() -> Self {\n        Self { base4_slices: [0; N], skew: false }\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.base4_slices[idx]\n    }\n}\n\n#[test]\nunconstrained fn test_wnaf() {\n    let result: Field = 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0;\n    let (t0, t1) = get_wnaf_slices::<64>(result);\n    let expected = from_wnaf_slices(t0, t1);\n    assert_eq(result, expected);\n}\n\n#[test]\nfn test_regression_wnaf() {\n    let a = 0x7b;\n    let s: ScalarField<64> = ScalarField::<64>::from(a);\n    let b: Field = ScalarField::<64>::into(s);\n    assert_eq(a, b);\n}\n\n#[test]\nunconstrained fn to_le_radix_16_works_with_odd_N() {\n    let input = 0x0f00;\n    let nibbles: [u8; 3] = to_le_radix_16(input);\n    assert_eq(nibbles, [0x0, 0x0, 0xf]);\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/scalar_field.nr"},"65":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/georgegeorge/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"69":{"source":"use common::{cipher::encrypt, ecdh::{derive_public_key, derive_shared_key}, utils::commit};\n\nfn main(\n    key_commitment: pub Field,\n    from_pub: pub [Field; 2],\n    to_pub: pub [Field; 2],\n    nonce: pub Field,\n    master_key: Field,\n    private_key: Field,\n    salt: Field,\n) -> pub Field {\n    assert(from_pub == derive_public_key(private_key));\n    assert(key_commitment == commit([master_key], salt));\n\n    let shared_key = derive_shared_key(private_key, to_pub);\n    encrypt([master_key], shared_key, nonce)[0]\n}\n\n#[test]\nfn test_main() {\n    // let a_key = Poseidon2::hash([0], 1);\n    // let a_pubkey = derive_public_key(a_key);\n\n    // let b_key = Poseidon2::hash([1], 1);\n    // let b_pubkey = derive_public_key(b_key);\n\n    // let mut msg = [0; FIELDS_PER_MESSAGE];\n    // let nonce = 0x123456789;\n    // let domain_tag = 0xdeadbeef;\n\n    // let msg_hash = Poseidon2::hash(msg, FIELDS_PER_MESSAGE);\n    // let commitment = commit(msg_hash, nonce, domain_tag);\n    // let cipher_text = main(\n    //     commitment,\n    //     b_pubkey,\n    //     a_pubkey,\n    //     nonce,\n    //     domain_tag,\n    //     msg_hash,\n    //     msg,\n    //     b_key,\n    // );\n\n    // let shared_key = derive_shared_key(a_key, b_pubkey);\n    // let recovered_msg = decrypt(cipher_text, shared_key, nonce, domain_tag);\n\n    // assert(msg == recovered_msg);\n}\n","path":"/Users/georgegeorge/WebstormProjects/bobiko/packages/circuits/crates/sale/src/main.nr"}}};

export async function sale(key_commitment: Field, from_pub: Field[], to_pub: Field[], nonce: Field, master_key: Field, private_key: Field, salt: Field, foreignCallHandler?: ForeignCallHandler): Promise<Field> {
  const program = new Noir(sale_circuit);
  const args: InputMap = { key_commitment, from_pub, to_pub, nonce, master_key, private_key, salt };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field;
}
